<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Swift Refresher"/><link rel="canonical" href="https://swiftrefresher.com/leetcode/blind-75-trees"/><meta name="twitter:url" content="https://swiftrefresher.com/leetcode/blind-75-trees"/><meta name="og:url" content="https://swiftrefresher.com/leetcode/blind-75-trees"/><title>Blind 75: Trees | Swift Refresher</title><meta name="twitter:title" content="Blind 75: Trees | Swift Refresher"/><meta name="og:title" content="Blind 75: Trees | Swift Refresher"/><meta name="description" content="Everything you need to know about Trees"/><meta name="twitter:description" content="Everything you need to know about Trees"/><meta name="og:description" content="Everything you need to know about Trees"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Swift Refresher"/></head><body class="bg-white font-sans leading-normal tracking-normal"><div class="pb-16"><nav class="fixed z-10 bg-gray-900 p-4 mt-0 w-full overflow-auto scrolling-touch"><div class="container mx-auto flex items-center"><div class="flex-shrink-0 text-white font-extrabold"><a class="flex text-white text-base no-underline hover:text-white hover:no-underline" href="/"><span class="block md:hidden md:w-auto pl-1">üèù</span><span class="hidden md:block w-0 md:w-auto pl-1">Swift Refresher</span></a></div><div class=" flex flex-no-wrap pl-4 text-sm"><ul class="list-reset flex justify-between items-center"><li class="mr-2"><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2" href="/">HOME</a></li><li><a class="inline-block py-2 px-2 text-white no-underline hover:underline whitespace-no-wrap" href="/leetcode">LEETCODE</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/ios-fundamentals">IOS-FUNDAMENTALS</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/SwiftUI">SWIFTUI</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/combine">COMBINE</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/about">ABOUT</a></li></ul></div></div></nav></div><div class="text-center pt-16 md:pt-32"><p class="text-xs md:text-sm text-casper-blue font-bold">24 OCTOBER 2022<span class="text-gray-900 px-1">/</span><a href="/tags/leetcode">LEETCODE</a></p><h1 class="font-bold break-normal text-3xl md:text-5xl max-w-6xl mx-auto">Blind 75: Trees</h1></div><div class="container max-w-5xl mx-auto "><div class="mx-0 sm:mx-6"><main class="bg-white w-full p-8 md:p-24 text-gray-800 leading-normal"><article class="prose prose-sm sm:prose-xl break-words"><h1>Intro</h1><p>A tree is a data structure that consists of nodes, with values and pointers to child nodes, which recursively form subtrees. Lets understand the structure of a Tree. Trees have a root node, and each node has 0 or more child nodes. Trees cannot contain cycles -- that is, Trees are top down and a node cannot reference anything above itself. Typically, tree questions are riddled with ambiguity and incorrect assumptions. Be careful! Always clarify with your interviewer all the details of the question.</p><p>The path from the root node to the leaf node is known as a 'branch'. A trees height, is the length of its longest branch. The depth of a tree, is the distance of root to node level.</p><p>You can think of trees like graphs that are acyclic, connected, directed, with an explicit root node, and all nodes have a single parent.</p><h3>Types of Trees</h3><ul><li>Binary Tree<ul><li>A binary tree is when each node has up to 2 children nodes. Not all trees are considered Binary trees</li><li>A node is called a "leaf" when it has no children nodes attached to itself</li></ul></li></ul><ul><li>Binary Search Tree<ul><li>A binary search tree is when every node fits into an ordering system. When all left descendants ‚â§ the current node value ‚â§ all right descendants</li><li>Some binary search trees may or may not have duplicate values. <strong>Clarify this</strong>!</li></ul></li></ul><ul><li>Balanced Tree<ul><li>A balanced tree is when left and right subtrees are the same size</li></ul></li></ul><ul><li>Complete Binary Tree<ul><li>A complete binary tree is when every level of the tree is filled from left to right</li></ul></li></ul><ul><li>Full Binary Tree<ul><li>A full binary tree is when every node has 0 or 2 children -- aka there are no nodes with only 1 child node</li></ul></li></ul><ul><li>Perfect Binary Tree<ul><li>A perfect binary tree is when the tree is both full and complete. All leaf nodes are at the same level, and this level has the maximum amount of nodes</li><li>Perfect trees have 2·µè-1 nodes, where k is the number of levels in a tree</li><li>Never assume a tree is perfect in an interview!</li></ul></li></ul><h3>Binary Tree Traversals</h3><p>There are 3 main methods of traversing a binary tree: in-order traversal, pre-order traversal, and post-order traversal. In a pre-order traversal, we arrive at the root node first, then traverse the left side, then the right side. In post-order traversal, we traverse the left side, then the right side, then the root node. And finally in in-order traversal we traverse the left side, then the root node, then the right side. An easy way to think of these is the in reference to the root node. The order in which we traverse depends on when we visit the root node. For example, post-order traversal has us visit the root node last (or post-everything else).</p><h3>Binary Heaps</h3><p>A min heap is a complete binary tree, where each node is smaller than its children. The root node is the minimum of the entire structure. A max heap is the same rules but vice versa -- the root node is the maximum &amp; nodes are larger than its children.</p><p>We should take a look at some operations on a min/max heap:</p><ul><li>When we insert into a heap, we insert the new value at the bottom - right most spot to maintain the completeness of the tree. Then we will fix the tree by swapping the new element with its parent until we find the correct spot. All-in-all this will take O(logN) time.</li><li>Extracting the min/max element is easy. We remove the root node, and swap with the last element. Then we bubble down the new element until it is in place. Swap as we go down. All-in-all this will take O(logN) time.</li></ul><h3>Tries</h3><p>Tries (or prefix tree) is a variant of a n-ary tree in which characters are stored at each node. Each path down the tree represents a word. Tries are most commonly used to store entire english language for quick prefix lookups. Hash Tables are fast, but cannot tell us valid prefixes of words.</p><hr><h1>Invert Binary Tree</h1><p>The worlds most popular tree problem!! Time to dive in.</p><img src="/invertbinarytree.png"/><p>So as you will find with most Tree problems, we can solve this recursively or iteratively. Lets go over both, but keep in mind! We lose some space efficiency when we go with a recursive solution.</p><h3>[ Recursive ]</h3><h3>[ O(n) worst time + O(n) space ]</h3><p>So at first glance, the recursive solution would actually be pretty easy. When I solve recursive problems, I start at the base case, and build out from there. In this problem, our base case is if the root node is nil, we should return nil in our function. Another base case is if the root has no children, we just return the root. After that, it is about swapping the left and right side.</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">input</span> <span class="k">is</span> <span class="kc">nil</span> <span class="k">return</span> <span class="kc">nil</span>
<span class="bp">swap</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">of</span> <span class="n">the</span> <span class="n">root</span>
<span class="k">return</span> <span class="n">the</span> <span class="n">root</span>
</div></code></pre><p>As we discussed earlier, the space complexity here, is O(n) where n is the number of nodes in the call stack. We know at every level, we will need to recurse the left and right nodes to swap them. The time complexity here is O(k) where K represents the number of nodes in the tree. We know we need to swap all of them at least once.<br><br><br>The final code is pretty simple:</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">root</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
<span class="kd">let</span> <span class="nv">left</span> <span class="p">=</span> <span class="n">invertTree</span><span class="p">(</span><span class="n">root</span><span class="p">?.</span><span class="kr">left</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">right</span> <span class="p">=</span> <span class="n">invertTree</span><span class="p">(</span><span class="n">root</span><span class="p">?.</span><span class="kr">right</span><span class="p">)</span>
<span class="n">root</span><span class="p">?.</span><span class="kr">left</span> <span class="p">=</span> <span class="kr">right</span>
<span class="n">root</span><span class="p">?.</span><span class="kr">right</span> <span class="p">=</span> <span class="kr">left</span>
<span class="k">return</span> <span class="n">root</span>
</div></code></pre><h3>[ Iterative with a Queue (BFS) ]</h3><h3>[ O(n) worst time + O(n) space ]</h3><p>We can use Breadth-First search for an iterative solution. In Swift, a Queue is really just an array, where we utilize the <strong>removeFirst()</strong> function on sequences to simulate array removal. First we want to add the root node to our array. While our queue is not empty, its safe to assume we have more nodes to visit, and to invert. At every step, we will remove the first element from our queue, and invert it. It follows very similar logic to our recursive solution, we just have another data structure involved.</p><pre><code><div class="highlight"><span></span><span class="n">create</span> <span class="n">a</span> <span class="n">queue</span>
<span class="n">add</span> <span class="n">root</span> <span class="n">to</span> <span class="n">queue</span>
<span class="k">while</span> <span class="n">queue</span> <span class="k">is</span> <span class="n">not</span> <span class="n">empty</span>
    <span class="n">pop</span> <span class="bp">first</span> <span class="n">element</span> <span class="k">in</span> <span class="n">queue</span>
    <span class="n">invert</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> 
    <span class="n">add</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span>
</div></code></pre><p>The time complexity here once again is O(N) because we need to visit every node to invert it. Our space complexity is lightened due to the lack of recursive call stack, but we lose that efficiency by introducing a Queue that grows with every node we have added to it. This on average comes out to be O(n) as well.</p><p>Here is the final implementation:</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nv">queue</span> <span class="p">=</span> <span class="p">[</span><span class="n">TreeNode</span><span class="p">?]()</span>
<span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

<span class="k">while</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">node</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">node</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">continue</span> <span class="p">}</span>
    <span class="kd">let</span> <span class="nv">left</span> <span class="p">=</span> <span class="n">node</span><span class="p">?.</span><span class="kr">left</span>
    <span class="kd">let</span> <span class="nv">right</span> <span class="p">=</span> <span class="n">node</span><span class="p">?.</span><span class="kr">right</span>
    <span class="n">node</span><span class="p">?.</span><span class="kr">left</span> <span class="p">=</span> <span class="kr">right</span>
    <span class="n">node</span><span class="p">?.</span><span class="kr">right</span> <span class="p">=</span> <span class="kr">left</span>
    
    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">?.</span><span class="kr">left</span><span class="p">)</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">?.</span><span class="kr">right</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">root</span>
</div></code></pre><hr><h1>Maximum Depth of Binary Tree</h1><p>Building upon our previous knowledge, we are presented with the following:</p><img src="/maximumdepthofbinarytree.png"/><p>Not too bad! This too, can be solved iteratively or recursively.</p><h3>[ Recursive ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>The idea behind the recursive solution, is very similar to the "Invert Binary Tree" problem we saw earlier. We want to traverse every node, and at each level, we want to keep track of the depth at any given moment. For example, if we have a tree with 1 parent node and 2 children nodes, the maximum depth will be whichever side (left or right) has a larger depth.</p><p>Solving for the base case first, the base case is if the root node is nil, we return a depth of 0. Ultimately we want to append 1 to every level node we are at, and append 1 to the current depth. Something like this:</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">root</span> <span class="k">is</span> <span class="kc">nil</span> <span class="k">return</span> <span class="mi">0</span>
<span class="kr">get</span> <span class="n">depth</span> <span class="n">of</span> <span class="kr">left</span><span class="p">,</span> <span class="n">recursively</span>
<span class="kr">get</span> <span class="n">depth</span> <span class="n">of</span> <span class="kr">right</span><span class="p">,</span> <span class="n">recursively</span> 
<span class="kr">get</span> <span class="n">the</span> <span class="bp">max</span> <span class="n">of</span> <span class="kr">left</span> <span class="n">vs</span> <span class="kr">right</span>
<span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">the</span> <span class="n">maximum</span> <span class="n">side</span>
</div></code></pre><p>The time complexity here is pretty simple. We traverse all nodes, both left and right. So the time complexity is O(n) where n is the number of nodes in the tree. The space complexity would be constant, except we need to keep track of the call stack for all the recursive calls. So in this case the space complexity is O(n) where n is the number of nodes in the call stack.</p><p>The real implementation is pretty simple, like so:</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">root</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>
<span class="kd">let</span> <span class="nv">left</span> <span class="p">=</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">?.</span><span class="kr">left</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">right</span> <span class="p">=</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">?.</span><span class="kr">right</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">maxi</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="kr">left</span><span class="p">,</span> <span class="kr">right</span><span class="p">)</span>
<span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">maxi</span> 
</div></code></pre><p>But now for the real test...the iterative solution!</p><h3>[ Iterative with a Stack (BFS) ]</h3><h3>[ O(n) worst time + O(n) space ]</h3><p>This is very similar to the invert binary tree problem, except our queue structure will be a little different. We want to, at each queue node, hold the depth of our tree node &amp; the node itself. For example, if I have a tree with a root node of (3), our queue will hold this node as a tuple of (3, 1) where 1 is the depth of the node at the given time. Other than that, we essentially have the same problem as the invert binary tree.</p><pre><code><div class="highlight"><span></span><span class="n">create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">of</span> <span class="n">tuples</span>
<span class="n">append</span> <span class="n">the</span> <span class="n">root</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span>
<span class="k">while</span> <span class="n">the</span> <span class="n">queue</span> <span class="k">is</span> <span class="n">not</span> <span class="n">empty</span>
    <span class="n">remove</span> <span class="bp">first</span> <span class="n">node</span> <span class="n">item</span> <span class="n">from</span> <span class="n">the</span> <span class="n">queue</span>
    <span class="n">update</span> <span class="n">global</span> <span class="bp">max</span> <span class="n">from</span> <span class="n">our</span> <span class="n">queue</span> <span class="n">value</span>
    <span class="k">if</span> <span class="n">there</span> <span class="k">is</span> <span class="n">a</span> <span class="kr">left</span> <span class="n">value</span> <span class="k">for</span> <span class="n">our</span> <span class="n">queue</span> <span class="n">node</span>
        <span class="n">add</span> <span class="n">the</span> <span class="kr">left</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">and</span> <span class="n">append</span> <span class="n">the</span> <span class="n">depth</span> <span class="n">by</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">there</span> <span class="k">is</span> <span class="n">a</span> <span class="kr">right</span> <span class="n">value</span> <span class="k">for</span> <span class="n">our</span> <span class="n">queue</span> <span class="n">node</span>
        <span class="n">add</span> <span class="n">the</span> <span class="kr">right</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">and</span> <span class="n">append</span> <span class="n">the</span> <span class="n">depth</span> <span class="n">by</span> <span class="mi">1</span>
        
<span class="k">return</span> <span class="n">the</span> <span class="n">global</span> <span class="bp">max</span>
</div></code></pre><p>Nothing much has changed here in terms of time complexity, as we still need to visit every single node in the tree. This comes out to O(n) time, and meanwhile our space complexity is lightened due to the lack of recursive call stack, but we lose that efficiency by introducing a Queue that grows with every node we have added to it. This on average comes out to be O(n) as well.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nv">queue</span> <span class="p">=</span> <span class="p">[(</span><span class="n">TreeNode</span><span class="p">?,</span> <span class="nb">Int</span><span class="p">)]()</span>
<span class="kd">var</span> <span class="nv">globalMax</span> <span class="p">=</span> <span class="mi">0</span>
<span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="k">while</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span>
    <span class="n">globalMax</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">globalMax</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">left</span> <span class="p">=</span> <span class="n">node</span><span class="p">?.</span><span class="kr">left</span> <span class="p">{</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="kr">left</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">}</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">right</span> <span class="p">=</span> <span class="n">node</span><span class="p">?.</span><span class="kr">right</span> <span class="p">{</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="kr">right</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">globalMax</span>
</div></code></pre><p>Woohoo!</p><hr><h1>Same Tree</h1><p>Building upon our previous knowledge, we are presented with the following:</p><img src="/sametree.png"/><p>And you probably guessed it! We need to traverse our 2 input trees similar to the other problems. We can go about this recursively with DFS or using BFS and a queue</p><h3>[ Recursive ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>So the trick here is, if we go with a recursive solution, we need to cover all base cases. Since there are 2 trees, and every node on the tree has a chance to be nullable, we need to really think about this.</p><p>The base cases that come to mind, are:</p><ol><li>If both of the root nodes are null, return true as they are equal</li><li>If ONE of the root nodes is null, return false, as one is null and one is not, representing inequality</li><li>If the values of the nodes is not equal, then return false, as the nodes are not the same.</li></ol><p>Other than that, it is business as usual! We need to recurse left, and recurse right. As long as the left and right subtrees are equal, we have the same tree!</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">both</span> <span class="n">p</span> <span class="n">and</span> <span class="n">q</span> <span class="n">are</span> <span class="n">null</span> <span class="k">return</span> <span class="kc">true</span>
<span class="k">if</span> <span class="n">either</span> <span class="n">p</span> <span class="n">or</span> <span class="n">q</span> <span class="k">is</span> <span class="n">null</span> <span class="k">return</span> <span class="kc">false</span>
<span class="k">if</span> <span class="n">p</span> <span class="n">value</span> <span class="n">does</span> <span class="n">not</span> <span class="bp">equal</span> <span class="n">q</span> <span class="n">value</span> <span class="k">return</span> <span class="kc">false</span> 

<span class="n">recurse</span> <span class="kr">left</span>
<span class="n">recurse</span> <span class="kr">right</span>

<span class="k">if</span> <span class="kr">left</span> <span class="k">is</span> <span class="n">valid</span> <span class="n">AND</span> <span class="kr">right</span> <span class="k">is</span> <span class="n">valid</span><span class="p">,</span> <span class="k">return</span> <span class="kc">true</span>
</div></code></pre><p>The time complexity here is pretty simple: O(n) where n is equal to the number of nodes in the larger tree. We will need to visit every node in both so our time is limited to the larger tree. The space complexity here is O(n) where...you guessed it...n is equal to the recursive call stack! Same as the others.</p><p>Final product is like so:</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">p</span> <span class="p">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="n">q</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span> <span class="c1">// if both are nil </span>
<span class="k">if</span> <span class="n">p</span> <span class="p">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="n">q</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span> <span class="c1">// if one is nil</span>
<span class="k">if</span> <span class="n">p</span><span class="p">!.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">q</span><span class="p">!.</span><span class="n">val</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span> <span class="c1">// not equal values</span>
<span class="kd">let</span> <span class="nv">isLeftValid</span> <span class="p">=</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="p">!.</span><span class="kr">left</span><span class="p">,</span> <span class="n">q</span><span class="p">!.</span><span class="kr">left</span><span class="p">)</span> <span class="c1">// recurse left</span>
<span class="kd">let</span> <span class="nv">isRightValid</span> <span class="p">=</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="p">!.</span><span class="kr">right</span><span class="p">,</span> <span class="n">q</span><span class="p">!.</span><span class="kr">right</span><span class="p">)</span> <span class="c1">// recurse right</span>
<span class="k">return</span> <span class="n">isLeftValid</span> <span class="o">&amp;&amp;</span> <span class="n">isRightValid</span> <span class="c1">// return left and right are simultaneously valid </span>
</div></code></pre><h3>[ Iterative with a Queue (BFS) ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>So just like our other problems, to eliminate recursion we can introduce a new data structure to traverse the tree. We still need to keep our base cases in check though, as when we remove elements from the queue, we will make sure they follow our earlier rules</p><pre><code><div class="highlight"><span></span><span class="n">add</span> <span class="n">p</span> <span class="n">and</span> <span class="n">q</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span>
<span class="k">while</span> <span class="n">the</span> <span class="n">queue</span> <span class="k">is</span> <span class="n">not</span> <span class="n">empty</span> 
    <span class="n">remove</span> <span class="bp">first</span> <span class="n">from</span> <span class="n">queue</span> <span class="n">representing</span> <span class="n">p</span>
    <span class="n">remove</span> <span class="bp">first</span> <span class="n">from</span> <span class="n">queue</span> <span class="n">representing</span> <span class="n">q</span>
    <span class="n">check</span> <span class="n">our</span> <span class="n">bases</span> <span class="n">cases</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">the</span> <span class="n">values</span> <span class="n">are</span> <span class="n">not</span> <span class="bp">equal</span><span class="p">,</span> <span class="n">or</span> <span class="n">only</span> <span class="n">ONE</span> <span class="k">is</span> <span class="kc">nil</span> <span class="k">return</span> <span class="kc">false</span>
    <span class="n">add</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">of</span> <span class="n">each</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span>
</div></code></pre><p>The time complexity is O(n) where n is equal to the number of nodes in the larger tree. We stil need to visit every node in both trees so the time is constrained to the larger tree. And the introduction of the queue keeps our space complexity here at O(n) where n is the number of nodes in the queue at any given time. For the final implementation:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">p</span> <span class="p">=</span> <span class="n">p</span>
<span class="kd">var</span> <span class="nv">q</span> <span class="p">=</span> <span class="n">q</span>
<span class="kd">var</span> <span class="nv">queue</span> <span class="p">=</span> <span class="p">[</span><span class="n">p</span> <span class="p">,</span><span class="n">q</span><span class="p">]</span>

<span class="k">while</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span>
    <span class="n">p</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span>
    <span class="n">q</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">p</span> <span class="p">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="n">q</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span><span class="k">continue</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">p</span> <span class="p">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="n">q</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span><span class="k">return</span> <span class="kc">false</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">p</span><span class="p">!.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">q</span><span class="p">!.</span><span class="n">val</span> <span class="p">{</span><span class="k">return</span> <span class="kc">false</span><span class="p">}</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">!.</span><span class="kr">left</span><span class="p">)</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">q</span><span class="p">!.</span><span class="kr">left</span><span class="p">)</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">!.</span><span class="kr">right</span><span class="p">)</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">q</span><span class="p">!.</span><span class="kr">right</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">return</span> <span class="kc">true</span>
</div></code></pre><hr><h1>Subtree of Another Tree</h1><p>Time to continue our tree journey with another example!</p><img src="/subtreeofanothertree.png"/><p>Just like every other problem we have encountered, we can solve this recursively or iteratively using BFS/DFS!</p><h3>[ Recursive ]</h3><h3>[ O(n ¬∑ m) time + O(n + m) space ]</h3><p>To make this problem a little easier, we can break out the "is same tree" functionality into its own function. This makes it unit testable, as well as easier to read from a code perspective. Once we break out this out into another function, it makes our problem much easier. We can traverse our root tree using DFS &amp; if our current root at a given time is equal to the subroot, we can return true. Since this is a recursive function, if somewhere on the left or right of our tree, we have a subtree, we can return true.</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">root</span> <span class="k">is</span> <span class="kc">nil</span> <span class="k">return</span> <span class="kc">false</span>
<span class="k">is</span> <span class="n">current</span> <span class="n">root</span> <span class="o">&amp;</span> <span class="n">subroot</span> <span class="n">are</span> <span class="n">the</span> <span class="n">same</span> <span class="k">return</span> <span class="kc">true</span>
<span class="n">recurse</span> <span class="kr">left</span>
<span class="n">recurse</span> <span class="kr">right</span>
<span class="k">return</span> <span class="kr">left</span> <span class="n">OR</span> <span class="kr">right</span> <span class="kc">true</span>
</div></code></pre><p>The time complexity for our solution here is a little complex. Checking if a root &amp; subroot are the same tree, requires us to traverse every node of our subtree &amp; root tree. This is M ¬∑ N where M is the number of nodes in the root tree, and N is the number of nodes in the subtree. We need to traverse our entire tree M, and at every step we traverse our N subtree looking for a similarity. This comes out to O(M¬∑N) time complexity. The space complexity here is O(n + m) where N is the number of calls in the stack for traversing our root node in a dfs fashion. At every recursive call, we call our "is same tree" function, so M is representative of the number of "is same tree" function calls in the stack. This evens out to O(n + m) space.</p><p>The final implementation comes out to the following:</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">isSubtree</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?,</span> <span class="kc">_</span> <span class="n">subRoot</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">dfs</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?,</span> <span class="kc">_</span> <span class="n">subRoot</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">root</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span>
    <span class="kd">let</span> <span class="nv">left</span> <span class="p">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">?.</span><span class="kr">left</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">right</span> <span class="p">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">?.</span><span class="kr">right</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span>
    <span class="k">return</span> <span class="kr">left</span> <span class="o">||</span> <span class="kr">right</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="kc">_</span> <span class="n">one</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?,</span> <span class="kc">_</span> <span class="n">two</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">one</span> <span class="p">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="n">two</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">one</span> <span class="p">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="n">two</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">one</span><span class="p">?.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">two</span><span class="p">?.</span><span class="n">val</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="kd">let</span> <span class="nv">isLeftValid</span> <span class="p">=</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">one</span><span class="p">?.</span><span class="kr">left</span><span class="p">,</span> <span class="n">two</span><span class="p">?.</span><span class="kr">left</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">isRightValid</span> <span class="p">=</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">one</span><span class="p">?.</span><span class="kr">right</span><span class="p">,</span> <span class="n">two</span><span class="p">?.</span><span class="kr">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">isLeftValid</span> <span class="o">&amp;&amp;</span> <span class="n">isRightValid</span>
<span class="p">}</span>
</div></code></pre><h3>[ Iterative with a Queue (BFS) ]</h3><h3>[ O(n + m) time + O(n + m) space ]</h3><p>The idea here is the exact same as other iterative BFS problems. We need to use a queue and pop nodes off of the queue to perform our checking logic.</p><pre><code><div class="highlight"><span></span><span class="n">add</span> <span class="n">root</span> <span class="n">and</span> <span class="n">subroot</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span>
<span class="k">while</span> <span class="n">the</span> <span class="n">queue</span> <span class="k">is</span> <span class="n">not</span> <span class="n">empty</span> 
    <span class="n">remove</span> <span class="bp">first</span> <span class="n">from</span> <span class="n">queue</span> <span class="n">representing</span> <span class="n">root</span>
    <span class="n">remove</span> <span class="bp">first</span> <span class="n">from</span> <span class="n">queue</span> <span class="n">representing</span> <span class="n">subroot</span>
    <span class="k">if</span> <span class="n">root</span> <span class="n">and</span> <span class="n">subroot</span> <span class="n">are</span> <span class="n">same</span> <span class="n">tree</span> <span class="k">return</span> <span class="kc">true</span>
    <span class="n">add</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">of</span> <span class="n">each</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span>
<span class="k">return</span> <span class="kc">false</span>
</div></code></pre><p>Space complexity as we know is O(n + m). N is representative of the space of our queue at any given moment, where m is the number of "is same tree" function calls. Time complexity is once again, O(n + m) for the reasons stated above.</p><p>Here is the final implementation:</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">isSubtree</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?,</span> <span class="kc">_</span> <span class="n">subRoot</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">bfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">bfs</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?,</span> <span class="kc">_</span> <span class="n">subRoot</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="kd">var</span> <span class="nv">queue</span> <span class="p">=</span> <span class="p">[</span><span class="n">TreeNode</span><span class="p">?]()</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

    <span class="k">while</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">node</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">node</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">continue</span> <span class="p">}</span>
        <span class="k">if</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">?.</span><span class="kr">left</span><span class="p">)</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">?.</span><span class="kr">right</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="kc">_</span> <span class="n">one</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?,</span> <span class="kc">_</span> <span class="n">two</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">one</span> <span class="p">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="n">two</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">one</span> <span class="p">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="n">two</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">one</span><span class="p">?.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">two</span><span class="p">?.</span><span class="n">val</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="kd">let</span> <span class="nv">isLeftValid</span> <span class="p">=</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">one</span><span class="p">?.</span><span class="kr">left</span><span class="p">,</span> <span class="n">two</span><span class="p">?.</span><span class="kr">left</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">isRightValid</span> <span class="p">=</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">one</span><span class="p">?.</span><span class="kr">right</span><span class="p">,</span> <span class="n">two</span><span class="p">?.</span><span class="kr">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">isLeftValid</span> <span class="o">&amp;&amp;</span> <span class="n">isRightValid</span>
<span class="p">}</span>
</div></code></pre><hr><h1>Lowest Common Ancestor of a Binary Search Tree</h1><p>Turn up the heat a little!</p><img src="/lcaofbinarysearchtree.png"/><p>To start here we should revisit the definition of a Binary Search Tree..."A binary search tree is when every node fits into an ordering system. When all left descendants ‚â§ the current node value ‚â§ all right descendants". When you see a BST being stated in the problem statement, we should know to use the BST characteristics to our advantage. We should immediately think to compare the children node values to the root value, and vice versa.</p><h3>[ Recursive ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>For our problem at hand we should check P and Qs value relative to the root. If both P and Q are greater than the root, we should repeat our search in the right half of the tree. If both P and Q are less than the root, we should repeat our search in the left half of the tree. And if neither of those cases are true, we should return our root node, because we cannot go any deeper in the tree.</p><p>This is fairly straight forward, but what about the edge cases where either P or Q is equal to the root node? Well this should not change much in our case. This is because since either P or Q is equal to the root, we know neither the left or right subtrees would contain the value we are searching for.</p><p>Here is a high level implementation:</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">P</span> <span class="n">and</span> <span class="n">Q</span> <span class="n">are</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">root</span>
    <span class="n">search</span> <span class="kr">right</span> <span class="n">subtree</span>
<span class="k">if</span> <span class="n">P</span> <span class="n">and</span> <span class="n">Q</span> <span class="n">are</span> <span class="n">less</span> <span class="n">than</span> <span class="n">root</span>
    <span class="n">search</span> <span class="kr">left</span> <span class="n">subtree</span>
<span class="k">else</span>
    <span class="k">return</span> <span class="n">root</span>
</div></code></pre><p>The space complexity here is O(n) where N is the number of recursive calls on the call stack at any given time, this should be roughly equal to the height of the Tree. The time complexity is roughly equal to the number of nodes in the tree, and this is because at the worst case, we need to traverse down to the bottom of the entire tree through every node...O(n). This time complexity assumes the tree is not balanced.<br><br>The final implementation is as follows:</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">p</span> <span class="p">=</span> <span class="n">p</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">q</span> <span class="p">=</span> <span class="n">q</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
<span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">.</span><span class="n">val</span> <span class="p">{</span> <span class="c1">// search right</span>
    <span class="k">return</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">right</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">.</span><span class="n">val</span> <span class="p">{</span> <span class="c1">// search left</span>
    <span class="k">return</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">left</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">root</span>
<span class="p">}</span>
</div></code></pre><h3>[ Iterative ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>The iterative solution follows the same pattern as the recursive, without the recursion.</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">a</span> <span class="n">current</span> <span class="n">node</span> <span class="n">to</span> <span class="n">traverse</span> <span class="n">the</span> <span class="n">tree</span>
<span class="k">while</span> <span class="n">the</span> <span class="n">current</span> <span class="k">is</span> <span class="n">not</span> <span class="kc">nil</span>
    <span class="k">if</span> <span class="n">P</span> <span class="n">and</span> <span class="n">Q</span> <span class="n">are</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">root</span>
        <span class="n">assign</span> <span class="n">current</span> <span class="n">to</span> <span class="kr">right</span> <span class="n">node</span>
    <span class="k">if</span> <span class="n">P</span> <span class="n">and</span> <span class="n">Q</span> <span class="n">are</span> <span class="n">less</span> <span class="n">than</span> <span class="n">root</span>
        <span class="n">assign</span> <span class="n">current</span> <span class="n">to</span> <span class="kr">left</span> <span class="n">node</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">root</span>
<span class="k">return</span> <span class="n">current</span>
</div></code></pre><p>The space complexity here is obviously improved without the recursion. This equates out to O(1) space. The time complexity is O(n) because we need to possibly traverse every node in the entire tree. If the tree is balanced though this would be an O(logN) time complexity.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">first</span> <span class="p">=</span> <span class="n">p</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">second</span> <span class="p">=</span> <span class="n">q</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nv">current</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?</span> <span class="p">=</span> <span class="n">root</span>
<span class="k">while</span> <span class="kd">let</span> <span class="nv">node</span> <span class="p">=</span> <span class="n">current</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="bp">first</span><span class="p">.</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">second</span><span class="p">.</span><span class="n">val</span> <span class="p">{</span>
        <span class="n">current</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="kr">right</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="bp">first</span><span class="p">.</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">second</span><span class="p">.</span><span class="n">val</span> <span class="p">{</span>
        <span class="n">current</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="kr">left</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">current</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">current</span>
</div></code></pre><p>Keep it rolling!</p><hr><h1>Binary Tree Level Order Traversal</h1><p>Lets take a peek at the next tree challenge</p><img src="/binarytreelevelordertraversal.png"/><p>If this problem looks familiar...its because it is! We have had some tree problems in the past where we traverse the tree with BFS (Breadth First Search). And this problem is eerily similar! We just have a slight wrinkle on what we should be doing at any given tree level.</p><h3>[ BFS with Extra Loop ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>The idea here is, we use a queue like we would any other BFS tree traversal. But the difference is, while our queue is not empty, we want to keep a count of how big our queue is. While the queue has a count greater than or equal to zero, we want to pop values, and add child values to the queue. After we have popped values from the queue all the way until the queue is empty, we know we have traversed a level, and we can add the traversed values to our return array.</p><p>It is important to emphasize, the trick here is keep tracking of how big the queue is at every level, with its own variable.</p><p>We should note that the problem is asking for a LEVEL order traversal, aka root, left, and then right.</p><pre><code><div class="highlight"><span></span><span class="n">create</span> <span class="n">queue</span>
<span class="n">add</span> <span class="n">root</span> <span class="n">to</span> <span class="n">queue</span>

<span class="k">while</span> <span class="n">queue</span> <span class="k">is</span> <span class="n">not</span> <span class="n">empty</span>
    <span class="kr">get</span> <span class="n">length</span> <span class="n">of</span> <span class="n">current</span> <span class="n">queue</span>
    <span class="n">create</span> <span class="n">an</span> <span class="n">array</span> <span class="n">to</span> <span class="n">track</span> <span class="n">this</span> <span class="n">level</span>
    <span class="k">for</span> <span class="n">element</span> <span class="k">in</span> <span class="n">length</span> <span class="n">of</span> <span class="n">queue</span>
        <span class="n">remove</span> <span class="bp">first</span> <span class="n">value</span> <span class="n">from</span> <span class="n">queue</span>
        <span class="n">add</span> <span class="n">value</span> <span class="n">to</span> <span class="n">this</span> <span class="n">level</span> <span class="n">array</span>
        <span class="n">add</span> <span class="kr">left</span> <span class="n">child</span> <span class="n">to</span> <span class="n">queue</span>
        <span class="n">add</span> <span class="kr">right</span> <span class="n">child</span> <span class="n">to</span> <span class="n">queue</span>
    <span class="n">add</span> <span class="n">this</span> <span class="n">level</span> <span class="n">array</span> <span class="n">to</span> <span class="k">return</span> <span class="n">value</span>
    
<span class="k">return</span> <span class="n">nested</span> <span class="n">array</span> <span class="n">we</span> <span class="n">created</span>
</div></code></pre><p>The space complexity here is O(n) because of the queue data structure we are using. In a Binary tree we can have at most O(‚ÇÅ/‚ÇÇn) values on it at any given time. The time complexity here is O(n) because we will only ever visit each node one time.</p><p>Here is the final implementation!</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[]</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nv">result</span> <span class="p">=</span> <span class="p">[[</span><span class="nb">Int</span><span class="p">]]()</span>
<span class="kd">var</span> <span class="nv">queue</span><span class="p">:</span> <span class="p">[</span><span class="n">TreeNode</span><span class="p">?]</span> <span class="p">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>

<span class="k">while</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">count</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="kd">var</span> <span class="nv">currentIterativeArray</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]()</span>
     <span class="k">while</span> <span class="bp">count</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
       <span class="k">if</span> <span class="kd">let</span> <span class="nv">node</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span> <span class="p">{</span>
           <span class="n">currentIterativeArray</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
           <span class="bp">count</span> <span class="o">-=</span> <span class="mi">1</span>
           <span class="k">if</span> <span class="kd">let</span> <span class="nv">left</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="kr">left</span> <span class="p">{</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="kr">left</span><span class="p">)</span> <span class="p">}</span>
           <span class="k">if</span> <span class="kd">let</span> <span class="nv">right</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="kr">right</span> <span class="p">{</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="kr">right</span><span class="p">)</span> <span class="p">}</span>
       <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentIterativeArray</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">result</span>
</div></code></pre><p>Like I said in the beginning, it is a pretty straight forward BFS with a little wrinkle!</p><hr><h1>Validate Binary Search Tree</h1><p>Now this one is a little tricky...</p><img src="/validatebinarysearchtree.png"/><p>Lets make sure we are reading the problem correctly! The first thing to call out is the definition of a BST. The left subtree of a node must be less than the root node. NOT less than or equal to, only less than. Same thing with the right side, the right subtree must be greater than the node. Also, pay attention to the wording, if a node is on the left side of the top most root, it must be less than the value of the root. It does not matter if the node is 4 levels down from the top. If it is on the left side of the tree, then we should ensure its value is less than the root node value.</p><h3>[ DFS with Comparison ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>So typically when validating a binary tree we would use DFS. But this time its a little different, and that is because of the BST definition, we can compare a roots value to its left and right value, but that does not help us as we get further and further down the tree. We lose track of the root node value.</p><p>So the trick here is to recognize what we are doing at each node and each level. Say we have a tree with a topmost root node value of 5. We know for this to be valid, 5 must be less than -‚àû and greater than ‚àû. Next lets say the topmost node value of 5, has a left side child of 3. For this 3 to be a valid node, we know 3 must be less than -‚àû BUT greater than 5. Consider 5 has a right child node of 7. 7 must be greater than 5, but less than ‚àû.</p><p>The point here being, we need to make a comparison at each node. When we recursively travel through our tree, we need to just send the comparison values down the call stack. When recursing left, we know the minimum should be the current minimum, but the maximum should be the root node value (parent). Vice versa with the right side. Something like this:</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">node</span> <span class="k">is</span> <span class="kc">nil</span> <span class="k">return</span> <span class="kc">true</span>
<span class="k">if</span> <span class="n">our</span> <span class="n">node</span> <span class="k">is</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">the</span> <span class="n">minimum</span> <span class="n">value</span><span class="p">,</span> <span class="n">or</span><span class="p">,</span> <span class="n">the</span> <span class="n">node</span> <span class="k">is</span> <span class="n">less</span> <span class="n">than</span> <span class="n">the</span> <span class="n">maximum</span> <span class="n">value</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="k">return</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">subtrees</span> <span class="n">are</span> <span class="n">valid</span><span class="p">,</span> <span class="k">while</span> <span class="n">passing</span> <span class="n">the</span> <span class="n">new</span> <span class="bp">min</span> <span class="o">&amp;</span> <span class="bp">max</span> <span class="n">values</span>
</div></code></pre><p>The time complexity here is pretty straightforward as we need to visit every node here once. The comparison itself is constant time, but the time comes out to O(n) where n is the number of nodes in the tree. The space complexity here as we have seen is O(n), due to the recursive nature of the solution. We need to host at most n number of recursive calls when we traverse the tree. N in this case stands for the height of the tree, which evens out to O(n) time.</p><p>The final implementation is as follows:</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">isBst</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="bp">min</span><span class="p">:</span> <span class="nb">Int</span><span class="p">.</span><span class="bp">min</span><span class="p">,</span> <span class="bp">max</span><span class="p">:</span> <span class="nb">Int</span><span class="p">.</span><span class="bp">max</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kd">func</span> <span class="nf">isBst</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?,</span> <span class="bp">min</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="bp">max</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="bp">min</span> <span class="o">||</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="bp">max</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">isBst</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">left</span><span class="p">,</span> <span class="bp">min</span><span class="p">:</span> <span class="bp">min</span><span class="p">,</span> <span class="bp">max</span><span class="p">:</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isBst</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">right</span><span class="p">,</span> <span class="bp">min</span><span class="p">:</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="bp">max</span><span class="p">:</span> <span class="bp">max</span><span class="p">)</span>
<span class="p">}</span>
</div></code></pre><p>We just need to be careful on this one! Do not blindly implement DFS, make sure we are understanding the problem.</p><hr><h1>Kth Smallest Element in a BST</h1><p>Keep chugging along!</p><img src="/kthsmallestinbst.png"/><p>So here we have another BST problem. We should make sure we remember that a BST is a tree where all elements on the left side of the tree are less than the root, and all elements in the right subtree are greater than the root. Also we should remember how we normally traverse trees in general, here we will be using DFS.</p><h3>[ DFS inorder traversal ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>So we should consider the smart way to go about this. If we remember, Inorder traversal is when we visit the entire left side, then the root, then the right subtree. If we do an Inorder traversal on a BST, and we store the elements in an array as we visit them, we will end up with an array of all the nodes in order from smallest to largest!</p><p>This will make our lives a lot easier, if we want to find the kth-smallest element (1 indexed) we can then just return the kth - 1 element in our array we have created.</p><pre><code><div class="highlight"><span></span><span class="n">build</span> <span class="n">our</span> <span class="n">list</span>
<span class="k">return</span> <span class="n">the</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span> <span class="n">element</span> <span class="n">of</span> <span class="n">the</span> <span class="n">list</span>


<span class="n">build</span> <span class="n">list</span> <span class="n">function</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">root</span> <span class="k">is</span> <span class="kc">nil</span><span class="p">,</span> <span class="k">return</span> <span class="n">empty</span> <span class="n">array</span>
    <span class="n">add</span> <span class="n">root</span> <span class="n">value</span> <span class="n">to</span> <span class="n">new</span> <span class="n">list</span>
    <span class="n">recurse</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">get</span> <span class="kr">left</span> <span class="n">array</span>
    <span class="n">recurse</span> <span class="kr">right</span> <span class="n">and</span> <span class="kr">get</span> <span class="kr">right</span> <span class="n">array</span>
    <span class="k">return</span> <span class="kr">left</span> <span class="n">array</span> <span class="o">+</span> <span class="n">root</span> <span class="n">array</span> <span class="o">+</span> <span class="kr">right</span> <span class="n">array</span>
</div></code></pre><p>The time complexity here is O(n) where n is the number of nodes in the tree, we need to visit every node once to build the array. Arrays offer constant time lookup when accessing a value, so we can ignore the time complexity there. The space complexity is O(n) because we are building an array where the size of the array is how many nodes are in the tree. We are also recursively traversing the tree, so we need O(n) at most calls in the recursive call stack. This will even out to O(n) on average.</p><p>Here is the final implementation!</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">kthSmallest</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?,</span> <span class="kc">_</span> <span class="n">k</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="kd">var</span> <span class="nv">list</span> <span class="p">=</span> <span class="n">buildList</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">list</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> 
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">buildList</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[]</span> <span class="p">}</span>
    <span class="kd">var</span> <span class="nv">list</span> <span class="p">=</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span>
    <span class="kd">let</span> <span class="nv">left</span> <span class="p">=</span> <span class="n">buildList</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">left</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">right</span> <span class="p">=</span> <span class="n">buildList</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="kr">left</span> <span class="o">+</span> <span class="n">list</span> <span class="o">+</span> <span class="kr">right</span>
<span class="p">}</span>
</div></code></pre><p>Easy!</p><h3>[ BFS with a Stack ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>I think it would also be intelligent here to mention, we do not always have to traverse the tree using DFS, we can of course use BFS with a Stack like structure. It carries very similar logic to our DFS logic, but we save ourselves from the recursion. We will go as far left in our tree as possible and find the smallest value. After that, we will pop the parent and traverse right. All the while we need to keep a count of the values rankings. Every time we pop a value from the stack, we can decrement our K value count.</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">iterativeStack</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?,</span> <span class="kc">_</span> <span class="n">k</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">stack</span> <span class="p">=</span> <span class="p">[</span><span class="n">TreeNode</span><span class="p">]()</span>
    <span class="kd">var</span> <span class="nv">count</span> <span class="p">=</span> <span class="n">k</span>
    <span class="kd">var</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span>
    
    <span class="c1">// Go as far left as we can</span>
    <span class="k">while</span> <span class="n">root</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">!)</span>
        <span class="n">root</span> <span class="p">=</span> <span class="n">root</span><span class="p">?.</span><span class="kr">left</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="bp">count</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">node</span> <span class="p">=</span> <span class="n">stack</span><span class="p">.</span><span class="bp">removeLast</span><span class="p">()</span>
        <span class="bp">count</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">count</span> <span class="p">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// When our K value count is now at 0, we know we have found the right value. </span>
            <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
        <span class="p">}</span>
        <span class="kd">var</span> <span class="nv">rightNode</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="kr">right</span>
        <span class="k">while</span> <span class="n">rightNode</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">rightNode</span><span class="p">!)</span>
            <span class="n">rightNode</span> <span class="p">=</span> <span class="n">rightNode</span><span class="p">?.</span><span class="kr">left</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</div></code></pre><p>Nice!</p><hr><h1>Construct Binary Tree from Preorder and Inorder Traversal</h1><p>Hope you remembered how to traverse a tree! This one is all about testing your inner tree knowledge.</p><img src="/constructbinarytreefrompreorderinorder.png"/><p>In concept this is a straight forward problem, it just takes a little creativity arriving at the solution. We will be using DFS for this problem, which means recursion.</p><h3>[ DFS recursive build ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>Lets think about what preorder traversal means. Preorder traversal is arriving at the root first, then left subtree, then right subtree. This means in our example problem, our preorder array is [3,9,20,15,7], and the first element of this array is 3. Thus we know our root of our entire tree is 3. Cool. Now what?</p><p>Now lets think about inorder traversal. Inorder traversal is arriving at the left node first, then the root node, then the right now. So taking what we know from preorder traversal, we know our root is 3. If we find the value of 3 in our inorder traversal array, we can partition the array to know which values are in the left and right subtrees. For example, our inorder array is [9,3,15,20,7]. By finding the root value of 3, we can split our array up into 2 parts. We now know that the left subtree consists of [9]. While the right subtree consists of [15, 20, 7]. What next?</p><p>This pivot point I will refer to as "Mid". In our above example, our midpoint is 3. There is a "gotcha" to this problem as well. We should be careful when there is no left subtree to populate, that is when we should move on to the right subtree. If this midpoint has an index of 0, its time to move on to the right side. Lets see an example. If our preorder array is [7, 10]. And our inorder array is [7, 10]. Our midpoint here would be 7. We can see our midpoint in our inorder array has a midpoint of 0. This is because there is nothing to add to the left subtree and we should move on!</p><p>We can recursively repeat this process for our left and right subtrees, excluding values we do not need. So to find the right subtree for 3 for example, our preorder array would be [20, 15, 7]. Our inorder array will be [15, 20, 7]. Rinse and repeat!</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">either</span> <span class="n">inorder</span> <span class="n">or</span> <span class="n">preorder</span> <span class="k">is</span> <span class="n">empty</span><span class="p">,</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">(</span><span class="n">base</span> <span class="k">case</span><span class="p">)</span>

<span class="n">create</span> <span class="n">root</span> <span class="n">node</span> <span class="n">from</span> <span class="n">preorder</span> <span class="n">arrays</span> <span class="bp">first</span> <span class="n">value</span>
<span class="bp">find</span> <span class="n">midpoint</span> <span class="k">in</span> <span class="n">inorder</span> <span class="n">array</span>

<span class="bp">find</span> <span class="kr">left</span> <span class="n">of</span> <span class="n">root</span> <span class="n">by</span> <span class="n">recursing</span> <span class="kr">left</span> <span class="n">subtree</span>
<span class="bp">find</span> <span class="kr">right</span> <span class="n">of</span> <span class="n">root</span> <span class="n">by</span> <span class="n">recursing</span> <span class="kr">right</span> <span class="n">subtree</span>

<span class="k">return</span> <span class="n">root</span>
</div></code></pre><p>Given this is a recursive solution, the space complexity here is O(n) where n is the height of the call stack at any given time. The time complexity here is O(n) worst case, where the biggest time constraint is finding the midpoint in the inorder array. We may have to search the entire array to find it. Time to implement!</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">preorder</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="o">||</span> <span class="n">inorder</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nv">rootNode</span> <span class="p">=</span>  <span class="n">TreeNode</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">mid</span> <span class="p">=</span> <span class="n">inorder</span><span class="p">.</span><span class="n">firstIndex</span><span class="p">(</span><span class="n">of</span><span class="p">:</span> <span class="n">rootNode</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">mid</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// if we have a left side to populate</span>
        <span class="kd">let</span> <span class="nv">leftPreorder</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mf">1.</span><span class="p">..</span><span class="n">mid</span><span class="p">])</span>
        <span class="kd">let</span> <span class="nv">leftInorder</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">inorder</span><span class="p">[</span><span class="mf">0.</span><span class="p">.&lt;</span><span class="n">mid</span><span class="p">])</span>
        <span class="n">rootNode</span><span class="p">.</span><span class="kr">left</span> <span class="p">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">leftPreorder</span><span class="p">,</span> <span class="n">leftInorder</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nv">rightPreorder</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="n">mid</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">.&lt;</span><span class="n">preorder</span><span class="p">.</span><span class="bp">count</span><span class="p">])</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">rightPreorder</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">rightInorder</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">inorder</span><span class="p">[</span><span class="n">mid</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">.&lt;</span><span class="n">inorder</span><span class="p">.</span><span class="bp">count</span><span class="p">])</span>
                <span class="bp">print</span><span class="p">(</span><span class="n">rightInorder</span><span class="p">)</span>

    <span class="n">rootNode</span><span class="p">.</span><span class="kr">right</span> <span class="p">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">rightPreorder</span><span class="p">,</span> <span class="n">rightInorder</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">rootNode</span>
</div></code></pre><p>Almost done!</p><hr><h1>Binary Tree Maximum Path Sum</h1><p>And now we enter the hard realm üëÄ</p><img src="/binarytreemaxpathsum.png"/><p>This is an decently solvable hard leetcode problem, we just need to remember our tree fundamentals when it comes to DFS.</p><h3>[ DFS recursion w/ optimization ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>I think for this problem, understanding what the problem is asking is of the most importance. A path, in this case, is the ability to split the path of a node only once. And by this I mean, say we have a tree with a root of 1, and children of 2 and 3. We can only split our path once at the topmost root node of 1. We cannot say, go from 1 to 2, then back to 1, then to 3. We only split once. In the case where we are in a subtree and we have already split, we should be choosing the left or right path that is greater.</p><p>Also, some of the nodes may be negative. So this should affect the decision we are making when its time to choose a path. If we have to split between left and right, and one direction gives us a negative value, we should avoid it. It is possible negative values are a part of our path, we should just be methodical about when to use them.</p><p>So lets think about how we would go about solving this. I think at first it should be pretty clear that we will be recursively using DFS to eliminate repeated work. We want to, at each node in our tree, figure out if splitting at the current node and combining the left and right subtrees is greater, or if we have already split what is the maximum path using either the left OR right subtree.</p><p>Thinking recursively lets start with a base case. If the root of our tree is nil, we should return a max path of zero. Easy. We will then recurse left and right. We need to determine if the left max path is less than 0. If it is, we should not use this value as it will not optimize our path. Nice.</p><p>For this problem, we should be keeping a global max path variable, this keeps our code clean when determining the max path of the entire structure. At every iteration we should determine which is bigger: the current global max path sum, or splitting at the current node. Splitting at the current node can be represented as root + left max + right max.</p><p>Now lets assume we have already split earlier in our traversal, and we are deep into our tree structure. In this case, for our subtree we should just be returning what the maximum unidirectional path is to our parent. In this case we will just add the root to the maximum of the left vs right subtrees. Slightly different. Recapping all of that, some pseudocode looks like this:</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">root</span> <span class="k">is</span> <span class="kc">nil</span> <span class="k">return</span> <span class="mi">0</span>

<span class="n">keep</span> <span class="n">global</span> <span class="bp">max</span> <span class="n">path</span> <span class="n">sum</span><span class="p">,</span> <span class="n">starting</span> <span class="n">value</span> <span class="k">is</span> <span class="n">our</span> <span class="n">root</span> <span class="n">value</span>


<span class="kr">get</span> <span class="kr">left</span> <span class="n">value</span> <span class="n">by</span> <span class="n">recursing</span>
<span class="kr">get</span> <span class="kr">right</span> <span class="n">value</span> <span class="n">by</span> <span class="n">recursing</span>
<span class="k">if</span> <span class="kr">left</span> <span class="n">value</span> <span class="k">is</span> <span class="n">less</span> <span class="n">than</span> <span class="n">zero</span><span class="p">,</span> <span class="n">use</span> <span class="mi">0</span> <span class="n">instead</span>
<span class="k">if</span> <span class="kr">right</span> <span class="n">value</span> <span class="k">is</span> <span class="n">less</span> <span class="n">than</span> <span class="n">zero</span><span class="p">,</span> <span class="n">use</span> <span class="mi">0</span> <span class="n">instead</span>

<span class="n">update</span> <span class="n">global</span> <span class="bp">max</span> <span class="n">with</span> <span class="n">whichever</span> <span class="k">is</span> <span class="n">greater</span><span class="p">:</span> <span class="n">the</span> <span class="n">global</span> <span class="bp">max</span><span class="p">,</span> <span class="n">or</span> <span class="k">if</span> <span class="n">we</span> <span class="bp">split</span> <span class="n">at</span> <span class="n">this</span> <span class="n">present</span> <span class="n">node</span><span class="p">.</span> <span class="n">root</span> <span class="o">+</span> <span class="kr">left</span> <span class="o">+</span> <span class="kr">right</span>

<span class="k">return</span> <span class="n">to</span> <span class="n">our</span> <span class="n">parent</span><span class="p">,</span> <span class="n">assuming</span> <span class="n">we</span> <span class="n">already</span> <span class="bp">split</span><span class="p">.</span> <span class="n">root</span> <span class="o">+</span> <span class="bp">max</span> <span class="n">of</span> <span class="kr">left</span> <span class="n">vs</span> <span class="kr">right</span>
</div></code></pre><p>Due to the recursion, the space complexity here is O(n) where n represents the maximum size of the call stack at any given time. This is also equal to the height of the tree. If it is a balanced tree then the space complexity is O(logn). The time complexity here is O(n) because we need to visit every node in the tree only once.</p><p>And finally here is the implementation:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">result</span> <span class="p">=</span> <span class="n">root</span><span class="p">!.</span><span class="n">val</span>

<span class="kd">func</span> <span class="nf">recurse</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="kd">let</span> <span class="nv">left</span> <span class="p">=</span> <span class="n">recurse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">left</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">right</span> <span class="p">=</span> <span class="n">recurse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">right</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">leftMax</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="kr">left</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">rightMax</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="kr">right</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">result</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">leftMax</span> <span class="o">+</span> <span class="n">rightMax</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="bp">max</span><span class="p">(</span><span class="n">leftMax</span><span class="p">,</span> <span class="n">rightMax</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">recurse</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
</div></code></pre><p>Only one more to go!</p><hr><h1>Serialize and Deserialize Binary Tree</h1><p>and here we are, the final problem in our tree journey. Lets dive in!</p><img src="/serializedeserializetree.png"/><p>I think to start, we need to break this problem down into 2 parts, the serialization and the deserialization. And, as with most tree problems, we can use either BFS or DFS to solve this. I will be going over both for posterity üòé</p><p>No matter if you use BFS or DFS, the idea behind a solution is the same. We know to serialize we want to make the tree into a string. Lets say we have a tree where the root is 1, and it has children of 2 &amp; 3. If we use DFS, the string will be "1, 2, nil, nil, 3, nil, nil". We will want to add all children of nodes, even if they are nil. We want to also add the differentiator between nil and non nil nodes. This is because we need to know in DFS when to move on from the left subtree and go to the right subtree. In this case we used "nil" but you can use anything you want like "null", "next" or even "üî•". We also want to comma separate our values so we know if a value in the string is "12" meaning 1 node of value 12, or 2 values with the values of "1" &amp; "2".</p><p>Using this same logic our string for a BFS solution would be "1, 2, 3, nil, nil, nil, nil", due to the nature of BFS we are looking at the tree on a level by level basis.</p><h2>Serialization</h2><h3>[ DFS recursive string creation ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>For DFS, we know we will be recursively traveling down the tree until we reach our base case to end our recursion. We will also be traveling the left and right subtrees from our root. This solution is pretty straight forward. If we find a nil root, we will be adding "nil" to our string. Else we need to add subtree strings to our root.</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">a</span> <span class="n">global</span> <span class="k">return</span> <span class="n">string</span>

<span class="k">if</span> <span class="n">root</span> <span class="k">is</span> <span class="kc">nil</span> 
    <span class="k">return</span> <span class="n">string</span> <span class="o">+=</span> <span class="s">&quot;nil,&quot;</span>
    <span class="k">break</span> <span class="n">from</span> <span class="n">recursion</span>
<span class="k">return</span> <span class="n">string</span> <span class="o">+=</span> <span class="n">root</span> <span class="n">value</span> <span class="o">+</span> <span class="s">&quot;,&quot;</span>
<span class="k">return</span> <span class="n">string</span> <span class="o">+=</span> <span class="kr">left</span> <span class="n">subtree</span> <span class="n">recursed</span>
<span class="k">return</span> <span class="n">string</span> <span class="o">+=</span> <span class="kr">right</span> <span class="n">subtree</span> <span class="n">recursed</span>
</div></code></pre><p>Space complexity here is O(n) where n is the height of the tree, and the max size of the call stack at any given time. We have to visit every node and at each iteration we are doing constant addition, so the time complexity is O(n) where n is the# of nodes in a tree.</p><p>Something like this:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">result</span> <span class="p">=</span> <span class="s">&quot;&quot;</span>

<span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;null,&quot;</span>
    <span class="k">return</span> 
<span class="p">}</span>
<span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="si">\(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="si">)</span><span class="s">,&quot;</span>
<span class="n">result</span> <span class="o">+=</span> <span class="n">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">left</span><span class="p">)</span>
<span class="n">result</span> <span class="o">+=</span> <span class="n">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">right</span><span class="p">)</span>

<span class="k">return</span> <span class="n">result</span>
</div></code></pre><h3>[ BFS Queue string creation ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>As is usually the case with BFS, its a little more complicated due to the use of a Queue, but still not too bad. Here we will be keeping an array of values, and at the end, manually do the comma separation. This is just to give a different look at the problem.</p><p>First we will add the root of our tree to the queue. Then while the queue is not empty, we will add non nil values to our values array. If we find a nil value, we will add "nil" to our values array. For every node we pop we will add its children to the queue regardless of optionality. Like this:</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">a</span> <span class="n">queue</span>
<span class="n">keep</span> <span class="n">a</span> <span class="n">list</span> <span class="n">of</span> <span class="n">values</span>

<span class="k">while</span> <span class="n">queue</span> <span class="k">is</span> <span class="n">not</span> <span class="n">empty</span>
    <span class="n">pop</span> <span class="bp">first</span> <span class="n">from</span> <span class="n">queue</span>
    <span class="n">add</span> <span class="n">node</span> <span class="n">to</span> <span class="n">values</span> <span class="n">array</span>
    <span class="n">add</span> <span class="kr">left</span> <span class="n">child</span> <span class="n">to</span> <span class="n">queue</span>
    <span class="n">add</span> <span class="kr">right</span> <span class="n">child</span> <span class="n">to</span> <span class="n">queue</span>
    <span class="k">if</span> <span class="n">node</span> <span class="k">is</span> <span class="kc">nil</span> <span class="n">add</span> <span class="s">&quot;nil&quot;</span> <span class="n">to</span> <span class="n">values</span> <span class="n">array</span>
    
<span class="k">return</span> <span class="n">values</span> <span class="n">array</span><span class="p">,</span> <span class="n">but</span> <span class="n">comma</span> <span class="n">separated</span>
</div></code></pre><p>Space complexity here is O(2n) which evens out to O(n) due to the queue we need to keep track of our nodes. We will always add nodes to our queue for every node (and child node) we have. This evens out to O(n) time complexity.</p><p>Here is the final implementation:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">vals</span> <span class="p">=</span> <span class="p">[</span><span class="nb">String</span><span class="p">]()</span>
<span class="kd">var</span> <span class="nv">queue</span><span class="p">:</span> <span class="p">[</span><span class="n">TreeNode</span><span class="p">?]</span> <span class="p">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>

<span class="k">while</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">node</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">vals</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;</span><span class="si">\(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="kr">left</span><span class="p">)</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="kr">right</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">vals</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;nil&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">vals</span><span class="p">.</span><span class="n">joined</span><span class="p">(</span><span class="n">separator</span><span class="p">:</span> <span class="s">&quot;,&quot;</span><span class="p">)</span>
</div></code></pre><p>Ok we are serialized and good to go!</p><h2>Deserialization</h2><h3>[ DFS recursive ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>The idea here is the same with serializing DFS. But we just want to be careful when we approach a nil value. A simple way to get around this is using Swifts Int initializer. If we pass "2" into the initializer, Swift will give us 2. If we try to pass "nil", the initializer will conveniently fail.</p><pre><code><div class="highlight"><span></span><span class="n">separate</span> <span class="n">our</span> <span class="n">string</span> <span class="n">into</span> <span class="n">a</span> <span class="n">comma</span> <span class="n">separated</span> <span class="n">array</span>

<span class="n">pop</span> <span class="n">the</span> <span class="bp">first</span> <span class="n">from</span> <span class="n">the</span> <span class="n">array</span>
<span class="k">try</span> <span class="n">to</span> <span class="n">convert</span> <span class="n">the</span> <span class="n">value</span> <span class="n">into</span> <span class="n">an</span> <span class="nb">Int</span>
    <span class="k">if</span> <span class="n">it</span> <span class="n">fails</span><span class="p">,</span> <span class="k">return</span> <span class="kc">nil</span>

<span class="n">create</span> <span class="n">a</span> <span class="n">new</span> <span class="n">root</span> <span class="n">node</span>
<span class="n">node</span><span class="p">.</span><span class="kr">left</span> <span class="k">is</span> <span class="bp">equal</span> <span class="n">to</span> <span class="n">the</span> <span class="n">recursive</span> <span class="kr">left</span> <span class="n">subtree</span>
<span class="n">node</span><span class="p">.</span><span class="kr">right</span> <span class="k">is</span> <span class="bp">equal</span> <span class="n">to</span> <span class="n">the</span> <span class="n">recursive</span> <span class="kr">right</span> <span class="n">subtree</span>
<span class="k">return</span> <span class="n">new</span> <span class="n">root</span> <span class="n">node</span>
</div></code></pre><p>Same as always, space is the call stack size O(n). Time complexity is O(n) which is roughly the number of nodes in the tree. This is how we would go about DFS deserialization:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">val</span> <span class="p">=</span> <span class="n">nodes</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span>
<span class="k">guard</span> <span class="kd">let</span> <span class="nv">valInt</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>

<span class="kd">let</span> <span class="nv">node</span> <span class="p">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">valInt</span><span class="p">)</span>
<span class="n">node</span><span class="p">.</span><span class="kr">left</span> <span class="p">=</span> <span class="n">deseralize_DFS</span><span class="p">(&amp;</span><span class="n">nodes</span><span class="p">)</span>
<span class="n">node</span><span class="p">.</span><span class="kr">right</span> <span class="p">=</span> <span class="n">deseralize_DFS</span><span class="p">(&amp;</span><span class="n">nodes</span><span class="p">)</span>
<span class="k">return</span> <span class="n">node</span>
</div></code></pre><h3>[ BFS queue ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>This one is a bit more complicated, by using BFS deserialization. Like DFS, we will want to convert our string into a comma separated array. We should attempt to keep a pointer in our array, so we know where in our values we are iteration on. Per usual we will create a queue and add our root to it. While the queue is not empty, we will pop nodes from the queue. BUT after we pop, we need to look at our values array. If the value is not nil only then will we add the left child node to our queue. Same with the right side. Every time we check the values array we want to move our pointer by 1 spot.</p><pre><code><div class="highlight"><span></span><span class="n">separate</span> <span class="n">string</span> <span class="n">into</span> <span class="n">comma</span> <span class="n">separated</span> <span class="n">array</span>
<span class="n">create</span> <span class="n">queue</span> <span class="n">with</span> <span class="n">a</span> <span class="n">new</span> <span class="n">root</span> <span class="n">node</span> <span class="n">we</span> <span class="n">create</span>

<span class="k">while</span> <span class="n">the</span> <span class="n">queue</span> <span class="k">is</span> <span class="n">not</span> <span class="n">empty</span>
    <span class="n">remove</span> <span class="n">queue</span> <span class="n">from</span> <span class="n">node</span>
    <span class="k">if</span> <span class="n">values</span> <span class="n">pointer</span> <span class="k">is</span> <span class="n">not</span> <span class="n">a</span> <span class="kc">nil</span> <span class="n">value</span>
        <span class="n">node</span><span class="p">.</span><span class="kr">left</span> <span class="k">is</span> <span class="n">a</span> <span class="n">newly</span> <span class="n">created</span> <span class="n">node</span> <span class="n">from</span> <span class="n">values</span> <span class="n">array</span>
        <span class="n">add</span> <span class="n">this</span> <span class="n">new</span> <span class="n">node</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span>
    <span class="n">move</span> <span class="n">values</span> <span class="n">pointer</span> <span class="n">by</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">values</span> <span class="n">pointer</span> <span class="k">is</span> <span class="n">not</span> <span class="n">a</span> <span class="kc">nil</span> <span class="n">value</span>
        <span class="n">node</span><span class="p">.</span><span class="kr">right</span> <span class="k">is</span> <span class="n">a</span> <span class="n">newly</span> <span class="n">created</span> <span class="n">node</span> <span class="n">from</span> <span class="n">values</span> <span class="n">array</span>
        <span class="n">add</span> <span class="n">this</span> <span class="n">new</span> <span class="n">node</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span>
    <span class="n">move</span> <span class="n">values</span> <span class="n">pointer</span> <span class="n">by</span> <span class="mi">1</span>

<span class="k">return</span> <span class="n">new</span> <span class="n">root</span>
</div></code></pre><p>Space complexity here is O(n) due to the queue we need to keep track of our nodes. We will always add nodes to our queue for every node (and child node) we have. This evens out to O(n) time complexity. Value comparison and assignment is always constant time.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">data</span> <span class="o">!=</span> <span class="s">&quot;nil&quot;</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
<span class="kd">let</span> <span class="nv">vals</span> <span class="p">=</span> <span class="n">data</span>
    <span class="p">.</span><span class="bp">split</span><span class="p">(</span><span class="n">separator</span><span class="p">:</span> <span class="s">&quot;,&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nb">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">Int</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">!</span><span class="p">)</span>
<span class="kd">var</span> <span class="nv">queue</span> <span class="p">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>

<span class="kd">var</span> <span class="nv">idx</span> <span class="p">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">node</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">vals</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;nil&quot;</span> <span class="p">{</span>
        <span class="n">node</span><span class="p">.</span><span class="kr">left</span> <span class="p">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">Int</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">!</span><span class="p">)</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="kr">left</span><span class="p">!)</span>
    <span class="p">}</span>
    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">vals</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;nil&quot;</span> <span class="p">{</span>
        <span class="n">node</span><span class="p">.</span><span class="kr">right</span> <span class="p">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">Int</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">!</span><span class="p">)</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="kr">right</span><span class="p">!)</span>
    <span class="p">}</span>
    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">root</span>
</div></code></pre><p>Well done!!!! Trees problems should be a breeze now!!</p></article></main><div class="flex flex-wrap w-full items-center font-sans p-8 md:p-24"><div class="md:flex-1 flex"><img class="w-10 h-10 rounded-full mr-4" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><div class="flex-1"><p class="text-base font-bold text-base md:text-xl leading-none">Alex Stevens</p><p class="text-gray-600 text-xs md:text-base">iOS Software Engineer</p></div></div><div class="mt-8 md:mt-0 mx-auto md:mx-0 md:justify-end"><a class="bg-transparent border border-gray-500 hover:border-casper-blue text-xs text-gray-500 hover:text-casper-blue font-bold py-2 px-4 rounded-full" href="/tags">All tags</a></div></div></div></div><div class="bg-gray-200"><div class="container w-full max-w-6xl mx-auto px-2 py-8"><div class="grid grid-cols-1 sm:grid-cols-3 gap-12"><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/leetcode/blind-75-stack" class="flex flex-wrap no-underline hover:no-underline"><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">LEETCODE</p><div class="w-full font-bold text-2xl text-gray-900 px-6">Blind 75: Stacks</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">A short introduction into Stacks</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><p class="text-gray-600 text-xs md:text-sm">4 MIN READ</p></div></div></div><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/leetcode/how-to-solve-a-leetcode-problem" class="flex flex-wrap no-underline hover:no-underline"><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">LEETCODE</p><div class="w-full font-bold text-2xl text-gray-900 px-6">How to solve a Leetcode problem</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">Leetcode. The bane of many a programmer</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><p class="text-gray-600 text-xs md:text-sm">1 MIN READ</p></div></div></div><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/leetcode/blind-75-arrays" class="flex flex-wrap no-underline hover:no-underline"><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">LEETCODE</p><div class="w-full font-bold text-2xl text-gray-900 px-6">Blind 75: Arrays + Hashing + 2 pointers</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">Arrays + Leetcode = Match made in heaven</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><p class="text-gray-600 text-xs md:text-sm">37 MIN READ</p></div></div></div></div></div></div><footer class="bg-gray-900"><div class="container max-w-6xl mx-auto flex items-center px-2 pt-2 pb-8"><div class="w-full mx-auto flex flex-wrap items-center"><div class="flex w-full md:w-1/2 justify-center md:justify-start text-white font-extrabold"><p><a class="text-gray-900 no-underline hover:text-gray-900 hover:no-underline" href="#"><span class="text-base text-gray-200">Swift Refresher</span></a></p></div><div class="flex w-full pt-2 content-center justify-between md:w-1/2 md:justify-end"><ul class="list-reset flex justify-center flex-1 md:flex-none items-center"><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="/">Latest Posts</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="https://github.com/JohnSundell/Publish">Publish</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="https://ghost.org">Ghost</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline px-3 text-sm" href="/feed.rss"><svg class="fill-current h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"></circle><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"></path></svg></a></li></ul></div></div></div></footer></body></html>