<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Swift Refresher"/><link rel="canonical" href="https://swiftrefresher.com/leetcode/blind-75-binary-search"/><meta name="twitter:url" content="https://swiftrefresher.com/leetcode/blind-75-binary-search"/><meta name="og:url" content="https://swiftrefresher.com/leetcode/blind-75-binary-search"/><title>Blind 75: Binary Search | Swift Refresher</title><meta name="twitter:title" content="Blind 75: Binary Search | Swift Refresher"/><meta name="og:title" content="Blind 75: Binary Search | Swift Refresher"/><meta name="description" content="The programmers favorite searching mechanism!"/><meta name="twitter:description" content="The programmers favorite searching mechanism!"/><meta name="og:description" content="The programmers favorite searching mechanism!"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Swift Refresher"/></head><body class="bg-white font-sans leading-normal tracking-normal"><div class="pb-16"><nav class="fixed z-10 bg-gray-900 p-4 mt-0 w-full overflow-auto scrolling-touch"><div class="container mx-auto flex items-center"><div class="flex-shrink-0 text-white font-extrabold"><a class="flex text-white text-base no-underline hover:text-white hover:no-underline" href="/"><span class="block md:hidden md:w-auto pl-1">üèù</span><span class="hidden md:block w-0 md:w-auto pl-1">Swift Refresher</span></a></div><div class=" flex flex-no-wrap pl-4 text-sm"><ul class="list-reset flex justify-between items-center"><li class="mr-2"><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2" href="/">HOME</a></li><li><a class="inline-block py-2 px-2 text-white no-underline hover:underline whitespace-no-wrap" href="/leetcode">LEETCODE</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/SwiftUI">SWIFTUI</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/combine">COMBINE</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/swift">SWIFT</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/about">ABOUT</a></li></ul></div></div></nav></div><div class="text-center pt-16 md:pt-32"><p class="text-xs md:text-sm text-casper-blue font-bold">29 AUGUST 2022<span class="text-gray-900 px-1">/</span><a href="/tags/leetcode">LEETCODE</a></p><h1 class="font-bold break-normal text-3xl md:text-5xl max-w-6xl mx-auto">Blind 75: Binary Search</h1></div><div class="container max-w-5xl mx-auto "><div class="mx-0 sm:mx-6"><main class="bg-white w-full p-8 md:p-24 text-gray-800 leading-normal"><article class="prose prose-sm sm:prose-xl break-words"><h1>Binary Search</h1><p>So you have mastered the basic string and array problems. Awesome. Now we will be moving on to Binary Search. Binary Search is the most common searching mechanism, and really the only one seen in Leetcode problems. Let's give an overview of how Binary Search works, and why it is better than a common linear search.</p><p>So Swift has a built in method of searching for an element in an array, we could simply do:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">array</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">indexOfElement</span> <span class="p">=</span> <span class="n">array</span><span class="p">.</span><span class="n">firstIndex</span><span class="p">(</span><span class="n">of</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">indexOfElement</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 2</span>
</div></code></pre><p>Using the built-in Swift search, we can search our entire array to find the index of the element we are searching for. This is great if our element is in the beginning of the array, but if our element is at the very end of the array it becomes very time consuming. The built in Swift search, is a linear search, which gives us on average O(n) time. If our array has 1 million elements, it will on average take us 1 million steps to find the element. Ouch.</p><p>This is where Binary Search comes in. Binary Search takes O(Log(n)) time on average. So our 1 million element array, will only take us about 20 steps on average to find the element. Awesome. BUT, there is a downside to the Binary Search, and that is the array must be sorted in order. We will see why that is the case.</p><p>The way Binary Search works is:</p><ol><li>Find which half of the array our element is in (Left half vs Right half)</li><li>If the element is in the right half, we repeat this process with the right half of the array (and vice-versa for left half)</li><li>Repeat until the element is found</li><li>If we cannot split the array anymore, our element doesn't exist in our array</li></ol><p>As you can now see, we must have a sorted array when doing Binary Search. We can easily find which half of the array our element resides in, with a simple comparison operator like <code>&lt;</code> or <code>&gt;</code>. You will often hear Binary Search referred to as "Divide and Conquer" for this reason.</p><h3>Implementation</h3><p>Binary Search can be implemented both recursively and iteratively.</p><h4>Recursive</h4><p>The recursive implementation is very straight forward.</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="kc">_</span> <span class="n">array</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">range</span><span class="p">:</span> <span class="nb">Range</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">&gt;)</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">range</span><span class="p">.</span><span class="n">lowerBound</span> <span class="o">&gt;=</span> <span class="n">range</span><span class="p">.</span><span class="n">upperBound</span> <span class="p">{</span>
        <span class="c1">// If we get here, then the search key is not present in the array.</span>
        <span class="k">return</span> <span class="kc">nil</span>

    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Calculate where to split the array.</span>
        <span class="kd">let</span> <span class="nv">midIndex</span> <span class="p">=</span> <span class="n">range</span><span class="p">.</span><span class="n">lowerBound</span> <span class="o">+</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">upperBound</span> <span class="o">-</span> <span class="n">range</span><span class="p">.</span><span class="n">lowerBound</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        
        <span class="c1">// Is the search key in the left half?</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">midIndex</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">key</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span> <span class="n">range</span><span class="p">:</span> <span class="n">range</span><span class="p">.</span><span class="n">lowerBound</span> <span class="p">..</span><span class="o">&lt;</span> <span class="n">midIndex</span><span class="p">)</span>

        <span class="c1">// Is the search key in the right half?</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">midIndex</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">key</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span> <span class="n">range</span><span class="p">:</span> <span class="n">midIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">..</span><span class="o">&lt;</span> <span class="n">range</span><span class="p">.</span><span class="n">upperBound</span><span class="p">)</span>

        <span class="c1">// If we get here, then we&#39;ve found the search key!</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">midIndex</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">numbers</span> <span class="p">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">67</span><span class="p">]</span>

<span class="k">if</span> <span class="kd">let</span> <span class="nv">result</span> <span class="p">=</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="mi">43</span><span class="p">,</span> <span class="n">range</span><span class="p">:</span> <span class="mi">0</span> <span class="p">..</span><span class="o">&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="bp">count</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1">// gives 13</span>
<span class="p">}</span>
</div></code></pre><p>Pay a close bit of attention on how we anchor our left vs right halves of our array. The equation <strong>range.lowerBound + (range.upperBound - range.lowerBound) / 2</strong> is something you should remember as we can split both even and odd numbered arrays with this equation. Every time we find our element is in the left or right half of the array, we recursively pass the range of the new array back into our function. This saves us space by not having to keep variables for the left and right halves of the array.</p><p>It is also worth noting, that recursive implementations inherently come with O(n) space, due to our machine holding the function call stack in memory. Because of this, the iterative approach is favored here, for efficiency sake.</p><h4>Iterative</h4><p>The following is the iterative approach to the Binary Search:</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="kc">_</span> <span class="n">array</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">lowerBound</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">var</span> <span class="nv">upperBound</span> <span class="p">=</span> <span class="n">array</span><span class="p">.</span><span class="bp">count</span>
    <span class="k">while</span> <span class="n">lowerBound</span> <span class="o">&lt;</span> <span class="n">upperBound</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">midIndex</span> <span class="p">=</span> <span class="n">lowerBound</span> <span class="o">+</span> <span class="p">(</span><span class="n">upperBound</span> <span class="o">-</span> <span class="n">lowerBound</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">midIndex</span><span class="p">]</span> <span class="p">==</span> <span class="n">key</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">midIndex</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">midIndex</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">key</span> <span class="p">{</span>
            <span class="n">lowerBound</span> <span class="p">=</span> <span class="n">midIndex</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">upperBound</span> <span class="p">=</span> <span class="n">midIndex</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">numbers</span> <span class="p">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">67</span><span class="p">]</span>

<span class="k">if</span> <span class="kd">let</span> <span class="nv">result</span> <span class="p">=</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="mi">43</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1">// gives 13</span>
<span class="p">}</span>
</div></code></pre><p>Many recursive functions can be converted to iterative functions by using loops. Note the <strong>while</strong> loop here.</p><p>So that is Binary Search and how it works under the hood. Let's apply this to some Leetcode problems!</p><hr><h1>Search in Rotated Sorted Array</h1><p>Time to apply that Binary Search knowledge!</p><img src="/searchrotatedsortedarray.png"/><p>This one can be a little tricky. We know from the intro in this article, that Binary Search takes a sorted array. But the input array in this problem is sorted around a pivot. So we cannot use Binary Search out of the box, we need to alter it a little. Considering the problem statement says our solution must be in O(logN) time, there really is no point figuring out a brute force, O(n) solution. Let's get into the Binary Search solution.</p><h3>[ Altered Binary Search ]</h3><h3>[ O(logN) time + O(1) space ]</h3><p>We need to think about how our input array is structured. We can still use Binary search in a way but we must be methodical. We know we will have a left pointer, right pointer &amp; middle pointer of our array. The question is though, is our middle element, in the left sorted half, or right sorted half? If our input array is [4, 5, 6, 7, 0, 1, 2] our midpoint will be 7. We know that 7 (our midpoint) is in the left sorted half of the array. How do we know this?</p><p>Well we can compare our midpoint to our leftPointer. If our midpoint is greater than or equal to our left pointer, our midpoint belongs in the left half of the array. Let's see another example. Say our input array is [7, 0, 1, 2, 3]. In this case our midpoint is not greater than or equal to our left pointer, thus our midpoint belongs to the right half of our array. Ok cool. Now what do we do when we figure out what side our midpoint belongs to?</p><p>Once we figure out which side of the array our midpoint belongs to, we can see if our target falls within the range of that side of the array. For example, say our input array is [4, 5, 6, 7, 0, 1, 2], we know the midpoint belongs to the left side of the array. So within the left side of the array, we need to check if our target falls in that range. If it does we need to search that half, if it doesn't we need to search the other side of the array. Our target in the example problem is 0. Considering we know the midpoint belongs to the left side of the array, we should compare our target to the array [4, 5, 6, 7]. Does our target fall within that range? No it doesn't, so we should check the other half of the array [0, 1, 2]. Then we repeat this process continuously until we find our element.</p><p>In pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">while</span> <span class="n">leftPointer</span> <span class="n">less</span> <span class="n">than</span> <span class="n">or</span> <span class="bp">equal</span> <span class="n">to</span> <span class="n">rightPointer</span> 
    <span class="k">if</span> <span class="n">our</span> <span class="n">midpoint</span> <span class="k">is</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">or</span> <span class="bp">equal</span> <span class="n">to</span> <span class="n">our</span> <span class="kr">left</span> <span class="n">pointer</span><span class="p">,</span> <span class="n">midpoint</span> <span class="k">is</span> <span class="k">in</span> <span class="n">the</span> <span class="kr">left</span> <span class="n">half</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">our</span> <span class="n">target</span> <span class="k">is</span> <span class="k">in</span> <span class="n">range</span> <span class="n">of</span> <span class="n">the</span> <span class="kr">left</span> <span class="n">side</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
            <span class="k">repeat</span> <span class="n">search</span> <span class="n">on</span> <span class="n">the</span> <span class="kr">left</span> <span class="n">side</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
        <span class="k">else</span> <span class="n">our</span> <span class="n">target</span> <span class="k">is</span> <span class="n">out</span> <span class="n">of</span> <span class="n">range</span> <span class="n">of</span> <span class="n">the</span> <span class="kr">left</span> <span class="n">side</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
            <span class="k">repeat</span> <span class="n">search</span> <span class="n">on</span> <span class="n">the</span> <span class="kr">right</span> <span class="n">side</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
    <span class="k">else</span> <span class="n">our</span> <span class="n">midpoint</span> <span class="k">is</span> <span class="k">in</span> <span class="n">the</span> <span class="kr">right</span> <span class="n">side</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">our</span> <span class="n">target</span> <span class="k">is</span> <span class="k">in</span> <span class="n">range</span> <span class="n">of</span> <span class="n">the</span> <span class="kr">right</span> <span class="n">side</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
            <span class="k">repeat</span> <span class="n">search</span> <span class="n">on</span> <span class="n">the</span> <span class="kr">right</span> <span class="n">half</span> <span class="n">of</span> <span class="n">array</span>
        <span class="k">else</span> <span class="n">our</span> <span class="n">target</span> <span class="k">is</span> <span class="n">out</span> <span class="n">of</span> <span class="n">range</span> <span class="n">of</span> <span class="n">the</span> <span class="kr">right</span> <span class="n">side</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
            <span class="k">repeat</span> <span class="n">search</span> <span class="n">on</span> <span class="n">the</span> <span class="kr">left</span> <span class="n">half</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
            
</div></code></pre><p>That gets a little wordy! But it outlines our intent very well. As discussed here earlier, the time complexity is O(logN) due to Binary Search, and O(1) space because we are not storing anything here. The real implementation is as follows:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">var</span> <span class="nv">rightPointer</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span>
        
<span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;=</span> <span class="n">rightPointer</span> <span class="p">{</span> <span class="c1">// While our pointers are still valid</span>
    <span class="kd">let</span> <span class="nv">mid</span> <span class="p">=</span> <span class="n">leftPointer</span> <span class="o">+</span> <span class="p">(</span><span class="n">rightPointer</span> <span class="o">-</span> <span class="n">leftPointer</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="c1">// Find the midpoint of our array</span>
    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="p">==</span> <span class="n">target</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mid</span> <span class="p">}</span> <span class="c1">// We have found our element!</span>
    
    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// Our midpoint is in the left half of the array</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">||</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// Target is not in range of the left half</span>
            <span class="n">leftPointer</span> <span class="p">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// Move left pointer</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// Target is in range of the left half</span>
            <span class="n">rightPointer</span> <span class="p">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// Move right pointer   </span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// Our midpoint is in the right half of the array</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">||</span> <span class="n">target</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// Target is not in range of the right half</span>
            <span class="n">rightPointer</span> <span class="p">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// Move right pointer</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">leftPointer</span> <span class="p">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// Move left pointer</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</div></code></pre><p>Well Done!</p><p>---</p><h1>Find Minimum in Rotated Sorted Array</h1><p>This problem is actually more straight forward than our last one.</p><img src="/minimuminsortedarray.png"/><p>There should be a couple flags here that let us know this is a Binary Search array type problem. First, the problem states the input array is in sorted (but rotated) order, and second, we need an O(LogN) time solution. When we see a combination of these two things, we know it is most likely a Binary Search problem.</p><h3>[ Altered Binary Search ]</h3><h3>[ O(logN) time + O(1) space ]</h3><p>This approach is like a slightly altered version of Binary Search. Since our input array is sorted but rotated an unknown amount of times, we don't exactly know where our pivot point is. If we take a look at the previous problem, we can check the midpoint and compare it to the rightmost array element to see if our midpoint belongs to the left or right side of the array. Using that information we can search the right and left arrays continuously until we run out of elements to search.</p><p>We will also want to keep a variable for the minimum element in the array. We can use our midpoint anchor to track which element is our smallest.</p><p>BUT, there is one situation we should also be aware of. If our array is sorted, based on our left and right pointers, we can break out of our loop, because we know the smallest element will be the leftmost element. Here is the pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">while</span> <span class="n">leftPointer</span> <span class="n">less</span> <span class="n">than</span> <span class="n">or</span> <span class="bp">equal</span> <span class="n">to</span> <span class="n">rightPointer</span> 
    <span class="k">if</span> <span class="n">our</span> <span class="n">array</span> <span class="k">is</span> <span class="bp">sorted</span>
        <span class="bp">min</span> <span class="k">is</span> <span class="n">leftmost</span> <span class="n">element</span>
        <span class="k">break</span> <span class="n">from</span> <span class="n">loop</span>
    <span class="n">update</span> <span class="n">minimum</span> <span class="n">element</span> <span class="n">with</span> <span class="n">midPointer</span> <span class="k">as</span> <span class="n">needed</span>
    <span class="k">if</span> <span class="n">midPointer</span> <span class="o">&gt;</span> <span class="n">rightPointer</span>
        <span class="n">search</span> <span class="kr">right</span> <span class="n">half</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
    <span class="k">else</span> <span class="n">search</span> <span class="kr">left</span> <span class="n">half</span> <span class="n">of</span> <span class="n">array</span>
        
</div></code></pre><p>As discussed here earlier, the time complexity is O(logN) due to Binary Search, and O(1) space because we are not storing anything here, aside from a minimum element variable. The real implementation is below:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">mini</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">.</span><span class="bp">max</span> <span class="c1">// Some default value</span>
<span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">var</span> <span class="nv">rightPointer</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span>

<span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;=</span> <span class="n">rightPointer</span> <span class="p">{</span> <span class="c1">// While our pointers are still valid</span>
    <span class="k">guard</span> <span class="n">nums</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// If our array is sorted </span>
        <span class="n">mini</span> <span class="p">=</span> <span class="bp">min</span><span class="p">(</span><span class="n">mini</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">])</span> <span class="c1">// Update global minimum</span>
        <span class="k">break</span> <span class="c1">// Break from loop</span>
    <span class="p">}</span>
    
    <span class="kd">let</span> <span class="nv">mid</span> <span class="p">=</span> <span class="n">leftPointer</span> <span class="o">+</span> <span class="p">(</span><span class="n">rightPointer</span> <span class="o">-</span> <span class="n">leftPointer</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">mini</span> <span class="p">=</span> <span class="bp">min</span><span class="p">(</span><span class="n">mini</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span> <span class="c1">// Update global minimum</span>
    
    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// Midpoint belongs to the right half of the array</span>
        <span class="n">leftPointer</span> <span class="p">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// Midpoint belongs to the left half of the array</span>
        <span class="n">rightPointer</span> <span class="p">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">mini</span>
</div></code></pre><hr><h1>Conclusion</h1><p>Keep an eye out when you see sorted input arrays, and problems that require O(logN) time complexity, this usually points to a classic Binary Search problem!</p><hr></article></main><div class="flex flex-wrap w-full items-center font-sans p-8 md:p-24"><div class="md:flex-1 flex"><img class="w-10 h-10 rounded-full mr-4" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><div class="flex-1"><p class="text-base font-bold text-base md:text-xl leading-none">Alex Stevens</p><p class="text-gray-600 text-xs md:text-base">iOS Software Engineer</p></div></div><div class="mt-8 md:mt-0 mx-auto md:mx-0 md:justify-end"><a class="bg-transparent border border-gray-500 hover:border-casper-blue text-xs text-gray-500 hover:text-casper-blue font-bold py-2 px-4 rounded-full" href="/tags">All tags</a></div></div></div></div><div class="bg-gray-200"><div class="container w-full max-w-6xl mx-auto px-2 py-8"><div class="grid grid-cols-1 sm:grid-cols-3 gap-12"><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/leetcode/blind-75-linked-lists" class="flex flex-wrap no-underline hover:no-underline"><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">LEETCODE</p><div class="w-full font-bold text-2xl text-gray-900 px-6">Blind 75: Linked Lists</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">Like an array...but not really</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><p class="text-gray-600 text-xs md:text-sm">25 MIN READ</p></div></div></div><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/leetcode/blind-75-arrays" class="flex flex-wrap no-underline hover:no-underline"><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">LEETCODE</p><div class="w-full font-bold text-2xl text-gray-900 px-6">Blind 75: Arrays + Hashing + 2 pointers</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">Arrays + Leetcode = Match made in heaven</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><p class="text-gray-600 text-xs md:text-sm">37 MIN READ</p></div></div></div><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/leetcode/how-to-solve-a-leetcode-problem" class="flex flex-wrap no-underline hover:no-underline"><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">LEETCODE</p><div class="w-full font-bold text-2xl text-gray-900 px-6">How to solve a Leetcode problem</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">Leetcode. The bane of many a programmer</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><p class="text-gray-600 text-xs md:text-sm">1 MIN READ</p></div></div></div></div></div></div><footer class="bg-gray-900"><div class="container max-w-6xl mx-auto flex items-center px-2 pt-2 pb-8"><div class="w-full mx-auto flex flex-wrap items-center"><div class="flex w-full md:w-1/2 justify-center md:justify-start text-white font-extrabold"><p><a class="text-gray-900 no-underline hover:text-gray-900 hover:no-underline" href="#"><span class="text-base text-gray-200">Swift Refresher</span></a></p></div><div class="flex w-full pt-2 content-center justify-between md:w-1/2 md:justify-end"><ul class="list-reset flex justify-center flex-1 md:flex-none items-center"><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="/">Latest Posts</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="https://github.com/JohnSundell/Publish">Publish</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="https://ghost.org">Ghost</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline px-3 text-sm" href="/feed.rss"><svg class="fill-current h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"></circle><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"></path></svg></a></li></ul></div></div></div></footer></body></html>