<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Swift Refresher"/><link rel="canonical" href="https://swiftrefresher.com/leetcode/blind-75-arrays"/><meta name="twitter:url" content="https://swiftrefresher.com/leetcode/blind-75-arrays"/><meta name="og:url" content="https://swiftrefresher.com/leetcode/blind-75-arrays"/><title>Blind 75: Arrays + Hashing + 2 pointers | Swift Refresher</title><meta name="twitter:title" content="Blind 75: Arrays + Hashing + 2 pointers | Swift Refresher"/><meta name="og:title" content="Blind 75: Arrays + Hashing + 2 pointers | Swift Refresher"/><meta name="description" content="Arrays + Leetcode = Match made in heaven"/><meta name="twitter:description" content="Arrays + Leetcode = Match made in heaven"/><meta name="og:description" content="Arrays + Leetcode = Match made in heaven"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Swift Refresher"/></head><body class="bg-white font-sans leading-normal tracking-normal"><div class="pb-16"><nav class="fixed z-10 bg-gray-900 p-4 mt-0 w-full overflow-auto scrolling-touch"><div class="container mx-auto flex items-center"><div class="flex-shrink-0 text-white font-extrabold"><a class="flex text-white text-base no-underline hover:text-white hover:no-underline" href="/"><span class="block md:hidden md:w-auto pl-1">üèù</span><span class="hidden md:block w-0 md:w-auto pl-1">Swift Refresher</span></a></div><div class=" flex flex-no-wrap pl-4 text-sm"><ul class="list-reset flex justify-between items-center"><li class="mr-2"><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2" href="/">HOME</a></li><li><a class="inline-block py-2 px-2 text-white no-underline hover:underline whitespace-no-wrap" href="/leetcode">LEETCODE</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/SwiftUI">SWIFTUI</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/combine">COMBINE</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/swift">SWIFT</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/about">ABOUT</a></li></ul></div></div></nav></div><div class="text-center pt-16 md:pt-32"><p class="text-xs md:text-sm text-casper-blue font-bold">16 MARCH 2022<span class="text-gray-900 px-1">/</span><a href="/tags/leetcode">LEETCODE</a></p><h1 class="font-bold break-normal text-3xl md:text-5xl max-w-6xl mx-auto">Blind 75: Arrays + Hashing + 2 pointers</h1></div><div class="container max-w-5xl mx-auto "><div class="mx-0 sm:mx-6"><main class="bg-white w-full p-8 md:p-24 text-gray-800 leading-normal"><article class="prose prose-sm sm:prose-xl break-words"><h1>TwoSum</h1><p>This is a classic introductory problem &amp; it is a good place for us to start our leetcode journey. Read over the problem statement below.</p><img src="/twosum.png"/><p>Pretty straightforward right? Let's take this step by step and make sure we understand the solution. We need the indices of 2 numbers that add up to a target. We can assume there is one answer, and we may not use the same element twice. Easy enough.</p><h3>Brute Force</h3><p>A brute force solution here is pretty obvious, let's go through each element in the array, and iterate over every other element, to see if we add up to a target. This is a common brute force method for most array problems. This will give us a O(n¬≤) time &amp; O(1) spacial solution. Let's write some pseudocode for this solution and test it. While testing, make sure to capture edge cases!</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">+</span> <span class="n">other</span> <span class="n">number</span> <span class="p">=</span> <span class="n">target</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">number</span> <span class="n">index</span><span class="p">,</span> <span class="n">other</span> <span class="n">number</span> <span class="n">index</span><span class="p">]</span>
</div></code></pre><p>It is time to consider some bottlenecks, and think how we can optimize our solution. Firstly, if you notice some nested for loops in your code, that is a code smell. Think how those can be optimized. In our case if we try to pass thru the array only once, while also sequentially finding the solution, we heavily optimize our solution.</p><h3>Approach 1</h3><h3>[ Sort + 2 pointer ]</h3><h3>[ O(nLog(n)) time + O(n) space ]</h3><p>For this specific problem we know we want 2 numbers that add up to a target. That is, X + Y = Z. If we have X, we know that we are searching for Z - Y. If we sort our array, we can make this search much faster.</p><p>Back to our above example, we have an array of [4, 2, 1, 3] and we need a target of 3. If we first sort the array, we can use 2 pointers to incrementally get closer to our target number. By sorting our array is [1, 2, 3, 4]. We have a left pointer at the beginning of the array and a right pointer at the end of the array. Let's add these numbers up. 1 + 4 = 5, which is greater than our target of 3. The sum is greater than our target, so let's move the right pointer inward. Now our pointers are targeted at 1, and 3. 1 + 3 = 4, a summation that is still greater than our target. So we move the right pointer inward once more. This makes our pointers at 1 and 2, and if we add those up we find our target.</p><p>Pseudocode:</p><pre><code><div class="highlight"><span></span><span class="bp">sort</span> <span class="n">array</span>
<span class="k">while</span> <span class="kr">left</span> <span class="n">pointer</span> <span class="o">&lt;</span> <span class="kr">right</span> <span class="n">pointer</span>
    <span class="n">add</span> <span class="n">up</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">pointers</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="p">=</span> <span class="n">target</span>
        <span class="k">return</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">pointer</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span>
        <span class="n">move</span> <span class="kr">right</span> <span class="n">pointer</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span>
        <span class="n">move</span> <span class="kr">left</span> <span class="n">pointer</span>
</div></code></pre><p>There are some considerations here. By sorting we can get, on average, O(nLog(n)) time performance. So by sorting and then searching our array we are looking at O(nLog(n)) + O(n) time complexity. Which comes out to be O(nLog(n)). This is a pretty significant time vs space tradeoff and this should be discussed with your interviewer.<br><br>Let's go into implementation now.</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for empty array + single element in array.</span>
<span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]()</span> <span class="p">}</span>

<span class="kd">let</span> <span class="nv">sorted</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">sorted</span><span class="p">()</span>
<span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">var</span> <span class="nv">rightPointer</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span>

<span class="c1">// Search our array</span>
<span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;</span> <span class="n">rightPointer</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">sum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="o">+</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="p">{</span>
        <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="p">{</span>
        <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">break</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Because the swift index(of:) function returns us an &#39;Array&lt;Int&gt;.Index?&#39; </span>
<span class="c1">// we need to manually get the integer Index value by doing one more loop.</span>
<span class="kd">let</span> <span class="nv">leftNum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">rightNum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span>

<span class="kd">var</span> <span class="nv">returnValue</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]()</span>

<span class="c1">// Beautiful swift! Reads just like english :) </span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="k">where</span> <span class="p">(</span><span class="n">num</span> <span class="p">==</span> <span class="n">leftNum</span> <span class="o">||</span> <span class="n">num</span> <span class="p">==</span> <span class="n">rightNum</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">returnValue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">returnValue</span>
</div></code></pre><p>Ta-Da! This is one passing solution to solve the 2 sum problem. This methodology will be the preferred method of solving in 3sum, 4sum and etc problems.</p><h3>Approach 2</h3><h3>[ Hash Table ]</h3><h3>[ O(n) time + space ]</h3><p>By using some auxiliary data structure for storage you can easily look up past calculations for your use case. In our case, we should try to optimize our O(n¬≤) time solution into a O(n) time solution. For array problems this is the mecca. This brings us to our introduction of hash tables/dictionary's. We can have constant lookup in swift dictionaries.</p><p>In our case let's consider we loop through the array 1 time, and in a hash table, we store the key as the element of our array and the value as the index of each value. So our original array of [4, 2, 1, 3] turns into a dictionary of [4: 0, 2: 1, 1: 2, 3: 3]. Now in our problem, we can go through our array 1 time, and at each element we can see if the inverse of the target exists. Namely it comes down to this pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">add</span> <span class="n">to</span> <span class="n">dictionary</span><span class="p">.</span> <span class="p">[</span><span class="n">number</span><span class="p">:</span> <span class="n">index</span> <span class="n">of</span> <span class="n">number</span><span class="p">]</span>
    
<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">inverse</span> <span class="p">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">number</span>
    <span class="k">if</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">inverse</span><span class="p">]</span> <span class="n">exists</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">number</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">inverse</span><span class="p">]]</span>
</div></code></pre><p>After testing, we see this is a lot more efficient, and it works! We gave up some constant space in order for time efficiency, but these tradeoffs are things you can discuss with your interviewer. Now let's code our final solution. Don't forget to cover those edge cases, and to practice safe optional unwrapping!</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for empty array + single element in array.</span>
<span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[]</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span>
<span class="c1">// Create our hashtable mapping</span>
<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">hashTable</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="n">index</span>
<span class="p">}</span>
<span class="c1">// Now search our array for the inverse!</span>
<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">inverse</span> <span class="p">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">element</span>
    <span class="c1">// we should not be using the same element within itself. Make sure to read the problem carefully!</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">existingInverse</span> <span class="p">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">inverse</span><span class="p">],</span> <span class="n">unwrappedInverse</span> <span class="o">!=</span> <span class="n">index</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">existingInverse</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="p">[]</span> <span class="c1">// we have no solution. </span>
</div></code></pre><p>Nice work!</p><hr><h1>ThreeSum</h1><p>This problem builds off of our previous problem, with a little more complexity. Check out the problem statement below.</p><img src="/threesum.png"/><p>If we remember one of the solutions for the TwoSum problem, when we sort the array then use 2 pointers to find our target it leads to decently efficient code.</p><h3>Brute Force</h3><p>With most array problems, the brute force solution is straightforward. By using nested loops, we can iterate on all possible answer combinations until we find the solution(s) we want. In this case, this is an O(n¬≥) solution. With all of our "sum" problems we can represent the brute force as a O(nÀ£) where x = the number 'sum' the problem is asking for.</p><p>Pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">secondNumber</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">for</span> <span class="n">thirdNumber</span> <span class="k">in</span> <span class="n">array</span>
            <span class="k">if</span> <span class="n">number</span> <span class="o">+</span> <span class="n">secondNumber</span> <span class="o">+</span> <span class="n">thirdNumber</span> <span class="p">=</span> <span class="mi">0</span> <span class="n">AND</span> <span class="n">we</span> <span class="n">have</span> <span class="n">not</span> <span class="n">added</span> <span class="n">this</span> <span class="n">answer</span> <span class="n">combination</span> <span class="n">before</span>
                <span class="n">add</span> <span class="n">these</span> <span class="n">numbers</span> <span class="n">to</span> <span class="n">our</span> <span class="k">return</span> <span class="n">value</span>
</div></code></pre><p>Obviously the nested nature of these arrays should be avoided. So let's take a step back and iterate on our approach from the TwoSum problem.</p><h3>Approach</h3><h3>[ Sort + 2 pointer ]</h3><h3>[ O(n¬≤) time + O(n) space ]</h3><p>We know we need to add up to a target of 0, with 3 different numbers. In formulaic terms, we have X + Y + Z = 0. For each element in our array, we have one of the elements in our equation. So we are left with -Z = X + Y, where Z is our element in the array.</p><p>By sorting our array at the beginning of our function, we can reuse our TwoSum logic. Add up X + Y. If that sum is less than our target (-Z) we need to increase our sum &amp; vice versa. Since our array is sorted, and we can represent X and Y as leftPointer's and rightPointer's in our array, it is easy to increase and decrease our sum as needed. Namely we can do something similar to this.</p><pre><code><div class="highlight"><span></span><span class="bp">sort</span> <span class="n">array</span>
<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="bp">sorted</span> <span class="n">array</span>
    <span class="bp">find</span> <span class="n">the</span> <span class="n">targetNumber</span>
    <span class="bp">find</span> <span class="n">the</span> <span class="n">leftPointer</span>
    <span class="bp">find</span> <span class="n">the</span> <span class="n">rightPointer</span>
    
    <span class="k">while</span> <span class="n">leftPointer</span> <span class="n">less</span> <span class="n">than</span> <span class="n">rightPointer</span>
        <span class="n">sum</span> <span class="p">=</span> <span class="n">leftPointer</span> <span class="o">+</span> <span class="n">rightPointer</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="k">is</span> <span class="n">less</span> <span class="n">than</span> <span class="n">target</span>
            <span class="n">move</span> <span class="n">leftPointer</span> <span class="n">inward</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="k">is</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">target</span>
            <span class="n">move</span> <span class="n">rightPointer</span> <span class="n">inward</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="n">equals</span> <span class="n">target</span> <span class="n">AND</span> <span class="n">not</span> <span class="n">duplicated</span>
            <span class="n">we</span> <span class="n">have</span> <span class="n">our</span> <span class="n">combination</span><span class="p">!</span>
            <span class="n">add</span> <span class="n">to</span> <span class="n">answer</span>
            <span class="n">move</span> <span class="n">both</span> <span class="n">leftPointer</span> <span class="n">and</span> <span class="n">rightPointer</span> <span class="n">inward</span>
</div></code></pre><p>Some time + space considerations here. By sorting we have O(nLog(n)) and then searching every element in the array gives us O(nLog(n)) + O(n¬≤). Since O(n¬≤) is much greater than O(nLog(n)), the O(nLog(n)) cancels out and does not need to be considered in the final time complexity calculations, so the final time complexity is O(n¬≤) time where n is the length of our input array. For space, we need to keep track of the answer in an array, so the space complexity is O(n) where n is the length of the answer.</p><p>Let's implement the real answer.</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for empty array + single element + only 2 elements in array.</span>
<span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[[</span><span class="nb">Int</span><span class="p">]]()</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nv">returnVal</span> <span class="p">=</span> <span class="p">[[</span><span class="nb">Int</span><span class="p">]]()</span>
<span class="kd">let</span> <span class="nv">sorted</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">sorted</span><span class="p">()</span>

<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="bp">sorted</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">target</span> <span class="p">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">element</span>
    <span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="kd">var</span> <span class="nv">rightPointer</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="c1">// search for our target, within bounds</span>
    <span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;</span> <span class="n">rightPointer</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">sum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="o">+</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="p">{</span>
            <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// Sum is too small, increase our sum</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="p">{</span>
            <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1">// Sum is too big, decrease our sum</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">sum</span> <span class="p">==</span> <span class="n">target</span> <span class="p">{</span>
            <span class="c1">// We found an answer!</span>
            <span class="kd">let</span> <span class="nv">correctAns</span> <span class="p">=</span> <span class="p">[</span><span class="n">element</span><span class="p">,</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">],</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]]</span>
            <span class="c1">// Preemptively move our pointers inward </span>
            <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="n">returnVal</span><span class="p">.</span><span class="bp">contains</span><span class="p">(</span><span class="n">correctAns</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// add to our answer</span>
                <span class="n">returnVal</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">correctAns</span><span class="p">)</span>
            <span class="p">}</span> 
        <span class="p">}</span>  
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">returnVal</span>
</div></code></pre><p>Boom! Nicely done.</p><hr><h1>Contains Duplicates</h1><p>This is a pretty straightforward problem, but builds our foundational knowledge when it comes to HashTables! Find the problem statement below.</p><img src="/containsduplicates.png"/><p>Very easy problem to grasp. Now let's try to find ourselves a brute force solution, and optimize it.</p><h3>Brute Force</h3><p>A very easy brute force solution, leads us to an O(n¬≤) time complexity solution with O(1) space. This would be to go by each element in the array, and have a nested loop to see if our outer element is found within our inner loop. Like so:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">number</span> <span class="n">equals</span> <span class="n">other</span> <span class="n">number</span> <span class="n">we</span> <span class="n">have</span> <span class="n">found</span> <span class="n">a</span> <span class="n">duplicate</span><span class="p">.</span>
</div></code></pre><p>By introducing a HashTable into the problem, we know that HashTable's have constant lookup, but at worst, they take up O(n) space where N = length of the input array. Also since HashTable's have unique keys, we will be able to store all of the elements in our array just once.</p><h3>Approach</h3><h3>[ HashTable + Consistent Lookup ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>We can initialize a HashTable at the beginning of our problem, where the key of the HashTable is the same type of element in our input array, in this case Integer. As we loop through our array, we can check if the HashTable already contains a key-element pair that matches Integer at each iteration of the loop. If the key-element pair exists, we can break out of the loop, and return true for our function. If the key-element pair does not exist, we can add it to the HashTable.</p><pre><code><div class="highlight"><span></span><span class="n">Create</span> <span class="n">HashTable</span> <span class="n">with</span> <span class="n">key</span> <span class="n">of</span> <span class="n">Integer</span> <span class="n">and</span> <span class="n">element</span> <span class="n">of</span> <span class="n">whatever</span> <span class="n">you</span> <span class="n">would</span> <span class="n">like</span> 

<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">if</span> <span class="n">element</span> <span class="n">exists</span> <span class="n">with</span> <span class="n">number</span> <span class="k">as</span> <span class="n">the</span> <span class="n">key</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="k">else</span>
        <span class="n">add</span> <span class="n">to</span> <span class="n">the</span> <span class="n">HashTable</span>
</div></code></pre><p>Pretty simple right! Like I mentioned above, the time and space are both O(n). This is why HashTables are so powerful, is because they give us consistent lookup time when we need some auxiliary storage in our problems. Now it is time to implement the real solution.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span> <span class="c1">// edge-case check against small or empty inputs</span>

<span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span> <span class="c1">// i opted for an Int:Int pair, but you could have easily done Int:Bool, etc. </span>
        
<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// loop our input array</span>
    <span class="k">if</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span> <span class="c1">// We have found a duplicate!</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="n">index</span> <span class="c1">// Add element to HashTable</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="kc">false</span> <span class="c1">// No duplicates here...</span>
</div></code></pre><p>Easy-Peasy.</p><hr><h1>Product Of Array Except Self</h1><p>This problem is our first introduction on how to traverse an array both forwards and backwards! Let's dive in.</p><img src="/productexceptself.png"/><p>We need to come up with a brute force solution to start, and like every other array problem, we can nest iterations in order to get every possible combination in the array.</p><h3>Brute Force</h3><p>We can start at each point in a given array and calculate every other arrays product, and add it to a return value. This leads us to a O(n¬≤) time complexity and an O(n) spatial complexity because we need to store the length of the return array in our function. This is O(n¬≤) time due to the nested nature of our iterations within the array.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">iterate</span> <span class="n">through</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">array</span>
        <span class="n">calculate</span> <span class="n">the</span> <span class="n">product</span>
    <span class="n">add</span> <span class="n">product</span> <span class="n">to</span> <span class="k">return</span> <span class="n">value</span> 
</div></code></pre><h3>Approach</h3><h3>[ Forward + Backward Iteration ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>We can optimize this problem by filling in our return array only twice. We can loop forward through our auxiliary return array once, keep a running product at each iteration, and use the running product to fill our return value array. Then we can reset our running product count, and iterate our array backwards to keep a running count of all the values minus itself.</p><p>The thinking here is, as we iterate our array we can fill in our return value in place. On the first loop, returnArray[i] will contain proceeding product of nums[i] (exclusive). After the second loop, each returnArray[i] is updated by multiplying to succeeding product of nums[i].</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">running</span> <span class="bp">count</span> <span class="n">starting</span> <span class="n">at</span> <span class="mi">1</span>
<span class="n">create</span> <span class="k">return</span> <span class="n">array</span> <span class="n">of</span> <span class="n">all</span> <span class="mi">1</span><span class="err">&#39;</span><span class="n">s</span>

<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span> <span class="n">forward</span> <span class="n">direction</span>
    <span class="n">update</span> <span class="k">return</span> <span class="n">array</span> <span class="n">with</span> <span class="n">running</span> <span class="bp">count</span>
    <span class="n">update</span> <span class="n">running</span> <span class="bp">count</span> <span class="n">by</span> <span class="n">multiplying</span> <span class="n">number</span> <span class="n">to</span> <span class="n">existing</span> <span class="bp">count</span> 
    
<span class="n">reset</span> <span class="n">running</span> <span class="bp">count</span>

<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span> <span class="n">backwards</span> <span class="n">direction</span>
    <span class="n">update</span> <span class="k">return</span> <span class="n">array</span> <span class="n">by</span> <span class="n">multiplying</span> <span class="n">running</span> <span class="bp">count</span> <span class="n">by</span> <span class="n">number</span> <span class="k">in</span> <span class="n">input</span> <span class="n">array</span>
    <span class="n">update</span> <span class="n">running</span> <span class="bp">count</span> <span class="n">by</span> <span class="n">multiplying</span> <span class="n">number</span> <span class="n">to</span> <span class="n">existing</span> <span class="bp">count</span>
    
<span class="k">return</span>
</div></code></pre><p>This gives us an O(n) time solution since we only have to iterate twice, namely forward and backwards. O(2n) = O(n) on average. Space is still consistently O(n). Now let's implement the real solution.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[]</span> <span class="p">}</span> <span class="c1">// guard against edge cases</span>
<span class="kd">var</span> <span class="nv">auxArray</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">repeating</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">count</span><span class="p">:</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span><span class="p">)</span> <span class="c1">// create a return array of all 1&#39;s</span>
<span class="kd">var</span> <span class="nv">runningCount</span> <span class="p">=</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.&lt;</span><span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span> <span class="c1">// forward iteration</span>
    <span class="n">auxArray</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">runningCount</span>
    <span class="n">runningCount</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="c1">// update running count of product</span>
<span class="p">}</span>

<span class="n">runningCount</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// reset the running count</span>

<span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="bp">stride</span><span class="p">(</span><span class="n">from</span><span class="p">:</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">through</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">by</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// backward iteration</span>
    <span class="n">auxArray</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">*=</span> <span class="n">runningCount</span>
    <span class="n">runningCount</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="c1">// update running count of product</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">auxArray</span>
</div></code></pre><p>Good Job!</p><hr><h1>Valid Anagram</h1><p>This problem expands our knowledge on array best practices! Let's tackle it.</p><img src="/validanagram.png"/><h3>Brute Force</h3><p>Let's start by thinking of a brute force solution. My brute force solution I came up with involved a little different of an approach as opposed to other array problems. Nesting arrays in this problem isn't quite where my head first went. Initially I thought it would be easiest to sort both input strings, and then go letter by letter to compare the two strings. When we find a deviation between the two, we do not have a valid anagram.</p><pre><code><div class="highlight"><span></span><span class="bp">sort</span> <span class="n">string</span> <span class="n">s</span>
<span class="bp">sort</span> <span class="n">string</span> <span class="n">t</span>

<span class="n">make</span> <span class="n">sure</span> <span class="n">they</span> <span class="n">are</span> <span class="n">the</span> <span class="n">same</span> <span class="n">length</span> 

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">s</span> <span class="n">or</span> <span class="n">t</span> <span class="n">length</span>
    <span class="k">if</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">s</span> <span class="n">does</span> <span class="n">not</span> <span class="bp">equal</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">t</span>
        <span class="k">return</span> <span class="kc">false</span>
        
<span class="k">if</span> <span class="n">we</span> <span class="kr">get</span> <span class="n">here</span><span class="p">,</span> <span class="n">we</span> <span class="n">have</span> <span class="n">a</span> <span class="n">valid</span> <span class="n">anagram</span>
</div></code></pre><p>Looping the strings is not the issue here. Sorting 2 different strings, and then looping is not very optimal. By sorting we can get, on average, O(nLog(n)) time performance. Make that sorting twice plus looping the strings we are looking at O(2nLog(n)) + O(n) time complexity. We can simplify this to O(3nLog(n)) -&gt; O(nLog(n)) time, with O(1) consistent space complexity.</p><p>We know we can do better though. It may be worth giving up our consistent space complexity to get a better time complexity.</p><h3>Approach</h3><h3>[ HashTable with letter occurrences ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>We can introduce our arrays best friend! A hash table. We can store the occurrences of each letter in our hashTable. Utilizing a hash table here gives us consistent O(1) lookup when we need to know how many times we have seen a character. We have 2 strings, for one string we can increase the number of occurrences, for another string we can decrease the number of occurrences. In a perfect world, our hash table should have values of all 0's if it is a valid anagram.</p><pre><code><div class="highlight"><span></span><span class="n">check</span> <span class="n">string</span> <span class="n">lengths</span> <span class="n">are</span> <span class="bp">equal</span>
<span class="n">create</span> <span class="n">hash</span> <span class="n">table</span>

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">s</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span> <span class="bp">contains</span> <span class="n">this</span> <span class="n">letter</span> <span class="n">already</span>
        <span class="n">increment</span> <span class="n">its</span> <span class="n">occurrence</span> <span class="n">number</span> <span class="n">by</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span> <span class="n">does</span> <span class="n">not</span> <span class="n">contain</span> <span class="n">this</span> <span class="n">letter</span>
        <span class="n">add</span> <span class="n">it</span> <span class="n">to</span> <span class="n">the</span> <span class="n">hash</span> <span class="n">table</span> <span class="n">with</span> <span class="n">an</span> <span class="n">occurrence</span> <span class="n">of</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">t</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span> <span class="bp">contains</span> <span class="n">this</span> <span class="n">letter</span> <span class="n">already</span>
        <span class="n">decrement</span> <span class="n">its</span> <span class="n">occurrence</span> <span class="n">number</span> <span class="n">by</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span> <span class="n">does</span> <span class="n">not</span> <span class="n">contain</span> <span class="n">this</span> <span class="n">letter</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="n">we</span> <span class="n">have</span> <span class="n">found</span> <span class="n">a</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">t</span> <span class="n">that</span> <span class="n">s</span> <span class="n">does</span> <span class="n">not</span> <span class="n">have</span>
        
<span class="k">for</span> <span class="n">values</span> <span class="k">in</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">value</span> <span class="k">is</span> <span class="n">not</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">false</span>

<span class="k">return</span> <span class="kc">true</span>
</div></code></pre><p>This solution contains 3 loops. This equates to O(3n) ‚Üí O(n) on average time complexity. Our space complexity is O(n) where n is the number of unique characters in s and t. This can also be represented as O(max(s.length, t.length)) at worst case. It's time to bring it all together:</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">s</span><span class="p">.</span><span class="bp">count</span> <span class="p">==</span> <span class="n">t</span><span class="p">.</span><span class="bp">count</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span> <span class="c1">// edge case where our string lengths may not be equal</span>
<span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Character</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span>

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">existing</span> <span class="p">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">=</span> <span class="n">existing</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// if we have already seen this character, append its count by 1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// we have not seen this character yet, add to hash table</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">t</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">existing</span> <span class="p">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">=</span> <span class="n">existing</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// decrement the character occurrence by 1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span> <span class="c1">// t contains a letter s does not have. not a valid anagram</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">hashTable</span><span class="p">.</span><span class="n">values</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span> <span class="c1">// we have found a letter where s contains more occurrences than t, and vice versa</span>
<span class="p">}</span>
<span class="k">return</span> <span class="kc">true</span> <span class="c1">// valid!</span>
</div></code></pre><p>Nice!</p><hr><h1>Valid Palindrome</h1><p>Similar to our problem with Anagrams, this problem is a play on a string, but can easily be thought of as an array problem. One thing to note about this problem is PAY ATTENTION! The little details on some of these leetcode problems can kill you. Notice we should ignore non alphanumeric characters + ignore spaces. Also notice how we should be treating all alphanumerics as lowercased.</p><img src="/validpalindrome.png"/><h3>Brute Force</h3><p>As always we start with a Brute Force solution and optimize. Here we can think of the string as an array of characters. Initially we can consider the option of nested arrays with a pointer. We start at the first letter, traverse to the last letter, and make sure they match. Then go to the 2nd letter, traverse to the 2nd to last letter and see if they match. We can do this for all letters nums[x]...nums[length-x] until we meet in the middle.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">alphanumeric</span> <span class="n">character</span> <span class="k">in</span> <span class="n">string</span> 
    <span class="n">traverse</span> <span class="n">to</span> <span class="n">length</span> <span class="o">-</span> <span class="n">x</span> <span class="n">letter</span> <span class="n">of</span> <span class="n">the</span> <span class="n">string</span><span class="p">,</span> <span class="n">that</span> <span class="k">is</span> <span class="n">alphanumeric</span>
        <span class="k">if</span> <span class="n">letters</span> <span class="n">are</span> <span class="n">the</span> <span class="n">same</span>
            <span class="k">continue</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="kc">false</span>
</div></code></pre><p>The bottleneck within this problem is the inner traversal of the string to get to the length - x character in the string. Our brute force solution is on average O(n¬≤) time complexity, with a consistent O(1) spatial complexity. We do not keep any extra storage so we do not take up any extra space. Depending how we check if numbers are alphanumeric, our time complexity may be even slower than O(n¬≤).</p><h3>Approach</h3><h3>[ 2 pointers ]</h3><h3>[ O(n) time + O(1) space ]</h3><p>We can utilize the 2 pointer method, commonly found in arrays for this problem. If we take our string, and put a pointer at the beginning and end of the string, we can move our 2 pointers closer together until they meet in the middle, with O(1/2n) time complexity -&gt; which averages out to O(n).</p><p>We should also take considerations on how to check if a character is alphanumeric. We could create an array of letters and an array of numbers, and check if those array's contain our character. By doing this we introduce poor time complexity into our code. Say our string contains multiple Z's. We would need to traverse the entire alphabet array to see if the character is a letter. A more efficient solution would be to utilize properties on the Swift Standard Library. The Character object comes with built in "isLetter" and "isNumber" properties. Under the hood Swift compares the ASCII encoding value of your character to different ranges of letters and numbers, to ensure it is alphanumeric. This is a much more efficient solution than the array of letters approach.</p><pre><code><div class="highlight"><span></span><span class="n">create</span> <span class="kr">left</span> <span class="n">pointer</span>
<span class="n">create</span> <span class="kr">right</span> <span class="n">pointer</span>
<span class="n">create</span> <span class="n">array</span> <span class="n">of</span> <span class="n">lowercased</span> <span class="n">letters</span> <span class="c1">// O(n)</span>

<span class="k">while</span> <span class="kr">left</span> <span class="n">pointer</span> <span class="o">&lt;=</span> <span class="kr">right</span> <span class="n">pointer</span> <span class="c1">// O(1/2n) at worst</span>
    <span class="n">make</span> <span class="n">sure</span> <span class="kr">left</span> <span class="n">pointer</span> <span class="k">is</span> <span class="n">alphanumeric</span>
        <span class="k">if</span> <span class="n">not</span><span class="p">,</span> <span class="k">continue</span> <span class="n">thru</span> <span class="n">the</span> <span class="n">loop</span>
    <span class="n">make</span> <span class="n">sure</span> <span class="kr">right</span> <span class="n">pointer</span> <span class="k">is</span> <span class="n">alphanumeric</span>
        <span class="k">if</span> <span class="n">not</span><span class="p">,</span> <span class="k">continue</span> <span class="n">thru</span> <span class="n">the</span> <span class="n">loop</span>
    <span class="k">if</span> <span class="kr">left</span> <span class="n">pointer</span> <span class="n">does</span> <span class="n">not</span> <span class="bp">equal</span> <span class="kr">right</span> <span class="n">pointer</span>
        <span class="k">return</span> <span class="kc">false</span>
    
    <span class="n">move</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">pointers</span> <span class="n">inward</span> <span class="k">in</span> <span class="n">the</span> <span class="n">array</span>
</div></code></pre><p>We do not necessarily have to convert our string into an array of lowercased letters. I chose to do this because of the difficulty of indexing a string in swift. To index a certain letter in a string, you cannot just subscript like: str[9]. You must use the built in String.Index type. So for proper, clean code you may implement something like this:</p><pre><code><div class="highlight"><span></span><span class="kd">extension</span> <span class="nc">StringProtocol</span> <span class="p">{</span>
    <span class="kd">subscript</span><span class="p">(</span><span class="n">offset</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Character</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="n">offset</span><span class="p">)]</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Given the short amount of time in a leetcode interview, I tend to stay away, and just convert to an array when possible. Make sure to weigh trade-offs with your interviewer though! If keep the structure as the original string, we would just have to convert the letters to lowercase on each comparison.</p><p>Let's implement our O(n) time, and O(1) space solution.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">s</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span> <span class="c1">// guard against edge cases</span>
             
<span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rightPointer</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// create our pointers</span>
<span class="kd">var</span> <span class="nv">arr</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">lowercased</span><span class="p">())</span> <span class="c1">// convert to an array</span>

<span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;=</span> <span class="n">rightPointer</span> <span class="p">{</span> <span class="c1">// loop until our pointers meet in the middle</span>
    <span class="k">guard</span> <span class="n">arr</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">].</span><span class="n">isLetter</span> <span class="o">||</span> <span class="n">arr</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">].</span><span class="n">isNumber</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// make sure left is alphanumeric</span>
        <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// if not, move left pointer inward and continue the loop</span>
        <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">guard</span> <span class="n">arr</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">].</span><span class="n">isLetter</span> <span class="o">||</span> <span class="n">arr</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">].</span><span class="n">isNumber</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// make sure right is alphanumeric</span>
        <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1">// if not, move the right pointer inward and continue the loop</span>
        <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="o">!=</span> <span class="n">arr</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// if our letters are not equal, return false</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
                
    <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// move left inward</span>
    <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1">// move right inward</span>
<span class="p">}</span>
<span class="k">return</span> <span class="kc">true</span>
</div></code></pre><p>Great Job! and remember, keep an eye out for the little details in a problem description.</p><hr><h1>Group Anagrams</h1><p>This next problem expands our previous knowledge around what makes an anagram valid. Now let's use this base knowledge to group similar sets of anagrams!</p><img src="/groupanagrams.png"/><h3>Brute Force</h3><p>The brute force solution for this problem is pretty straight forward. We can use nested For Loops to find all the anagram groups for a given element, group similar ones, and return the groups in a nested return array.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">word</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">start</span> <span class="n">an</span> <span class="n">anagram</span> <span class="n">group</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">word</span> <span class="k">in</span> <span class="n">the</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">outer</span> <span class="n">and</span> <span class="n">inner</span> <span class="n">word</span> <span class="n">are</span> <span class="n">valid</span> <span class="n">anagrams</span> <span class="n">of</span> <span class="n">each</span> <span class="n">other</span> <span class="o">&amp;</span> <span class="n">not</span> <span class="k">in</span> <span class="n">anagram</span> <span class="n">group</span> <span class="n">array</span>
            <span class="n">add</span> <span class="n">words</span> <span class="n">to</span> <span class="n">anagram</span> <span class="n">group</span> <span class="n">array</span>
    <span class="n">add</span> <span class="n">anagram</span> <span class="n">group</span> <span class="n">array</span> <span class="n">to</span> <span class="k">return</span> <span class="n">value</span>
    
<span class="k">return</span> <span class="n">the</span> <span class="k">return</span> <span class="n">value</span>
</div></code></pre><p>This is obviously an inefficient solution due to the 2 nested arrays. This solution would give us an O(n¬≤) time solution + the time to check if the words are anagrams of one another + the time to check if the words are not in an anagram array. This total time equates to O(n¬≤xw), where n is the length of the input array, x is the length of the longest word, and w is the length of the longest anagram array. Not great. Space complexity is O(n) where n is the length of the return value.</p><h3>Approach</h3><h3>[ Sort + HashTable ]</h3><h3>[ O(wnLog(n)) time + O(wn) space ]</h3><p>The bottle necks we can identify from our brute force solution, is obviously: validating 2 words are anagrams of one another, and the grouping mechanism of the nested loops. We need to be able to find the groups faster.</p><p>One easy way to think about this is: We can find if two strings are anagrams of one another by sorting the letters in the strings alphabetically. For example, we know "rat" &amp; "tar" are anagrams because if we sort those two strings, "art" &amp; "art" are equal to one another.</p><p>Another good thought to have is, if we know a strings sorted representation we can figure out its group easily with a HashTable. If we know "rat" &amp; "art" &amp; tar" are all anagrams of one another, we can sort all of them in a Hashtable with their common sorted representation of "art" as HashTable key. It would look something like this:</p><pre><code><div class="highlight"><span></span><span class="kr">get</span> <span class="bp">sorted</span> <span class="n">representations</span> <span class="n">of</span> <span class="n">the</span> <span class="n">input</span> <span class="n">array</span><span class="p">...</span><span class="bp">sort</span> <span class="n">each</span> <span class="n">element</span>

<span class="k">for</span> <span class="n">index</span> <span class="n">of</span> <span class="bp">sorted</span>
    <span class="k">if</span> <span class="n">our</span> <span class="bp">sorted</span> <span class="n">representation</span> <span class="k">is</span> <span class="n">already</span> <span class="k">in</span> <span class="n">the</span> <span class="n">HashTable</span>
        <span class="kr">get</span> <span class="n">the</span> <span class="n">value</span><span class="p">,</span> <span class="n">and</span> <span class="n">add</span> <span class="n">the</span> <span class="n">element</span> <span class="n">of</span> <span class="n">the</span> <span class="n">input</span> <span class="n">array</span> <span class="p">(</span><span class="n">at</span> <span class="n">this</span> <span class="n">index</span><span class="p">)</span> <span class="n">to</span> <span class="n">the</span> <span class="n">hashTable</span> <span class="n">value</span>
    <span class="k">if</span> <span class="n">our</span> <span class="bp">sorted</span> <span class="n">representation</span> <span class="k">is</span> <span class="n">NOT</span> <span class="k">in</span> <span class="n">the</span> <span class="n">HashTable</span>
        <span class="n">add</span> <span class="n">it</span><span class="p">,</span> <span class="n">with</span> <span class="n">a</span> <span class="n">value</span> <span class="n">of</span> <span class="n">the</span> <span class="n">element</span> <span class="n">of</span> <span class="n">the</span> <span class="n">input</span> <span class="n">array</span><span class="p">,</span> <span class="n">at</span> <span class="n">this</span> <span class="n">index</span><span class="p">.</span>


<span class="k">for</span> <span class="n">values</span> <span class="k">in</span> <span class="n">our</span> <span class="n">HashTable</span>
    <span class="n">append</span> <span class="n">them</span> <span class="n">to</span> <span class="n">the</span> <span class="k">return</span> <span class="n">value</span>

<span class="k">return</span> <span class="n">the</span> <span class="k">return</span> <span class="n">value</span>
</div></code></pre><p>This can be a little wordy on the plan english implementation but we will see it with code soon enough. The space complexity of this solution is O(wn) where w is the number of unique words, and n is the length of the longest word. The time complexity of this problem is the time it takes to sort the input array O(nLogn) times the number of words in the input array that are unique. This comes out to be O(wnLog(n)) time.</p><p>The final product:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">sorted</span> <span class="p">=</span> <span class="n">strs</span><span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nb">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">.</span><span class="bp">sorted</span><span class="p">())</span> <span class="p">}</span> <span class="c1">// Our array of sorted representations</span>
<span class="kd">var</span> <span class="nv">returnVal</span> <span class="p">=</span> <span class="p">[[</span><span class="nb">String</span><span class="p">]]()</span>
<span class="kd">var</span> <span class="nv">hashMap</span> <span class="p">=</span> <span class="p">[</span><span class="nb">String</span><span class="p">:</span> <span class="p">[</span><span class="nb">String</span><span class="p">]]()</span>
        
<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="bp">sorted</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">var</span> <span class="nv">existing</span> <span class="p">=</span> <span class="n">hashMap</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// if our element is already in the HashTable</span>
        <span class="n">existing</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">strs</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="c1">// Get the grouped words, and add our new word to the existing array</span>
        <span class="n">hashMap</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="n">existing</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">hashMap</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span><span class="n">strs</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span> <span class="c1">// It is not in HashTable yet, lets add the unique string to it as a key, with our original word as the value</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="n">hashMap</span><span class="p">.</span><span class="n">values</span> <span class="p">{</span> <span class="n">returnVal</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// For all grouped words, lets append it to our return value.</span>

<span class="k">return</span> <span class="n">returnVal</span>
</div></code></pre><p>Well Done!</p><hr><h1>Longest Consecutive Sequence</h1><p>This problem is our introduction into common leetcode problems, namely sequences and subsequences.</p><img src="/longestconsecutivesequence.png"/><h3>Brute Force</h3><p>We should make sure we read the problem carefully here. There are a couple things to keep in mind:</p><ul><li>The numbers are unsorted</li><li>We do not care <em>what</em> the longest consecutive sequence is, we just care about the length of the longest sequence</li><li>We <em>must</em> have an O(n) solution</li></ul><p>Because we need an O(n) solution, it may be a waste of our time thinking of Brute force solutions. We know also that we cannot sort this list of unsorted numbers, because sorting alone will give us, at best, O(nLogn) time complexity.</p><p>It's important here to realize what makes a sequence. If we have a number X, we know we have a sequence if X - 1 or X + 1 exists. If we wanted to think of a brute force solution, we could start by iterating on every element and looking for something that would match a sequence on each number. If we find a number, we could loop once again expanding left and right of our sequence.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">inner</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">inner</span> <span class="n">makes</span> <span class="n">a</span> <span class="n">sequence</span>
            <span class="n">search</span> <span class="k">for</span> <span class="n">expansion</span> <span class="n">of</span> <span class="kr">left</span> <span class="n">of</span> <span class="n">sequence</span>
            <span class="n">search</span> <span class="k">for</span> <span class="n">expansion</span> <span class="n">of</span> <span class="kr">right</span> <span class="n">of</span> <span class="n">sequence</span>
        <span class="n">keep</span> <span class="n">track</span> <span class="k">if</span> <span class="n">this</span> <span class="k">is</span> <span class="n">the</span> <span class="n">longest</span> <span class="n">we</span> <span class="n">have</span> <span class="n">seen</span>
<span class="k">return</span> <span class="n">the</span> <span class="n">longest</span> <span class="n">we</span> <span class="n">have</span> <span class="n">seen</span>
</div></code></pre><p>Overall this works, but has terrible efficiency. We have two nested loops, which gives us O(n¬≤) time complexity. Plus for our expansion of the left &amp; right of our sequence, we would continually search in our array for those. At best a searching algorithm could give us O(2Logn) because we have to do it twice. Overall this gives us O(n¬≤Logn) time complexity. Just not great.</p><h3>Approach</h3><h3>[ HashTable ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>Yep! You guessed it, we are bringing back our friend the hash table. We can look for the existence of a sequence as we iterate on our array. And store each value in our array to see if we have seen a possible sequence already.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">keep</span> <span class="n">track</span> <span class="n">of</span> <span class="n">this</span> <span class="n">iterative</span> <span class="n">sequence</span> <span class="n">length</span>
    <span class="k">while</span> <span class="err">¬±</span> <span class="mi">1</span> <span class="n">of</span> <span class="n">our</span> <span class="n">number</span> <span class="n">exists</span> <span class="k">in</span> <span class="n">the</span> <span class="n">hashTable</span>
        <span class="n">append</span> <span class="n">to</span> <span class="n">our</span> <span class="n">sequence</span>
        <span class="n">keep</span> <span class="n">expanding</span> <span class="k">in</span> <span class="n">the</span> <span class="n">direction</span> <span class="n">we</span> <span class="n">are</span> <span class="n">checking</span>
    <span class="n">add</span> <span class="n">this</span> <span class="n">number</span> <span class="n">to</span> <span class="n">the</span> <span class="n">hashTable</span>
    <span class="n">what</span> <span class="k">is</span> <span class="n">bigger</span><span class="p">,</span> <span class="n">the</span> <span class="n">longest</span> <span class="n">sequence</span> <span class="n">we</span> <span class="n">have</span> <span class="n">seen</span><span class="p">?</span> <span class="n">or</span> <span class="n">this</span> <span class="n">iterative</span> <span class="n">sequence</span> <span class="n">length</span><span class="p">?</span>

<span class="k">return</span> <span class="n">longest</span>
</div></code></pre><p>This is an O(n) solution, where n is the length of the input array, because we only iterate through the array once, and our while loop is just checking for the existence of a number in a hash table. Hash Table's give us O(1) lookup which is awesome. Our space is O(n) because we are just filling a hashTable, and a hashTable can only be n length where n is the number of unique numbers in our input array. Let's create the final answer:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">longest</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// Initially our greatest sequence will be 0</span>
<span class="kd">var</span> <span class="nv">hashMap</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">:</span><span class="nb">Bool</span><span class="p">]()</span>

<span class="k">for</span> <span class="n">element</span> <span class="k">in</span> <span class="n">nums</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">minusOne</span> <span class="p">=</span> <span class="n">element</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// Create a variable for the left section of our possible sequence</span>
    <span class="kd">var</span> <span class="nv">plusOne</span> <span class="p">=</span> <span class="n">element</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// Create a variable for the right section of our possible sequence</span>
    <span class="kd">var</span> <span class="nv">thisSequenceLongest</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">hashMap</span><span class="p">[</span><span class="n">minusOne</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// While we have seen a left sequence (it exists in our hashTable)</span>
        <span class="n">thisSequenceLongest</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">minusOne</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1">// Keep expanding</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="n">hashMap</span><span class="p">[</span><span class="n">plusOne</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// While we have seen a right sequence (it exists in our hashTable)</span>
        <span class="n">thisSequenceLongest</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">plusOne</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// Keep expanding</span>
    <span class="p">}</span>
    <span class="n">hashMap</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span> <span class="c1">// Add this element to our hashTable</span>
    <span class="n">longest</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">longest</span><span class="p">,</span> <span class="n">thisSequenceLongest</span><span class="p">)</span> <span class="c1">// Update the longest sequence we have seen</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">longest</span>
</div></code></pre><p>Nice! This was definitely a tricky one.</p><hr><h1>Encode and Decode Strings</h1><p>This is a LeetCode premium question, but still worth going over as it gives good insight on Array/String manipulation! This is a classic Google question too. Here is the screenshot:</p><img src="/encodedecodestrings.png"/><h3>Possible Ideas</h3><p>Pretty straight forward! And considering there is not really a point to optimize a brute force solution lets walk through some thoughts.<br><br>1. We have to create 2 functions, an encoding function &amp; a decoding function. The importance is how we need to encode our original array, so our decoding function will know how to handle the string. 2. We need to make this generic enough to use any ASCII characters. 3. This must be stateless. No class level variables allowed.</p><p>So when I looked at this problem, my first thought was 'I need a way to mark the separation of values in our original array'. For example if we have an input array of ["Alex", "Loves", "Google"] then I need a special character to mark the difference between "Alex" and "Google". With this thinking, I chose "#" as my separation character. ["Alex", "Loves", "Google"] would turn into ‚Üí "Alex#Loves#Google". Nice!</p><p>This causes concern though. In our original problem statement, the question mentioned we need these functions to be generic enough to host any ASCII character. If we use any ASCII character as our separation element, there is the chance the separation element appears in our input array. Let's take the input array of ["Alex", "#", "R"] for example. If our separation element is "#" our input array would be encoded to "Alex###R". When we go to decode this, and decode based on separation elements, does the string "Alex###R" translate to ["Alex", "##R"]? Or ["Alex#", "#R"]? Or ["Alex#", "#", "R"]? There is no way to know. And no matter the separation character we choose to use, this will be a problem.</p><p>To solve this, we need a way to define 1. the separation of characters, and 2. the beginning and end of an element. A straight forward way to go about this is by using the word's length + separation character at the beginning of each element. For example ["Alex", "#", "R"] is encoded into "4#Alex1##1#R". The thinking here is, when we get to separation character, the previous number to it will tell us how far ahead to skip for our element. So on and so forth ad nauseam. Let's get some psuedocode together for the encoding and decoding.</p><pre><code><div class="highlight"><span></span><span class="n">Encoding</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">word</span> <span class="k">in</span> <span class="n">input</span>
        <span class="n">concatenate</span> <span class="k">return</span> <span class="n">string</span> <span class="n">with</span><span class="p">:</span> <span class="n">word</span> <span class="n">length</span> <span class="o">+</span> <span class="s">&quot;#&quot;</span> <span class="o">+</span> <span class="n">word</span>
    <span class="k">return</span> <span class="n">the</span> <span class="n">encoded</span> <span class="n">string</span>
    
    
<span class="n">Decoding</span><span class="p">:</span>
    <span class="n">start</span> <span class="n">at</span> <span class="n">the</span> <span class="n">beginning</span> <span class="n">of</span> <span class="n">the</span> <span class="n">encoded</span> <span class="n">string</span>
    <span class="k">while</span> <span class="n">this</span> <span class="n">index</span> <span class="k">is</span> <span class="k">in</span> <span class="n">bounds</span> <span class="n">of</span> <span class="n">the</span> <span class="n">string</span>
        <span class="n">start</span> <span class="n">a</span> <span class="n">new</span> <span class="n">index</span> <span class="k">for</span> <span class="n">the</span> <span class="n">current</span> <span class="n">element</span>
        <span class="k">while</span> <span class="n">this</span> <span class="n">new</span> <span class="n">index</span> <span class="k">is</span> <span class="n">not</span> <span class="n">a</span> <span class="n">separation</span> <span class="n">character</span>
            <span class="n">append</span> <span class="n">to</span> <span class="n">new</span> <span class="n">index</span> <span class="n">by</span> <span class="mi">1</span>
        <span class="k">else</span>
            <span class="kr">get</span> <span class="n">word</span> <span class="n">size</span> <span class="n">from</span> <span class="n">index</span> <span class="p">-&gt;</span> <span class="n">newIndex</span>
            <span class="kr">get</span> <span class="n">word</span> <span class="n">from</span> <span class="n">new</span> <span class="n">index</span> <span class="p">-&gt;</span> <span class="n">word</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">append</span> <span class="n">word</span> <span class="n">to</span> <span class="n">response</span>
            <span class="n">track</span> <span class="n">new</span> <span class="n">index</span> <span class="n">at</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">the</span> <span class="bp">last</span> <span class="n">added</span> <span class="n">word</span>
</div></code></pre><p>Lot of Math there! Let's talk some time complexities. Encoding function will obviously be O(n) time where n is the length of the inout array. The space complexity will be O(c + 1 + s) where c is the number of characters in our input array, s is the separation character or string we choose, and 1 for the length of the word in Int form.</p><p>Decoding is a little more complicated. The space complexity is O(n) where n is the length of our original input array. The time complexity is O(n - x) where n is the length of characters in our encoded string, and x is the number of elements in our original input array. Not too bad.</p><h3>Approach</h3><h3>[ Separation Characters + Length ]</h3><h3>[ Encoding: O(n) time, O(c + 1 + s) space ]</h3><h3>[ Decoding: O(n - x) time, O(n) space ]</h3><p>Let's put this implementation to the test!</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="kc">_</span> <span class="n">words</span><span class="p">:</span> <span class="p">[</span><span class="nb">String</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">returnVal</span> <span class="p">=</span> <span class="s">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">word</span> <span class="k">in</span> <span class="n">words</span> <span class="p">{</span>
        <span class="n">returnVal</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="si">\(</span><span class="n">word</span><span class="p">.</span><span class="bp">count</span><span class="si">)</span><span class="s">&quot;</span> <span class="o">+</span> <span class="s">&quot;#&quot;</span> <span class="o">+</span> <span class="n">word</span> <span class="c1">// Pre-traversal concatenation</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">returnVal</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="kc">_</span> <span class="n">str</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="nb">String</span><span class="p">]</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">returnVal</span> <span class="p">=</span> <span class="p">[</span><span class="nb">String</span><span class="p">]()</span>
    <span class="kd">var</span> <span class="nv">index</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span> <span class="c1">// Loop through characters in our encoded string</span>
        
        <span class="kd">var</span> <span class="nv">thisWordIndex</span> <span class="p">=</span> <span class="n">index</span> <span class="c1">// Index for this given word</span>
        <span class="k">while</span> <span class="n">thisWordIndex</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nv">currentElementIndex</span> <span class="p">=</span> <span class="n">str</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="n">thisWordIndex</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">str</span><span class="p">[</span><span class="n">currentElementIndex</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;#&quot;</span> <span class="p">{</span> <span class="c1">// While we have not found a new word, continue</span>
                <span class="n">thisWordIndex</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">break</span> <span class="c1">// We have found a word, time to evaluate</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="kd">let</span> <span class="nv">beginningIndex</span> <span class="p">=</span> <span class="n">str</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="n">index</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">endingIndex</span> <span class="p">=</span> <span class="n">str</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="n">thisWordIndex</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">wordSize</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">beginningIndex</span><span class="p">..&lt;</span><span class="n">endingIndex</span><span class="p">])</span> <span class="p">??</span> <span class="mi">0</span> <span class="c1">// The size of the word</span>
        
        <span class="kd">let</span> <span class="nv">wordBeginningIndex</span> <span class="p">=</span> <span class="n">str</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="n">thisWordIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">wordEndingIndex</span> <span class="p">=</span> <span class="n">str</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="n">thisWordIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">wordSize</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">word</span> <span class="p">=</span> <span class="n">str</span><span class="p">[</span><span class="n">wordBeginningIndex</span><span class="p">..&lt;</span><span class="n">wordEndingIndex</span><span class="p">]</span> <span class="c1">// The word itself</span>
        
        <span class="n">returnVal</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="n">word</span><span class="p">))</span> <span class="c1">// Append the word to our return array</span>
        <span class="n">index</span> <span class="p">=</span> <span class="n">thisWordIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">wordSize</span> <span class="c1">// Set index to the end of our last word found and continue.</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">returnVal</span>
<span class="p">}</span>
</div></code></pre><p>Substrings in Swift are NOT FUN üòé</p><hr><h1>Top K Frequent Elements</h1><p>This is a tricky problem, especially in the iOS world.</p><img src="/topkfrequentelements.png"/><h3>Brute Force</h3><p>I think the brute force solution is pretty obvious. We can nest loops, and for every element we can count how often it appears in the input array. Outside of our loops we can keep track of the largest count. Based on our K input integer we can build out our top k frequent elements array.</p><pre><code><div class="highlight"><span></span><span class="n">create</span> <span class="n">array</span> <span class="n">of</span> <span class="n">k</span> <span class="n">length</span>

<span class="k">for</span> <span class="n">indexed</span> <span class="n">loop</span> <span class="n">from</span> <span class="mi">1</span> <span class="p">-&gt;</span> <span class="n">k</span>
    <span class="n">loop</span> <span class="n">input</span> <span class="n">array</span> <span class="n">and</span> <span class="bp">find</span> <span class="n">most</span> <span class="n">indexed</span> <span class="n">most</span> <span class="n">element</span> <span class="n">and</span> <span class="n">its</span> <span class="bp">count</span>
    <span class="n">compare</span> <span class="n">after</span> <span class="n">each</span> <span class="n">loop</span> <span class="n">to</span> <span class="n">see</span> <span class="k">if</span> <span class="n">the</span> <span class="k">return</span> <span class="n">array</span> <span class="n">needs</span> <span class="n">to</span> <span class="n">be</span> <span class="n">adjusted</span>
</div></code></pre><p>This has two nested loops so the time complexity here would be O(nk) where n is the length of the input array, and k is the input variable k. The space complexity would be O(k) where k is the input variable k we start the problem with, due to the length of the return variable.<br><br>Even a brute force solution here would be difficult, so lets simplify our lives a little bit, and introduce our favorite friends: Sorting and A HashTable.</p><h3>Approach</h3><h3>[ Sort + HashTable ]</h3><h3>[ O(uLogu) time + O(2u) space ]</h3><p>One easy way to simplify storing the count of each character frequency is to use a HashTable. We can use the HashTable as an [Int:Int] dictionary where each key is the unique element in the input array, and the value is its frequency in the input array. We can then sort our dictionary by values, descending order to get which elements have the highest frequency, and return the first k from the sorted dictionary.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">add</span> <span class="n">to</span> <span class="n">hashTable</span> <span class="k">if</span> <span class="n">it</span> <span class="n">doesnt</span> <span class="n">already</span> <span class="n">exist</span>
    <span class="k">if</span> <span class="n">it</span> <span class="n">does</span> <span class="n">exist</span><span class="p">,</span> <span class="n">append</span> <span class="n">its</span> <span class="n">frequency</span> <span class="n">by</span> <span class="mi">1</span>

<span class="bp">sort</span> <span class="n">hashTable</span> <span class="n">by</span> <span class="n">values</span><span class="p">,</span> <span class="n">descending</span> <span class="n">order</span>

<span class="k">for</span> <span class="n">indexed</span> <span class="n">loop</span> <span class="k">in</span> <span class="mi">1</span> <span class="p">-&gt;</span> <span class="n">k</span>
    <span class="kr">get</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="n">key</span><span class="p">,</span> <span class="n">and</span> <span class="n">add</span> <span class="n">to</span> <span class="k">return</span> <span class="n">array</span>
    
<span class="k">return</span> <span class="n">returnArray</span>
</div></code></pre><p>The tricky thing here is to make sure you are sorting properly. We want to sort the hashTable, but after sorting we only care about the keys in the hash-table, so it might be more intelligent to leverage the swift built in higher order functions on arrays to get the data structure we want.</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span>
<span class="kd">var</span> <span class="nv">returnVal</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]()</span>

<span class="k">for</span> <span class="n">num</span> <span class="k">in</span> <span class="n">nums</span> <span class="p">{</span>
    <span class="n">hashTable</span><span class="p">[</span><span class="n">num</span><span class="p">,</span> <span class="k">default</span><span class="p">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// add these values to a hashTable, and append the existing number if it exists</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">sorted</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">hashTable</span><span class="p">.</span><span class="bp">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="nv">$1</span><span class="p">.</span><span class="n">value</span> <span class="p">})</span> <span class="c1">// sort our hashTable by value.</span>
                <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">key</span> <span class="p">})</span> <span class="c1">//  But then put the (now sorted) keys into an array for easier access</span>

<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.&lt;</span><span class="n">k</span> <span class="p">{</span> <span class="c1">// loop through K times to get the top K elements from the sorted data structure</span>
    <span class="n">returnVal</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">sorted</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">returnVal</span>
</div></code></pre><p>The time complexity here is (n + uLogu + u + k) Where K is our input variable k, and n is the size of the input array, and u is the number of unique numbers. We go through the input array once (n), we sort the hashTable (guaranteed to only have u elements -&gt; uLogu), we add the unique elements into an array (u) and loop to find the top k elements (k). This mathematically simplifies to 2uLogu + n + k -&gt; which translates to uLogu on average.</p><p>The space complexity is O(2u) where u is the number of unique elements in the input array. Our HashTable will only ever be u size, because all keys must be unique in a hashTable. and our array of sorted keys will only ever be u size because of the same reason as before. That is 2 separate u space data structures that on average equal out to 2u.</p><p>Well done! Just be careful when it comes to Swift sorting üòÉ</p><hr><h1>Container With Most Water</h1><p>This is a tricky problem, especially in the iOS world.</p><img src="/continerwithmostwater.png"/><p>On initial thinking we see this has a math component. The good news about programming problems with math components is, the math is never more than basic algebra. It's all about having strong problem solving skills</p><h3>Brute Force</h3><p>The brute force solution to this problem seems obvious at first. We need to find the largest area between two points. By having some nested loops, we can calculate all possible areas for all values.</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">track</span> <span class="n">of</span> <span class="n">maximum</span>
<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">inner</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="n">calculate</span> <span class="n">area</span>
        <span class="n">update</span> <span class="n">maximum</span> <span class="k">as</span> <span class="n">necessary</span>
</div></code></pre><p>The time complexity here is O(n¬≤) due to the nested nature of the loops. Calculating area, and keeping track of a maximum are both O(1) operations. The space complexity is also constant because we are just storing the return value in a single variable, that does not expand.</p><h3>Approach</h3><h3>[ 2 pointers ]</h3><h3>[ O(n) time + O(1) space ]</h3><p>By using 2 pointers we can more effectively find the maximum area within a set of data points. We essentially need to find the 2 values that are the furthest apart, with one of the values being as maximum as possible. By keeping a left and right pointer and the beginning and end of our array, we can iteratively move the pointers inward based on which value is smaller. That way we can keep our maximum of the 2 values.</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">a</span> <span class="kr">left</span> <span class="o">&amp;</span> <span class="kr">right</span> <span class="n">pointer</span>
<span class="n">keep</span> <span class="n">a</span> <span class="n">maximum</span> <span class="n">array</span> <span class="n">variable</span>

<span class="k">while</span> <span class="kr">left</span> <span class="n">pointer</span> <span class="o">&lt;</span> <span class="kr">right</span> <span class="n">pointer</span> 
    <span class="bp">find</span> <span class="n">area</span>
    <span class="n">update</span> <span class="n">area</span> <span class="k">as</span> <span class="n">needed</span>
    <span class="n">move</span> <span class="n">either</span> <span class="kr">left</span> <span class="n">or</span> <span class="kr">right</span> <span class="n">pointer</span> <span class="n">inward</span> <span class="p">(</span><span class="n">whichever</span> <span class="k">is</span> <span class="n">smaller</span><span class="p">)</span>
</div></code></pre><p>The time complexity here is O(1/2n) which translates to O(n) on average. This is because we will on average gravitate towards the middle of our array with our pointers. It is guaranteed we will never move greater than the length of the array. The space complexity is O(1) because we only have 3 constant variables, the area &amp; the left + right pointers.</p><p>We should think how to find the area at each iteration. This can be found of width ** height. The height is the smaller of the 2 values because the problem description says we cannot tip our container. And the width is the distance between the 2 pointers aka rightPointer - leftPointer.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">height</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span> <span class="c1">// edge cases </span>
<span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rightPointer</span> <span class="p">=</span> <span class="n">height</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">area</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// setup our pointers</span>

<span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;</span> <span class="n">rightPointer</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">leftValue</span> <span class="p">=</span> <span class="n">height</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span>
    <span class="kd">let</span> <span class="nv">rightValue</span> <span class="p">=</span> <span class="n">height</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span>
    <span class="kd">let</span> <span class="nv">iterativeArea</span> <span class="p">=</span> <span class="p">(</span><span class="n">rightPointer</span> <span class="o">-</span> <span class="n">leftPointer</span><span class="p">)</span> <span class="o">*</span> <span class="bp">min</span><span class="p">(</span><span class="n">leftValue</span><span class="p">,</span> <span class="n">rightValue</span><span class="p">)</span> <span class="c1">// find our area at this cycle in our loop</span>
    
    <span class="n">area</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">iterativeArea</span><span class="p">)</span> <span class="c1">// update our area value as needed</span>
    
    <span class="k">if</span> <span class="n">leftValue</span> <span class="o">&lt;</span> <span class="n">rightValue</span> <span class="p">{</span> <span class="c1">// left value is smaller, move left pointer in</span>
        <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">leftValue</span> <span class="o">&gt;</span> <span class="n">rightValue</span> <span class="p">{</span> <span class="c1">// right value is smaller, move right pointer in</span>
        <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// values are equal, move both pointers</span>
        <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">area</span>
</div></code></pre><hr><h1>Conclusion</h1><p>When facing array problems, try to keep in mind some of these tricks we learned in these problems. You will start to find programming problems follow similar patterns! Happy Coding!</p><hr></article></main><div class="flex flex-wrap w-full items-center font-sans p-8 md:p-24"><div class="md:flex-1 flex"><img class="w-10 h-10 rounded-full mr-4" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><div class="flex-1"><p class="text-base font-bold text-base md:text-xl leading-none">Alex Stevens</p><p class="text-gray-600 text-xs md:text-base">iOS Software Engineer</p></div></div><div class="mt-8 md:mt-0 mx-auto md:mx-0 md:justify-end"><a class="bg-transparent border border-gray-500 hover:border-casper-blue text-xs text-gray-500 hover:text-casper-blue font-bold py-2 px-4 rounded-full" href="/tags">All tags</a></div></div></div></div><div class="bg-gray-200"><div class="container w-full max-w-6xl mx-auto px-2 py-8"><div class="grid grid-cols-1 sm:grid-cols-3 gap-12"><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/leetcode/blind-75-sliding-window" class="flex flex-wrap no-underline hover:no-underline"><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">LEETCODE</p><div class="w-full font-bold text-2xl text-gray-900 px-6">Blind 75: Sliding Window Problems</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">Getting crazy with arrays!</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><p class="text-gray-600 text-xs md:text-sm">15 MIN READ</p></div></div></div><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/leetcode/how-to-solve-a-leetcode-problem" class="flex flex-wrap no-underline hover:no-underline"><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">LEETCODE</p><div class="w-full font-bold text-2xl text-gray-900 px-6">How to solve a Leetcode problem</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">Leetcode. The bane of many a programmer</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><p class="text-gray-600 text-xs md:text-sm">1 MIN READ</p></div></div></div><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/leetcode/blind-75-stack" class="flex flex-wrap no-underline hover:no-underline"><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">LEETCODE</p><div class="w-full font-bold text-2xl text-gray-900 px-6">Blind 75: Stacks</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">A short introduction into Stacks</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><p class="text-gray-600 text-xs md:text-sm">4 MIN READ</p></div></div></div></div></div></div><footer class="bg-gray-900"><div class="container max-w-6xl mx-auto flex items-center px-2 pt-2 pb-8"><div class="w-full mx-auto flex flex-wrap items-center"><div class="flex w-full md:w-1/2 justify-center md:justify-start text-white font-extrabold"><p><a class="text-gray-900 no-underline hover:text-gray-900 hover:no-underline" href="#"><span class="text-base text-gray-200">Swift Refresher</span></a></p></div><div class="flex w-full pt-2 content-center justify-between md:w-1/2 md:justify-end"><ul class="list-reset flex justify-center flex-1 md:flex-none items-center"><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="/">Latest Posts</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="https://github.com/JohnSundell/Publish">Publish</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="https://ghost.org">Ghost</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline px-3 text-sm" href="/feed.rss"><svg class="fill-current h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"></circle><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"></path></svg></a></li></ul></div></div></div></footer></body></html>