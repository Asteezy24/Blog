<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Swift Refresher"/><link rel="canonical" href="https://swiftrefresher.com/leetcode/sliding-window"/><meta name="twitter:url" content="https://swiftrefresher.com/leetcode/sliding-window"/><meta name="og:url" content="https://swiftrefresher.com/leetcode/sliding-window"/><title>Sliding Window Problems | Swift Refresher</title><meta name="twitter:title" content="Sliding Window Problems | Swift Refresher"/><meta name="og:title" content="Sliding Window Problems | Swift Refresher"/><meta name="description" content="Getting crazy with arrays!"/><meta name="twitter:description" content="Getting crazy with arrays!"/><meta name="og:description" content="Getting crazy with arrays!"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Swift Refresher"/></head><body class="bg-white font-sans leading-normal tracking-normal"><div class="pb-16"><nav class="fixed z-10 bg-gray-900 p-4 mt-0 w-full overflow-auto scrolling-touch"><div class="container mx-auto flex items-center"><div class="flex-shrink-0 text-white font-extrabold"><a class="flex text-white text-base no-underline hover:text-white hover:no-underline" href="/"><span class="block md:hidden md:w-auto pl-1">üèù</span><span class="hidden md:block w-0 md:w-auto pl-1">Swift Refresher</span></a></div><div class=" flex flex-no-wrap pl-4 text-sm"><ul class="list-reset flex justify-between items-center"><li class="mr-2"><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2" href="/">HOME</a></li><li><a class="inline-block py-2 px-2 text-white no-underline hover:underline whitespace-no-wrap" href="/leetcode">LEETCODE</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/SwiftUI">SWIFTUI</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/combine">COMBINE</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/swift">SWIFT</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/about">ABOUT</a></li></ul></div></div></nav></div><div class="text-center pt-16 md:pt-32"><p class="text-xs md:text-sm text-casper-blue font-bold">19 JULY 2022<span class="text-gray-900 px-1">/</span><a href="/tags/leetcode">LEETCODE</a></p><h1 class="font-bold break-normal text-3xl md:text-5xl max-w-6xl mx-auto">Sliding Window Problems</h1></div><div class="container max-w-5xl mx-auto "><div class="mx-0 sm:mx-6"><main class="bg-white w-full p-8 md:p-24 text-gray-800 leading-normal"><article class="prose prose-sm sm:prose-xl break-words"><h1>Best Time to Buy and Sell Stock</h1><p>This is a good strategy for iterating on array problems. Let's build the foundation!</p><img src="/besttimebuysellstock.png"/><p>This is a very straightforward problem with real world application. Lets take it step by step.</p><h3>Brute Force</h3><p>A brute force solution here is obvious, let's go through each element in the array, and iterate every combination of elements to find the maximum profit.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">currentMaxProfit</span> <span class="o">&gt;</span> <span class="bp">max</span> <span class="n">profit</span> <span class="n">AND</span> <span class="n">currentMaxProfit</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="bp">max</span> <span class="n">profit</span> <span class="p">=</span> <span class="n">currentMaxProfit</span>
            
<span class="k">return</span> <span class="bp">max</span> <span class="n">profit</span> 
</div></code></pre><p>This is a very inefficient solution, with the time constraint being O(n¬≤). We at least have consistent space because we only hold a variable for the max profit. There is a better way of going about this problem though.<br><br>For this problem, we should approach using the sliding window methodology.</p><h3>[ Sliding Window ]</h3><h3>[ O(n) worst time + O(1) space ]</h3><p>The sliding window is when we have 2 pointers representing a window range, and we either move the start of the window, or expand the window based on the criteria we are looking for. In this specific problem, we have 2 criteria:</p><ol><li>Move the first index (start of the window) when the end of the window is greater than the beginning of the window. In this scenario our profit would be negative so we need to reset our search.</li><li>Expand our window when we have the criteria for a possible max profit.</li></ol><p>Pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">while</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">the</span> <span class="n">window</span> <span class="k">is</span> <span class="n">within</span> <span class="n">the</span> <span class="n">bounds</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
    <span class="k">if</span> <span class="n">we</span> <span class="n">can</span> <span class="n">have</span> <span class="n">a</span> <span class="bp">max</span> <span class="n">profit</span>
        <span class="n">maxProfit</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="bp">max</span> <span class="n">profit</span><span class="p">,</span> <span class="n">current</span> <span class="n">profit</span><span class="p">)</span>
    <span class="k">else</span> 
        <span class="n">reset</span> <span class="n">beginning</span> <span class="n">of</span> <span class="n">window</span>
    <span class="n">end</span> <span class="n">of</span> <span class="n">window</span> <span class="n">append</span> <span class="n">by</span> <span class="mi">1</span>
</div></code></pre><p>At worst here we get, O(n) time performance. This is if we cannot have a viable maximum profit in the entire array. Space is still consistent, due to the various array pointers.</p><p>Let's go into implementation now.</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for cases we cannot create a window.</span>
<span class="k">guard</span> <span class="n">prices</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nv">maxProf</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// start max profit at zero</span>
<span class="kd">var</span> <span class="nv">start</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// beginning of window pointer</span>
<span class="kd">var</span> <span class="nv">end</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// end of window pointer</span>

<span class="k">while</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span> <span class="c1">// while the end of the window is within the bounds of the array</span>
    <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// if the first number is less than second and we have a possible profit</span>
        <span class="n">maxProf</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">maxProf</span><span class="p">,</span> <span class="n">prices</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">start</span><span class="p">])</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">start</span> <span class="p">=</span> <span class="n">end</span> <span class="c1">// reset window</span>
    <span class="p">}</span>
    <span class="n">end</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// move end of window always</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">maxProf</span>
</div></code></pre><p>Beautiful. This will be instrumental in future problems.</p><hr><h1>Longest Substring Without Repeating Characters</h1><p>Time to turn the heat on a little bit! This sliding window is a little different than before.</p><img src="/longestsubstringwithoutrepeatchars.png"/><h3>Brute Force</h3><p>As with most array problems, if we use some nested loops to find our condition, we will arrive at the answer (albeit with extreme inefficiency).</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">we</span> <span class="n">have</span> <span class="n">not</span> <span class="n">seen</span> <span class="n">inner</span> <span class="n">letter</span> <span class="n">yet</span> <span class="k">in</span> <span class="n">this</span> <span class="n">iteration</span>
            <span class="n">add</span> <span class="n">to</span> <span class="n">our</span> <span class="n">iterative</span> <span class="bp">count</span>
            <span class="n">update</span> <span class="n">longest</span> <span class="k">if</span> <span class="n">possible</span>
        <span class="k">else</span>
            <span class="k">break</span>
            
<span class="k">return</span> <span class="n">longest</span> <span class="n">substring</span> <span class="n">char</span> <span class="bp">count</span> 
</div></code></pre><p>This solution is built on us keeping track of our current longest substring at any given iteration in the array. If we add to our current iterative substring count, we need to update our global variable as well. The condition for us to reset our search is if we find a character we have seen before.</p><p>Time complexity is O(n¬≥) due to our nested loops and substring checking. Depending on our preferred method of searching for past letters, if we use a hash table, this search is consistent O(1). Space complexity is O(n) because we need a data structure that expands for the letters we have previously seen. HashTable space complexity is O(n) where n is the number of unique characters (at worst).</p><h3>[ Sliding Window ]</h3><h3>[ O(n¬≤) worst time + O(n) space ]</h3><p>You guessed it! We have another sliding window problem. This time we need to be really careful with our 2 window conditions. Our 2 conditions are: expanding our window or reset the front of our window. The question is, what causes these conditions AND how specifically do we reset &amp; expand our window.</p><p>In our case, we know we need to expand our window when we have not seen a letter before (this includes the front of our window). To expand we can just move the end of our window by 1.</p><p>Otherwise we reset our window. BUT resetting our window only means we move the front by one. We need to ensure we do not skip any letter combinations.</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">a</span> <span class="n">hashtable</span> <span class="n">with</span> <span class="n">seen</span> <span class="n">letters</span>

<span class="k">while</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">our</span> <span class="n">window</span> <span class="k">is</span> <span class="k">in</span> <span class="n">bounds</span>
    <span class="k">if</span> <span class="n">we</span> <span class="n">have</span> <span class="n">not</span> <span class="n">seen</span> <span class="n">the</span> <span class="n">end</span> <span class="n">letter</span> <span class="n">before</span>
        <span class="c1">// expand</span>
        <span class="n">move</span> <span class="n">end</span> <span class="n">variable</span>
        <span class="n">update</span> <span class="n">global</span> <span class="n">variable</span>
        <span class="n">update</span> <span class="n">hashtable</span>
    <span class="k">else</span>
        <span class="c1">// reset window</span>
        <span class="n">move</span> <span class="n">start</span> <span class="n">of</span> <span class="n">window</span> <span class="mi">1</span> <span class="n">place</span>
        <span class="n">move</span> <span class="n">end</span> <span class="n">to</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">reset</span> <span class="n">hashtable</span>
        
<span class="k">return</span> <span class="n">global</span> <span class="n">variable</span>
        
</div></code></pre><p>Time complexity here is O(n¬≤) at worst. This occurs when we have all unique characters in our string. Our loop will essentially check every combination of substrings in this case. Space complexity is O(n) due to the expansion of the hashtable. N is representative of unique characters in our string.</p><p>Time to implement!</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span> <span class="c1">// edge case check</span>
<span class="kd">var</span> <span class="nv">longest</span> <span class="p">=</span> <span class="mi">1</span>
<span class="kd">var</span> <span class="nv">start</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// window start</span>
<span class="kd">var</span> <span class="nv">end</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// window end</span>

<span class="kd">let</span> <span class="nv">letters</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1">// swift optimization</span>

<span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="n">letters</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="p">:</span> <span class="kc">true</span><span class="p">]</span> <span class="c1">// HashTable with 1st letter </span>

<span class="k">while</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span> <span class="p">{</span> <span class="c1">// While in bounds</span>
    <span class="kd">let</span> <span class="nv">startLetter</span> <span class="p">=</span> <span class="n">letters</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="kd">let</span> <span class="nv">endLetter</span> <span class="p">=</span> <span class="n">letters</span><span class="p">[</span><span class="n">end</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// expand window</span>
        <span class="n">end</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">longest</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">longest</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="c1">// update longest if possible</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span> <span class="c1">// add to hashTable</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// reset window start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// move start</span>
        <span class="n">end</span> <span class="p">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// reset end</span>
        <span class="n">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="n">letters</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="p">:</span> <span class="kc">true</span><span class="p">]</span> <span class="c1">// reset hash</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">longest</span>
</div></code></pre><p>Well done!</p><hr></article></main><div class="flex flex-wrap w-full items-center font-sans p-8 md:p-24"><div class="md:flex-1 flex"><img class="w-10 h-10 rounded-full mr-4" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><div class="flex-1"><p class="text-base font-bold text-base md:text-xl leading-none">Alex Stevens</p><p class="text-gray-600 text-xs md:text-base">iOS Software Engineer</p></div></div><div class="mt-8 md:mt-0 mx-auto md:mx-0 md:justify-end"><a class="bg-transparent border border-gray-500 hover:border-casper-blue text-xs text-gray-500 hover:text-casper-blue font-bold py-2 px-4 rounded-full" href="/tags">All tags</a></div></div></div></div><div class="bg-gray-200"><div class="container w-full max-w-6xl mx-auto px-2 py-8"><div class="grid grid-cols-1 sm:grid-cols-3 gap-12"><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/leetcode/blind-75-arrays" class="flex flex-wrap no-underline hover:no-underline"><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">LEETCODE</p><div class="w-full font-bold text-2xl text-gray-900 px-6">Blind 75: Arrays + Hashing + 2 pointers</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">Arrays + Leetcode = Match made in heaven</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><p class="text-gray-600 text-xs md:text-sm">37 MIN READ</p></div></div></div><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/leetcode/how-to-solve-a-leetcode-problem" class="flex flex-wrap no-underline hover:no-underline"><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">LEETCODE</p><div class="w-full font-bold text-2xl text-gray-900 px-6">How to solve a Leetcode problem</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">Leetcode. The bane of many a programmer</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><p class="text-gray-600 text-xs md:text-sm">1 MIN READ</p></div></div></div></div></div></div><footer class="bg-gray-900"><div class="container max-w-6xl mx-auto flex items-center px-2 pt-2 pb-8"><div class="w-full mx-auto flex flex-wrap items-center"><div class="flex w-full md:w-1/2 justify-center md:justify-start text-white font-extrabold"><p><a class="text-gray-900 no-underline hover:text-gray-900 hover:no-underline" href="#"><span class="text-base text-gray-200">Swift Refresher</span></a></p></div><div class="flex w-full pt-2 content-center justify-between md:w-1/2 md:justify-end"><ul class="list-reset flex justify-center flex-1 md:flex-none items-center"><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="/">Latest Posts</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="https://github.com/JohnSundell/Publish">Publish</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="https://ghost.org">Ghost</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline px-3 text-sm" href="/feed.rss"><svg class="fill-current h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"></circle><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"></path></svg></a></li></ul></div></div></div></footer></body></html>