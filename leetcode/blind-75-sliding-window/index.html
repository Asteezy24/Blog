<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Swift Refresher"/><link rel="canonical" href="https://swiftrefresher.com/leetcode/blind-75-sliding-window"/><meta name="twitter:url" content="https://swiftrefresher.com/leetcode/blind-75-sliding-window"/><meta name="og:url" content="https://swiftrefresher.com/leetcode/blind-75-sliding-window"/><title>Blind 75: Sliding Window Problems | Swift Refresher</title><meta name="twitter:title" content="Blind 75: Sliding Window Problems | Swift Refresher"/><meta name="og:title" content="Blind 75: Sliding Window Problems | Swift Refresher"/><meta name="description" content="Getting crazy with arrays!"/><meta name="twitter:description" content="Getting crazy with arrays!"/><meta name="og:description" content="Getting crazy with arrays!"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Swift Refresher"/></head><body class="bg-white font-sans leading-normal tracking-normal"><div class="pb-16"><nav class="fixed z-10 bg-gray-900 p-4 mt-0 w-full overflow-auto scrolling-touch"><div class="container mx-auto flex items-center"><div class="flex-shrink-0 text-white font-extrabold"><a class="flex text-white text-base no-underline hover:text-white hover:no-underline" href="/"><span class="block md:hidden md:w-auto pl-1">üèù</span><span class="hidden md:block w-0 md:w-auto pl-1">Swift Refresher</span></a></div><div class=" flex flex-no-wrap pl-4 text-sm"><ul class="list-reset flex justify-between items-center"><li class="mr-2"><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2" href="/">HOME</a></li><li><a class="inline-block py-2 px-2 text-white no-underline hover:underline whitespace-no-wrap" href="/leetcode">LEETCODE</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/SwiftUI">SWIFTUI</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/combine">COMBINE</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/swift">SWIFT</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2 whitespace-no-wrap" href="/about">ABOUT</a></li></ul></div></div></nav></div><div class="text-center pt-16 md:pt-32"><p class="text-xs md:text-sm text-casper-blue font-bold">19 JULY 2022<span class="text-gray-900 px-1">/</span><a href="/tags/leetcode">LEETCODE</a></p><h1 class="font-bold break-normal text-3xl md:text-5xl max-w-6xl mx-auto">Blind 75: Sliding Window Problems</h1></div><div class="container max-w-5xl mx-auto "><div class="mx-0 sm:mx-6"><main class="bg-white w-full p-8 md:p-24 text-gray-800 leading-normal"><article class="prose prose-sm sm:prose-xl break-words"><h1>Best Time to Buy and Sell Stock</h1><p>This is a good strategy for iterating on array problems. Let's build the foundation!</p><img src="/besttimebuysellstock.png"/><p>This is a very straightforward problem with real world application. Lets take it step by step.</p><h3>Brute Force</h3><p>A brute force solution here is obvious, let's go through each element in the array, and iterate every combination of elements to find the maximum profit.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">currentMaxProfit</span> <span class="o">&gt;</span> <span class="bp">max</span> <span class="n">profit</span> <span class="n">AND</span> <span class="n">currentMaxProfit</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="bp">max</span> <span class="n">profit</span> <span class="p">=</span> <span class="n">currentMaxProfit</span>
            
<span class="k">return</span> <span class="bp">max</span> <span class="n">profit</span> 
</div></code></pre><p>This is a very inefficient solution, with the time constraint being O(n¬≤). We at least have consistent space because we only hold a variable for the max profit. There is a better way of going about this problem though.<br><br>For this problem, we should approach using the sliding window methodology.</p><h3>[ Sliding Window ]</h3><h3>[ O(n) worst time + O(1) space ]</h3><p>The sliding window is when we have 2 pointers representing a window range, and we either move the start of the window, or expand the window based on the criteria we are looking for. In this specific problem, we have 2 criteria:</p><ol><li>Move the first index (start of the window) when the end of the window is greater than the beginning of the window. In this scenario our profit would be negative so we need to reset our search.</li><li>Expand our window when we have the criteria for a possible max profit.</li></ol><p>Pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">while</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">the</span> <span class="n">window</span> <span class="k">is</span> <span class="n">within</span> <span class="n">the</span> <span class="n">bounds</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
    <span class="k">if</span> <span class="n">we</span> <span class="n">can</span> <span class="n">have</span> <span class="n">a</span> <span class="bp">max</span> <span class="n">profit</span>
        <span class="n">maxProfit</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="bp">max</span> <span class="n">profit</span><span class="p">,</span> <span class="n">current</span> <span class="n">profit</span><span class="p">)</span>
    <span class="k">else</span> 
        <span class="n">reset</span> <span class="n">beginning</span> <span class="n">of</span> <span class="n">window</span>
    <span class="n">end</span> <span class="n">of</span> <span class="n">window</span> <span class="n">append</span> <span class="n">by</span> <span class="mi">1</span>
</div></code></pre><p>At worst here we get, O(n) time performance. This is if we cannot have a viable maximum profit in the entire array. Space is still consistent, due to the various array pointers.</p><p>Let's go into implementation now.</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for cases we cannot create a window.</span>
<span class="k">guard</span> <span class="n">prices</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nv">maxProf</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// start max profit at zero</span>
<span class="kd">var</span> <span class="nv">start</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// beginning of window pointer</span>
<span class="kd">var</span> <span class="nv">end</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// end of window pointer</span>

<span class="k">while</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span> <span class="c1">// while the end of the window is within the bounds of the array</span>
    <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// if the first number is less than second and we have a possible profit</span>
        <span class="n">maxProf</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">maxProf</span><span class="p">,</span> <span class="n">prices</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">start</span><span class="p">])</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">start</span> <span class="p">=</span> <span class="n">end</span> <span class="c1">// reset window</span>
    <span class="p">}</span>
    <span class="n">end</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// move end of window always</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">maxProf</span>
</div></code></pre><p>Beautiful. This will be instrumental in future problems.</p><hr><h1>Longest Substring Without Repeating Characters</h1><p>Time to turn the heat on a little bit! This sliding window is a little different than before.</p><img src="/longestsubstringwithoutrepeatchars.png"/><h3>Brute Force</h3><p>As with most array problems, if we use some nested loops to find our condition, we will arrive at the answer (albeit with extreme inefficiency).</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">we</span> <span class="n">have</span> <span class="n">not</span> <span class="n">seen</span> <span class="n">inner</span> <span class="n">letter</span> <span class="n">yet</span> <span class="k">in</span> <span class="n">this</span> <span class="n">iteration</span>
            <span class="n">add</span> <span class="n">to</span> <span class="n">our</span> <span class="n">iterative</span> <span class="bp">count</span>
            <span class="n">update</span> <span class="n">longest</span> <span class="k">if</span> <span class="n">possible</span>
        <span class="k">else</span>
            <span class="k">break</span>
            
<span class="k">return</span> <span class="n">longest</span> <span class="n">substring</span> <span class="n">char</span> <span class="bp">count</span> 
</div></code></pre><p>This solution is built on us keeping track of our current longest substring at any given iteration in the array. If we add to our current iterative substring count, we need to update our global variable as well. The condition for us to reset our search is if we find a character we have seen before.</p><p>Time complexity is O(n¬≥) due to our nested loops and substring checking. Depending on our preferred method of searching for past letters, if we use a hash table, this search is consistent O(1). Space complexity is O(n) because we need a data structure that expands for the letters we have previously seen. HashTable space complexity is O(n) where n is the number of unique characters (at worst).</p><h3>[ Sliding Window ]</h3><h3>[ O(n¬≤) worst time + O(n) space ]</h3><p>You guessed it! We have another sliding window problem. This time we need to be really careful with our 2 window conditions. Our 2 conditions are: expanding our window or reset the front of our window. The question is, what causes these conditions AND how specifically do we reset &amp; expand our window.</p><p>In our case, we know we need to expand our window when we have not seen a letter before (this includes the front of our window). To expand we can just move the end of our window by 1.</p><p>Otherwise we reset our window. BUT resetting our window only means we move the front by one. We need to ensure we do not skip any letter combinations.</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">a</span> <span class="n">hashtable</span> <span class="n">with</span> <span class="n">seen</span> <span class="n">letters</span>

<span class="k">while</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">our</span> <span class="n">window</span> <span class="k">is</span> <span class="k">in</span> <span class="n">bounds</span>
    <span class="k">if</span> <span class="n">we</span> <span class="n">have</span> <span class="n">not</span> <span class="n">seen</span> <span class="n">the</span> <span class="n">end</span> <span class="n">letter</span> <span class="n">before</span>
        <span class="c1">// expand</span>
        <span class="n">move</span> <span class="n">end</span> <span class="n">variable</span>
        <span class="n">update</span> <span class="n">global</span> <span class="n">variable</span>
        <span class="n">update</span> <span class="n">hashtable</span>
    <span class="k">else</span>
        <span class="c1">// reset window</span>
        <span class="n">move</span> <span class="n">start</span> <span class="n">of</span> <span class="n">window</span> <span class="mi">1</span> <span class="n">place</span>
        <span class="n">move</span> <span class="n">end</span> <span class="n">to</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">reset</span> <span class="n">hashtable</span>
        
<span class="k">return</span> <span class="n">global</span> <span class="n">variable</span>
        
</div></code></pre><p>Time complexity here is O(n¬≤) at worst. This occurs when we have all unique characters in our string. Our loop will essentially check every combination of substrings in this case. Space complexity is O(n) due to the expansion of the hashtable. N is representative of unique characters in our string.</p><p>Time to implement!</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span> <span class="c1">// edge case check</span>
<span class="kd">var</span> <span class="nv">longest</span> <span class="p">=</span> <span class="mi">1</span>
<span class="kd">var</span> <span class="nv">start</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// window start</span>
<span class="kd">var</span> <span class="nv">end</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// window end</span>

<span class="kd">let</span> <span class="nv">letters</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1">// swift optimization</span>

<span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="n">letters</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="p">:</span> <span class="kc">true</span><span class="p">]</span> <span class="c1">// HashTable with 1st letter </span>

<span class="k">while</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span> <span class="p">{</span> <span class="c1">// While in bounds</span>
    <span class="kd">let</span> <span class="nv">startLetter</span> <span class="p">=</span> <span class="n">letters</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="kd">let</span> <span class="nv">endLetter</span> <span class="p">=</span> <span class="n">letters</span><span class="p">[</span><span class="n">end</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// expand window</span>
        <span class="n">end</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">longest</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">longest</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="c1">// update longest if possible</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span> <span class="c1">// add to hashTable</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// reset window start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// move start</span>
        <span class="n">end</span> <span class="p">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// reset end</span>
        <span class="n">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="n">letters</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="p">:</span> <span class="kc">true</span><span class="p">]</span> <span class="c1">// reset hash</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">longest</span>
</div></code></pre><p>Well done!</p><hr><h1>Longest Repeating Character Replacement</h1><p>This is a particularly unique sliding window problem. I personally struggled with this one. Let's dive in.</p><img src="/longestrepeatingcharacterreplacement.png"/><h3>Brute Force</h3><p>There are a couple factors at play here. First off, we can check every substring available in the input string by using nested for loops. But as we check each substring what exactly are we looking for? In a given substring, we need to see if the number of letters we need to replace is less than our input K. And we know we need to replace all characters that are not equal to the most frequent character in a given substring.</p><p>Let's say for example we have a substring "ABAA" and K=2. We know that A is the most frequent letter, so every instance of a letter that isn't A needs replaced. So we can search the substring for all non-A letters and as long as that number is less than or equal to K, its a valid substring. It would look something like this</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">every</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">S</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">remaining</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">S</span>
        <span class="bp">find</span> <span class="bp">count</span> <span class="n">of</span> <span class="n">most</span> <span class="n">frequent</span> <span class="n">character</span>
        <span class="bp">count</span> <span class="n">of</span> <span class="n">everything</span> <span class="k">else</span> <span class="p">=</span> <span class="n">substring</span> <span class="n">length</span> <span class="o">-</span> <span class="n">most</span> <span class="n">frequent</span> 
        <span class="k">if</span> <span class="bp">count</span> <span class="n">of</span> <span class="n">everything</span> <span class="k">else</span> <span class="o">&lt;=</span> <span class="n">K</span>
            <span class="k">continue</span> <span class="n">inner</span> <span class="n">loop</span>
        <span class="k">else</span> 
            <span class="k">break</span> <span class="n">inner</span> <span class="n">loop</span>
</div></code></pre><p>Pretty darn inefficient right? Let's dive into time and space complexity here. The nested loops alone give us O(n¬≤) time. Within our loops, finding the count of the most frequent letter is another search through our substring is another O(n) time. Total this gives us O(n¬≥). Yikes. The space complexity is at worst O(n) where n is the length of the S input string. This is because we can never have to search a substring longer than the input string.</p><h3>[ Sliding Window + HashTable ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>So for efficiency sake here, we can speed a few things up. First off the searching a substring can be expedited with a HashTable. We can keep track of the counts for any given substring at all times, and have consistent time searching for each character count. We can also keep a global variable representing the most frequent character count.</p><p>For the nested loops, we can use a sliding window instead to massively decrease our algorithm time. If we have a valid substring, we can keep expanding our window to the right. If we do not have a valid substring, we need to shrink our window from the left (Move the start pointer forward). Here is the pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">string</span>
    <span class="n">add</span> <span class="n">to</span> <span class="n">hashTable</span>
    <span class="n">update</span> <span class="n">global</span> <span class="bp">max</span> <span class="n">character</span> <span class="n">frequency</span> <span class="n">value</span>
    
    <span class="k">while</span> <span class="n">our</span> <span class="n">substring</span> <span class="k">is</span> <span class="n">invalid</span>
        <span class="n">shrink</span> <span class="n">window</span> <span class="n">from</span> <span class="n">the</span> <span class="n">start</span>
        <span class="n">update</span> <span class="n">HashTable</span> <span class="n">accordingly</span>
        
    <span class="n">update</span> <span class="n">global</span> <span class="n">variable</span> <span class="k">for</span> <span class="n">our</span> <span class="n">result</span>
    
<span class="k">return</span> <span class="n">global</span>
</div></code></pre><p>With this solution, we have at worst O(n) time where n is the length of the input string. This is because the worst that can happen, is we expand our window all the way to the right, have the last letter make the substring invalid, and then shrink our window to the end. This averages out to be O(n) time. Space complexity is O(26N) because we know we are only using capital english letters, there are only 26 of those, so our HashTable storage will never be bigger than 26 Keys. This averages out to O(n) space.</p><p>Let's implement the real solution.</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">charCount</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Character</span><span class="p">:</span> <span class="nb">Int</span><span class="p">]()</span> <span class="c1">// HashTable to keep track of character counts in our substring</span>
<span class="kd">var</span> <span class="nv">maxCharCount</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// Max Character Count, largest in our HashTable at any given moment</span>
<span class="kd">var</span> <span class="nv">result</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// Our return result</span>
<span class="kd">var</span> <span class="nv">start</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// Start of window pointer</span>

<span class="kd">let</span> <span class="nv">sArr</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1">// Easy Char access in Swift</span>

<span class="k">for</span> <span class="n">end</span> <span class="k">in</span> <span class="mi">0</span> <span class="p">..</span><span class="o">&lt;</span> <span class="n">sArr</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span> <span class="c1">// while our end pointer is in bounds</span>
    <span class="kd">var</span> <span class="nv">currentWindowSize</span> <span class="p">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// get our current window size</span>
    <span class="kd">let</span> <span class="nv">endLetter</span> <span class="p">=</span> <span class="n">sArr</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="c1">// end letter</span>
    <span class="kd">var</span> <span class="nv">startLetter</span> <span class="p">=</span> <span class="n">sArr</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="c1">// start letter</span>
    
    <span class="n">charCount</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="p">=</span> <span class="n">charCount</span><span class="p">[</span><span class="n">endLetter</span><span class="p">,</span> <span class="k">default</span><span class="p">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// We have a new end letter, increment its count in the HashTable</span>
    <span class="n">maxCharCount</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">maxCharCount</span><span class="p">,</span> <span class="n">charCount</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span><span class="o">!</span><span class="p">)</span> <span class="c1">// See if the newly added letter, ups the maximum char count in the substring</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">currentWindowSize</span> <span class="o">-</span> <span class="n">maxCharCount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">k</span> <span class="p">{</span> <span class="c1">// If our substring is invalid (Our # of chars we need to change is bigger than we are allowed (K)  )</span>
        <span class="n">charCount</span><span class="p">[</span><span class="n">startLetter</span><span class="p">]</span> <span class="p">=</span> <span class="n">charCount</span><span class="p">[</span><span class="n">startLetter</span><span class="p">]</span><span class="o">!</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// Decrement the start of our window count, as we are shrinking our window</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// Shrink our window forward because string is invalid</span>
        
        <span class="n">currentWindowSize</span> <span class="p">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// Update window size</span>
        <span class="n">startLetter</span> <span class="p">=</span> <span class="n">sArr</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="c1">// Update Start Letter</span>
    <span class="p">}</span>
    <span class="n">result</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">currentWindowSize</span><span class="p">)</span> <span class="c1">// update our global result for the longest substring</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">result</span>
</div></code></pre><p>Sheesh!</p><hr><h1>Minimum Window Substring</h1><p>Ahhh our first Leetcode Hard. No need to fear!</p><img src="/minimumwindowsubstring.png"/><h3>Brute Force</h3><p>So this is definitely a tricky one. It takes some in-depth thinking to even arrive at a brute force solution.</p><p>The idea behind the brute force solution is to keep 2 hash tables. One hash table containing character counts we need for our substring to be considered 'valid', and one hash table containing the character counts of our current sliding window substring. In our example problem where s = "ADOBECODEBANC", and t = "ABC", we know we will have a hash table representing the characters we need, and that hash table will be ['A': 1, 'B': 1, 'C': 1]. When we start our hash table for the character count in our substring will be ['A': 0, 'B': 0, 'C': 0], as we have not seen any of these letters yet.</p><p>Now we slide our window. What makes a substring valid? Well that is if: for every key in our haveHashTable, the character count is ‚â• the corresponding letter count in the needHashTable. For example, in our starting substring of 'A'...our haveHashTable will be ['A': 1, 'B': 0, 'C': 0], but we know that its not a valid substring because the character counts for both 'B' and 'C' are ‚â§ the 'B' and 'C' counts in our needHashTable (the count for each of these is 1). We will continue to slide our window until our substring is valid. What happens when our substring is valid?</p><p>If we have a valid substring, we need to globally record the length, and update our result. Then we will pop from the start of our window, until our substring is no longer valid. The repeated work here, is every time we want to check if a substring is valid, we need to loop through every key in our haveHashTable. Gross!</p><p>It would look something like this:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">S</span>
    <span class="k">if</span> <span class="n">its</span> <span class="n">a</span> <span class="n">character</span> <span class="n">we</span> <span class="n">need</span><span class="p">,</span> <span class="n">update</span> <span class="n">haveHashTable</span>
    
    <span class="k">while</span> <span class="n">substring</span> <span class="k">is</span> <span class="n">valid</span>
        <span class="n">update</span> <span class="n">global</span> <span class="n">minimum</span> <span class="n">variable</span> <span class="k">as</span> <span class="n">applicable</span>
        <span class="n">pop</span> <span class="n">from</span> <span class="n">front</span> <span class="n">of</span> <span class="n">window</span> <span class="p">(</span><span class="n">update</span> <span class="n">haveHashTable</span><span class="p">,</span> <span class="n">and</span> <span class="n">move</span> <span class="n">the</span> <span class="n">start</span> <span class="n">of</span> <span class="n">the</span> <span class="n">window</span> <span class="mi">1</span> <span class="n">place</span> <span class="n">to</span> <span class="n">the</span> <span class="kr">right</span><span class="p">)</span>
        
<span class="k">return</span> <span class="n">minimum</span>
</div></code></pre><p>We know that we have O(n) time by searching through the entire string S, and if we need to go all the way forward, and then pop the front all the way to the back, that still averages out to O(n). We have O(26n) time for seeing if our substring is valid, which on average comes out to O(n) time. This comes out to be O(n¬≤) at worst. Space complexity here is O(2n) because we need 2 hashTables that can be at most 26 Keys long, and on average O(2n) comes out to be O(n) space.</p><p>How can we make this better?</p><h3>[ Sliding Window + HashTables + Global Character Count Variables ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>The idea here is, we know we have repeated work by checking if a substring is valid. So we can tweak our logic a little bit to make this linear time. Let's keep two variables: One for the number of characters we have (the sum of all keys in haveHashTable) and one for the number of characters we need (the sum of all keys in needHashTable). If numberOfCharactersWeHave == numberOfCharactersWeNeed, then we know our substring is valid. For example in the substring 'ADOBEC', our needHashTable will be ['A': 1, 'B': 1, 'C': 1], and our haveHashTable will be ['A': 1, 'B': 1, 'C': 1]. The sum of all values for both of these hashTables = 3. Since 3 == 3, we know our substring is valid.</p><p>BUT, we need to be careful here. We should only update our numberOfCharactersWeHave if we slide the window into a character we actually need, and if the character count for what we have == its count for what we need. Also, when we pop from the start of our window, we should only decrement numberOfCharactersWeHave if the letter is something we need, and the substring is no longer valid (its count for what we have is less than its count for what we need). By doing these 2 things we satisfy our condition from the brute force solution.</p><p>In the brute force solution, we only have a valid substring if the character count in haveHashTable ‚â• the corresponding letter count in the needHashTable. So with our new logic, we only decrement the character count if the count falls below our needHashTable threshold. Conversely, we only increment if our character counts are equal.</p><p>In pseudocode it looks like this:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">S</span>
    <span class="k">if</span> <span class="n">its</span> <span class="n">a</span> <span class="n">character</span> <span class="n">we</span> <span class="n">need</span><span class="p">,</span> <span class="n">update</span> <span class="n">haveHashTable</span>
    <span class="n">update</span> <span class="n">our</span> <span class="n">numberOfCharactersWeHave</span> <span class="n">only</span> <span class="k">if</span> <span class="n">the</span> <span class="n">end</span> <span class="n">letter</span> <span class="k">is</span> <span class="n">something</span> <span class="n">we</span> <span class="n">need</span> <span class="o">&amp;&amp;</span> <span class="n">its</span> <span class="bp">count</span> <span class="k">for</span> <span class="n">what</span> <span class="n">we</span> <span class="n">have</span> <span class="n">equals</span> <span class="n">its</span> <span class="bp">count</span> <span class="k">for</span> <span class="n">what</span> <span class="n">we</span> <span class="n">need</span>
    
    <span class="k">while</span> <span class="n">numberOfCharactersWeHave</span> <span class="n">equals</span> <span class="n">numberOfCharactersWeNeed</span>
        <span class="n">update</span> <span class="n">global</span> <span class="n">minimum</span> <span class="n">variable</span> <span class="k">as</span> <span class="n">applicable</span>
        <span class="n">pop</span> <span class="n">from</span> <span class="kr">left</span> <span class="n">of</span> <span class="n">window</span> <span class="p">(</span> <span class="k">if</span> <span class="n">the</span> <span class="n">character</span> <span class="k">is</span> <span class="k">in</span> <span class="n">our</span> <span class="n">haveHashTable</span> <span class="n">update</span> <span class="n">it</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">the</span> <span class="n">start</span> <span class="n">letter</span> <span class="k">is</span> <span class="n">something</span> <span class="n">we</span> <span class="n">need</span><span class="p">,</span> <span class="n">and</span> <span class="n">the</span> <span class="n">substring</span> <span class="k">is</span> <span class="n">no</span> <span class="n">longer</span> <span class="n">valid</span> <span class="p">(</span><span class="n">its</span> <span class="bp">count</span> <span class="k">for</span> <span class="n">what</span> <span class="n">we</span> <span class="n">have</span> <span class="o">&lt;</span> <span class="n">its</span> <span class="bp">count</span> <span class="k">for</span> <span class="n">what</span> <span class="n">we</span> <span class="n">need</span><span class="p">)</span> <span class="n">decrement</span> <span class="n">numberOfCharactersWeHave</span>
        <span class="n">move</span> <span class="n">start</span> <span class="n">pointer</span> <span class="n">by</span> <span class="mi">1</span>
        
<span class="k">return</span> <span class="n">minimum</span>
</div></code></pre><p>The time complexity here is now liner. We still traverse the string S, but checking if a substring is valid is a consistent operation. We are only checking 2 variables. This means we now have O(n) time. The space complexity still remains O(n) due to the 2 hash tables to store character counts. Let's implement the real thing (and apologies for the extra code and comments, I wanted to make it as clear as possible).</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">inputS</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1">// for easier swift access</span>
<span class="kd">let</span> <span class="nv">inputT</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1">// for easier swift access</span>

<span class="kd">var</span> <span class="nv">haveHash</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Character</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span>
<span class="kd">var</span> <span class="nv">needHash</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Character</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span>

<span class="kd">var</span> <span class="nv">slidingWindowStart</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">var</span> <span class="nv">globalMinSubstringLength</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">.</span><span class="bp">max</span>
<span class="kd">var</span> <span class="nv">globalMinSubstring</span> <span class="p">=</span> <span class="s">&quot;&quot;</span>

<span class="kd">var</span> <span class="nv">numberOfCharactersWeHave</span> <span class="p">=</span> <span class="mi">0</span>

<span class="c1">// set up our hashTable for letters we need</span>
<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">inputS</span> <span class="p">{</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span> <span class="p">}</span>
<span class="c1">// set up our hashTable for letters we need</span>
<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">inputT</span> <span class="p">{</span> <span class="n">needHash</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">=</span> <span class="n">needHash</span><span class="p">[</span><span class="n">letter</span><span class="p">,</span> <span class="k">default</span><span class="p">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nv">numberOfCharactersWeNeed</span> <span class="p">=</span> <span class="n">needHash</span><span class="p">.</span><span class="bp">count</span>

<span class="k">for</span> <span class="p">(</span><span class="n">endLetterIndex</span><span class="p">,</span> <span class="n">endLetter</span><span class="p">)</span> <span class="k">in</span> <span class="n">inputS</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// update haveHash if applicable</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">endLetterCountInHaveHash</span> <span class="p">=</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="p">{</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="p">=</span> <span class="n">endLetterCountInHaveHash</span> <span class="o">+</span> <span class="mi">1</span>  <span class="p">}</span>
    <span class="c1">// see if our have character count can be appended. </span>
    <span class="c1">// that is, the end letter is something we need &amp;&amp; its count for what we have == its count for what we need</span>
    <span class="k">if</span> <span class="n">needHash</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">needHashCount</span> <span class="p">=</span> <span class="n">needHash</span><span class="p">[</span><span class="n">endLetter</span><span class="p">],</span> <span class="kd">let</span> <span class="nv">haveHashCount</span> <span class="p">=</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">endLetter</span><span class="p">],</span> <span class="n">needHashCount</span> <span class="p">==</span> <span class="n">haveHashCount</span> <span class="p">{</span>
        <span class="n">numberOfCharactersWeHave</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="c1">// while we have all the characters we need (the substring is valid)</span>
    <span class="k">while</span> <span class="n">numberOfCharactersWeHave</span> <span class="p">==</span> <span class="n">numberOfCharactersWeNeed</span> <span class="p">{</span>
        <span class="c1">// get length of current substring</span>
        <span class="kd">let</span> <span class="nv">lengthOfCurrentSubstring</span> <span class="p">=</span> <span class="p">(</span><span class="n">endLetterIndex</span> <span class="o">-</span> <span class="n">slidingWindowStart</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1">// update global minimum substring if possible</span>
        <span class="k">if</span> <span class="n">lengthOfCurrentSubstring</span> <span class="o">&lt;</span> <span class="n">globalMinSubstringLength</span> <span class="p">{</span>
            <span class="n">globalMinSubstring</span> <span class="p">=</span> <span class="nb">String</span><span class="p">(</span><span class="n">inputS</span><span class="p">[</span><span class="n">slidingWindowStart</span><span class="p">...</span><span class="n">endLetterIndex</span><span class="p">])</span>
            <span class="n">globalMinSubstringLength</span> <span class="p">=</span> <span class="n">lengthOfCurrentSubstring</span>
        <span class="p">}</span>
        
        <span class="kd">let</span> <span class="nv">startLetter</span> <span class="p">=</span> <span class="n">inputS</span><span class="p">[</span><span class="n">slidingWindowStart</span><span class="p">]</span>
        <span class="c1">// pop from left of window if the character is in our have hash</span>
        <span class="k">if</span> <span class="kd">let</span> <span class="nv">haveHashStartLetterCount</span> <span class="p">=</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">startLetter</span><span class="p">]</span> <span class="p">{</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">startLetter</span><span class="p">]</span> <span class="p">=</span> <span class="n">haveHashStartLetterCount</span> <span class="o">-</span> <span class="mi">1</span>  <span class="p">}</span>
        <span class="c1">// if the start letter is something we need, and the substring is no longer valid (its count for what we have &lt; its count for what we need) update our numberOfCharactersWeHave</span>
        <span class="k">if</span> <span class="kd">let</span> <span class="nv">needHashStartLetterCount</span> <span class="p">=</span> <span class="n">needHash</span><span class="p">[</span><span class="n">startLetter</span><span class="p">],</span> <span class="kd">let</span> <span class="nv">haveHashStartLetterCount</span> <span class="p">=</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">startLetter</span><span class="p">],</span> <span class="n">haveHashStartLetterCount</span> <span class="o">&lt;</span> <span class="n">needHashStartLetterCount</span> <span class="p">{</span> <span class="n">numberOfCharactersWeHave</span> <span class="o">-=</span> <span class="mi">1</span> <span class="p">}</span>
        <span class="c1">// move left window pointer</span>
        <span class="n">slidingWindowStart</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">globalMinSubstring</span>
</div></code></pre><hr><h1>Conclusion</h1><p>Sliding window problems can come in all shapes and sizes. Keep an eye out when you see the word 'Substring' in a problem, as it may well mean its a sliding window problem! Once you get the pattern of them down, they are easy-peasy.</p><hr></article></main><div class="flex flex-wrap w-full items-center font-sans p-8 md:p-24"><div class="md:flex-1 flex"><img class="w-10 h-10 rounded-full mr-4" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><div class="flex-1"><p class="text-base font-bold text-base md:text-xl leading-none">Alex Stevens</p><p class="text-gray-600 text-xs md:text-base">iOS Software Engineer</p></div></div><div class="mt-8 md:mt-0 mx-auto md:mx-0 md:justify-end"><a class="bg-transparent border border-gray-500 hover:border-casper-blue text-xs text-gray-500 hover:text-casper-blue font-bold py-2 px-4 rounded-full" href="/tags">All tags</a></div></div></div></div><div class="bg-gray-200"><div class="container w-full max-w-6xl mx-auto px-2 py-8"><div class="grid grid-cols-1 sm:grid-cols-3 gap-12"><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/leetcode/blind-75-arrays" class="flex flex-wrap no-underline hover:no-underline"><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">LEETCODE</p><div class="w-full font-bold text-2xl text-gray-900 px-6">Blind 75: Arrays + Hashing + 2 pointers</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">Arrays + Leetcode = Match made in heaven</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><p class="text-gray-600 text-xs md:text-sm">37 MIN READ</p></div></div></div><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/leetcode/blind-75-binary-search" class="flex flex-wrap no-underline hover:no-underline"><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">LEETCODE</p><div class="w-full font-bold text-2xl text-gray-900 px-6">Blind 75: Binary Search</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">The programmers favorite searching mechanism!</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><p class="text-gray-600 text-xs md:text-sm">10 MIN READ</p></div></div></div><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/leetcode/how-to-solve-a-leetcode-problem" class="flex flex-wrap no-underline hover:no-underline"><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">LEETCODE</p><div class="w-full font-bold text-2xl text-gray-900 px-6">How to solve a Leetcode problem</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">Leetcode. The bane of many a programmer</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><p class="text-gray-600 text-xs md:text-sm">1 MIN READ</p></div></div></div></div></div></div><footer class="bg-gray-900"><div class="container max-w-6xl mx-auto flex items-center px-2 pt-2 pb-8"><div class="w-full mx-auto flex flex-wrap items-center"><div class="flex w-full md:w-1/2 justify-center md:justify-start text-white font-extrabold"><p><a class="text-gray-900 no-underline hover:text-gray-900 hover:no-underline" href="#"><span class="text-base text-gray-200">Swift Refresher</span></a></p></div><div class="flex w-full pt-2 content-center justify-between md:w-1/2 md:justify-end"><ul class="list-reset flex justify-center flex-1 md:flex-none items-center"><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="/">Latest Posts</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="https://github.com/JohnSundell/Publish">Publish</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="https://ghost.org">Ghost</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline px-3 text-sm" href="/feed.rss"><svg class="fill-current h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"></circle><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"></path></svg></a></li></ul></div></div></div></footer></body></html>