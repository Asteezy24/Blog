<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Swift Refresher"/><link rel="canonical" href="https://swiftrefresher.com/posts/blind-75-arrays"/><meta name="twitter:url" content="https://swiftrefresher.com/posts/blind-75-arrays"/><meta name="og:url" content="https://swiftrefresher.com/posts/blind-75-arrays"/><title>Blind 75: Arrays | Swift Refresher</title><meta name="twitter:title" content="Blind 75: Arrays | Swift Refresher"/><meta name="og:title" content="Blind 75: Arrays | Swift Refresher"/><meta name="description" content="Arrays + Leetcode = Match made in heaven"/><meta name="twitter:description" content="Arrays + Leetcode = Match made in heaven"/><meta name="og:description" content="Arrays + Leetcode = Match made in heaven"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Swift Refresher"/></head><body class="bg-white font-sans leading-normal tracking-normal"><div class="pb-16"><nav class="fixed z-10 bg-gray-900 p-4 mt-0 w-full overflow-auto scrolling-touch"><div class="container mx-auto flex items-center"><div class="flex-shrink-0 text-white font-extrabold"><a class="flex text-white text-base no-underline hover:text-white hover:no-underline" href="/"><span class="block md:hidden md:w-auto pl-1">üèù</span><span class="hidden md:block w-0 md:w-auto pl-1">Swift Refresher</span></a></div><div class=" flex flex-no-wrap pl-4 text-sm"><ul class="list-reset flex justify-between items-center"><li class="mr-2"><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-2" href="/">HOME</a></li><li><a class="inline-block py-2 px-2 text-white no-underline hover:underline whitespace-no-wrap" href="/posts">POSTS</a></li></ul></div></div></nav></div><div class="text-center pt-16 md:pt-32"><p class="text-xs md:text-sm text-casper-blue font-bold">16 MARCH 2022<span class="text-gray-900 px-1">/</span><a href="/tags/blind-75">BLIND 75</a></p><h1 class="font-bold break-normal text-3xl md:text-5xl max-w-6xl mx-auto">Blind 75: Arrays</h1></div><div class="container max-w-5xl mx-auto "><div class="mx-0 sm:mx-6"><main class="bg-white w-full p-8 md:p-24 text-gray-800 leading-normal"><article class="prose prose-sm sm:prose-xl break-words"><h1>TwoSum</h1><p>This is a classic introductory problem &amp; it is a good place for us to start our leetcode journey. Read over the problem statement below.</p><img src="/twosum.png"/><p>Pretty straightforward right? Let's take this step by step and make sure we understand the solution. We need the indices of 2 numbers that add up to a target. We can assume there is one answer, and we may not use the same element twice. Easy enough.</p><h3>Brute Force</h3><p>A brute force solution here is pretty obvious, let's go through each element in the array, and iterate over every other element, to see if we add up to a target. This is a common brute force method for most array problems. This will give us a O(n¬≤) time &amp; O(1) spacial solution. Let's write some pseudocode for this solution and test it. While testing, make sure to capture edge cases!</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">+</span> <span class="n">other</span> <span class="n">number</span> <span class="p">=</span> <span class="n">target</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">number</span> <span class="n">index</span><span class="p">,</span> <span class="n">other</span> <span class="n">number</span> <span class="n">index</span><span class="p">]</span>
</div></code></pre><h3>Testing</h3><p>Let's run through a quick test here for our solution. Say we are given an array of [4, 2, 1, 3] and our target is 3. We start at 4, and loop through the rest of the array numbers. 4 + 2 != 3.....4 + 1 != 3..and so on. No luck for our first number 4. So let's move on to the next number 2. Lucky for us, our first try with number 2 works! 2 + 1 = 3. So in this case we would return the indices of 2 &amp; 1 in array form. Namely, [1, 2].</p><p>Now this simple testing may seem redundant, but it's important we build the foundational blocks for solving these easy problems, so when we arrive at harder problems, we have this base knowledge. It is also important to understand where the bottlenecks are and where our solution can appear inefficient.</p><p>It is time to consider some bottlenecks, and think how we can optimize our solution. Firstly, if you notice some nested for loops in your code, that is a code smell. Think how those can be optimized. In our case if we try to pass thru the array only once, while also sequentially finding the solution, we heavily optimize our solution.</p><h3>Approach 1</h3><h3>[ Sort + 2 pointer ]</h3><h3>[ O(nLog(n)) time + O(n) space ]</h3><p>For this specific problem we know we want 2 numbers that add up to a target. That is, X + Y = Z. If we have X, we know that we are searching for Z - Y. If we sort our array, we can make this search much faster.</p><p>Back to our above example, we have an array of [4, 2, 1, 3] and we need a target of 3. If we first sort the array, we can use 2 pointers to incrementally get closer to our target number. By sorting our array is [1, 2, 3, 4]. We have a left pointer at the beginning of the array and a right pointer at the end of the array. Let's add these numbers up. 1 + 4 = 5, which is greater than our target of 3. The sum is greater than our target, so let's move the right pointer inward. Now our pointers are targeted at 1, and 3. 1 + 3 = 4, a summation that is still greater than our target. So we move the right pointer inward once more. This makes our pointers at 1 and 2, and if we add those up we find our target.</p><p>Pseudocode:</p><pre><code><div class="highlight"><span></span><span class="bp">sort</span> <span class="n">array</span>
<span class="k">while</span> <span class="kr">left</span> <span class="n">pointer</span> <span class="o">&lt;</span> <span class="kr">right</span> <span class="n">pointer</span>
    <span class="n">add</span> <span class="n">up</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">pointers</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="p">=</span> <span class="n">target</span>
        <span class="k">return</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">pointer</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span>
        <span class="n">move</span> <span class="kr">right</span> <span class="n">pointer</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span>
        <span class="n">move</span> <span class="kr">left</span> <span class="n">pointer</span>
</div></code></pre><p>There are some considerations here. By sorting we can get, on average, nLog(n) time performance. So by sorting and then searching our array we are looking at O(nLog(n)) + O(n) time complexity. Which comes out to be O(nLog(n)). This is a pretty significant time vs space tradeoff and this should be discussed with your interviewer.<br><br>Let's go into implementation now.</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for empty array + single element in array.</span>
<span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]()</span> <span class="p">}</span>

<span class="kd">let</span> <span class="nv">sorted</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">sorted</span><span class="p">()</span>
<span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">var</span> <span class="nv">rightPointer</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span>

<span class="c1">// Search our array</span>
<span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;</span> <span class="n">rightPointer</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">sum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="o">+</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="p">{</span>
        <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="p">{</span>
        <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">break</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Because the swift index(of:) function returns us an &#39;Array&lt;Int&gt;.Index?&#39; </span>
<span class="c1">// we need to manually get the integer Index value by doing one more loop.</span>
<span class="kd">let</span> <span class="nv">leftNum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">rightNum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span>

<span class="kd">var</span> <span class="nv">returnValue</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]()</span>

<span class="c1">// Beautiful swift! Reads just like english :) </span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="k">where</span> <span class="p">(</span><span class="n">num</span> <span class="p">==</span> <span class="n">leftNum</span> <span class="o">||</span> <span class="n">num</span> <span class="p">==</span> <span class="n">rightNum</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">returnValue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">returnValue</span>
</div></code></pre><p>Ta-Da! This is one passing solution to solve the 2 sum problem. This methodology will be the preferred method of solving in 3sum, 4sum and etc problems.</p><h3>Approach 2</h3><h3>[ Hash Table ]</h3><h3>[ O(n) time + space ]</h3><p>By using some auxiliary data structure for storage you can easily look up past calculations for your use case. In our case, we should try to optimize our O(n¬≤) time solution into a O(n) time solution. For array problems this is the mecca. This brings us to our introduction of hash tables/dictionary's. We can have constant lookup in swift dictionaries.</p><p>In our case let's consider we loop through the array 1 time, and in a hash table, we store the key as the element of our array and the value as the index of each value. So our original array of [4, 2, 1, 3] turns into a dictionary of [4: 0, 2: 1, 1: 2, 3: 3]. Now in our problem, we can go through our array 1 time, and at each element we can see if the inverse of the target exists. Namely it comes down to this pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">add</span> <span class="n">to</span> <span class="n">dictionary</span><span class="p">.</span> <span class="p">[</span><span class="n">number</span><span class="p">:</span> <span class="n">index</span> <span class="n">of</span> <span class="n">number</span><span class="p">]</span>
    
<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">inverse</span> <span class="p">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">number</span>
    <span class="k">if</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">inverse</span><span class="p">]</span> <span class="n">exists</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">number</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">inverse</span><span class="p">]]</span>
</div></code></pre><p>After testing, we see this is a lot more efficient, and it works! We gave up some constant space in order for time efficiency, but these tradeoffs are things you can discuss with your interviewer. Now let's code our final solution. Don't forget to cover those edge cases, and to practice safe optional unwrapping!</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for empty array + single element in array.</span>
<span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[]</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span>
<span class="c1">// Create our hashtable mapping</span>
<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">hashTable</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="n">index</span>
<span class="p">}</span>
<span class="c1">// Now search our array for the inverse!</span>
<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">inverse</span> <span class="p">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">element</span>
    <span class="c1">// we should not be using the same element within itself. Make sure to read the problem carefully!</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">existingInverse</span> <span class="p">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">inverse</span><span class="p">],</span> <span class="n">unwrappedInverse</span> <span class="o">!=</span> <span class="n">index</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">existingInverse</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="p">[]</span> <span class="c1">// we have no solution. </span>
</div></code></pre><p>Nice work!</p><h1>ThreeSum</h1><p>This problem builds off of our previous problem, with a little more complexity. Check out the problem statement below.</p><img src="/threesum.png"/><p>If we remember one of the solutions for the TwoSum problem, when we sort the array then use 2 pointers to find our target it leads to decently efficient code.</p><h3>Brute Force</h3><p>With most array problems, the brute force solution is straightforward. By using nested loops, we can iterate on all possible answer combinations until we find the solution(s) we want. In this case, this is an O(n¬≥) solution. With all of our "sum" problems we can represent the brute force as a O(nÀ£) where x = the number 'sum' the problem is asking for.</p><p>Pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">secondNumber</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">for</span> <span class="n">thirdNumber</span> <span class="k">in</span> <span class="n">array</span>
            <span class="k">if</span> <span class="n">number</span> <span class="o">+</span> <span class="n">secondNumber</span> <span class="o">+</span> <span class="n">thirdNumber</span> <span class="p">=</span> <span class="mi">0</span> <span class="n">AND</span> <span class="n">we</span> <span class="n">have</span> <span class="n">not</span> <span class="n">added</span> <span class="n">this</span> <span class="n">answer</span> <span class="n">combination</span> <span class="n">before</span>
                <span class="n">add</span> <span class="n">these</span> <span class="n">numbers</span> <span class="n">to</span> <span class="n">our</span> <span class="k">return</span> <span class="n">value</span>
</div></code></pre><h3>Testing</h3><p>Let's run a quick test to verify we are headed down the right path. With an input of [-1,0,1,2,-1,-4], doing some manual testing leads us to an answer of [[-1,0,1], [-1, 2, -1]]. This is a correct answer but it probably takes way too long to even test by hand.</p><p>Obviously the nested nature of these arrays should be avoided. So let's take a step back and iterate on our approach from the TwoSum problem.</p><h3>Approach</h3><h3>[ Sort + 2 pointer ]</h3><h3>[ O(n¬≤) time + O(n) space ]</h3><p>We know we need to add up to a target of 0, with 3 different numbers. In formulaic terms, we have X + Y + Z = 0. For each element in our array, we have one of the elements in our equation. So we are left with -Z = X + Y, where Z is our element in the array.</p><p>By sorting our array at the beginning of our function, we can reuse our TwoSum logic. Add up X + Y. If that sum is less than our target (-Z) we need to increase our sum &amp; vice versa. Since our array is sorted, and we can represent X and Y as leftPointer's and rightPointer's in our array, it is easy to increase and decrease our sum as needed. Namely we can do something similar to this.</p><pre><code><div class="highlight"><span></span><span class="bp">sort</span> <span class="n">array</span>
<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="bp">sorted</span> <span class="n">array</span>
    <span class="bp">find</span> <span class="n">the</span> <span class="n">targetNumber</span>
    <span class="bp">find</span> <span class="n">the</span> <span class="n">leftPointer</span>
    <span class="bp">find</span> <span class="n">the</span> <span class="n">rightPointer</span>
    
    <span class="k">while</span> <span class="n">leftPointer</span> <span class="n">less</span> <span class="n">than</span> <span class="n">rightPointer</span>
        <span class="n">sum</span> <span class="p">=</span> <span class="n">leftPointer</span> <span class="o">+</span> <span class="n">rightPointer</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="k">is</span> <span class="n">less</span> <span class="n">than</span> <span class="n">target</span>
            <span class="n">move</span> <span class="n">leftPointer</span> <span class="n">inward</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="k">is</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">target</span>
            <span class="n">move</span> <span class="n">rightPointer</span> <span class="n">inward</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="n">equals</span> <span class="n">target</span> <span class="n">AND</span> <span class="n">not</span> <span class="n">duplicated</span>
            <span class="n">we</span> <span class="n">have</span> <span class="n">our</span> <span class="n">combination</span><span class="p">!</span>
            <span class="n">add</span> <span class="n">to</span> <span class="n">answer</span>
            <span class="n">move</span> <span class="n">both</span> <span class="n">leftPointer</span> <span class="n">and</span> <span class="n">rightPointer</span> <span class="n">inward</span>
</div></code></pre><p>Some time + space considerations here. By sorting we have O(nLog(n)) and then searching every element in the array gives us O(nLog(n)) + O(n¬≤). Since O(n¬≤) is much greater than O(nLog(n)), the O(nLog(n)) cancels out and does not need to be considered in the final time complexity calculations, so the final time complexity is O(n¬≤) time where n is the length of our input array. For space, we need to keep track of the answer in an array, so the space complexity is O(n) where n is the length of the answer.</p><p>Let's implement the real answer.</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for empty array + single element + only 2 elements in array.</span>
<span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[[</span><span class="nb">Int</span><span class="p">]]()</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nv">returnVal</span> <span class="p">=</span> <span class="p">[[</span><span class="nb">Int</span><span class="p">]]()</span>
<span class="kd">let</span> <span class="nv">sorted</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">sorted</span><span class="p">()</span>

<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="bp">sorted</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">target</span> <span class="p">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">element</span>
    <span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="kd">var</span> <span class="nv">rightPointer</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="c1">// search for our target, within bounds</span>
    <span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;</span> <span class="n">rightPointer</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">sum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="o">+</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="p">{</span>
            <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// Sum is too small, increase our sum</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="p">{</span>
            <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1">// Sum is too big, decrease our sum</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">sum</span> <span class="p">==</span> <span class="n">target</span> <span class="p">{</span>
            <span class="c1">// We found an answer!</span>
            <span class="kd">let</span> <span class="nv">correctAns</span> <span class="p">=</span> <span class="p">[</span><span class="n">element</span><span class="p">,</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">],</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]]</span>
            <span class="c1">// Preemptively move our pointers inward </span>
            <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="n">returnVal</span><span class="p">.</span><span class="bp">contains</span><span class="p">(</span><span class="n">correctAns</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// add to our answer</span>
                <span class="n">returnVal</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">correctAns</span><span class="p">)</span>
            <span class="p">}</span> 
        <span class="p">}</span>  
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">returnVal</span>
</div></code></pre><p>Boom! Nicely done.</p></article></main><div class="flex flex-wrap w-full items-center font-sans p-8 md:p-24"><div class="md:flex-1 flex"><img class="w-10 h-10 rounded-full mr-4" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><div class="flex-1"><p class="text-base font-bold text-base md:text-xl leading-none">Alex Stevens</p><p class="text-gray-600 text-xs md:text-base">iOS Software Engineer</p></div></div><div class="mt-8 md:mt-0 mx-auto md:mx-0 md:justify-end"><a class="bg-transparent border border-gray-500 hover:border-casper-blue text-xs text-gray-500 hover:text-casper-blue font-bold py-2 px-4 rounded-full" href="/tags">All tags</a></div></div></div></div><div class="bg-gray-200"><div class="container w-full max-w-6xl mx-auto px-2 py-8"><div class="grid grid-cols-1 sm:grid-cols-3 gap-12"><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/posts/how-to-solve-a-leetcode-problem" class="flex flex-wrap no-underline hover:no-underline"><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">BLIND75</p><div class="w-full font-bold text-2xl text-gray-900 px-6">How to solve a Leetcode problem</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">Leetcode. The bane of many a programmer</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><p class="text-gray-600 text-xs md:text-sm">1 MIN READ</p></div></div></div><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/posts/arrays" class="flex flex-wrap no-underline hover:no-underline"><img src="/array.jpeg" class="h-64 w-full rounded-t object-cover"/><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">SWIFT</p><div class="w-full font-bold text-2xl text-gray-900 px-6">Arrays Overview</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">Programmers best friend</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><p class="text-gray-600 text-xs md:text-sm">8 MIN READ</p></div></div></div><div class="w-full  py-6 flex flex-col flex-grow flex-shrink transform transition duration-200 ease-in-out hover:scale-105"><div class="flex-1 bg-white rounded-t rounded-b-none overflow-hidden shadow-lg"><a href="/posts/about" class="flex flex-wrap no-underline hover:no-underline"><img src="/about_me.jpeg" class="h-64 w-full rounded-t object-cover"/><p class="w-full text-casper-blue text-xs font-medium pt-6 px-6">ABOUT</p><div class="w-full font-bold text-2xl text-gray-900 px-6">About</div><p class="text-gray-800 font-serif text-lg px-6 mb-5">A little about myself üòÑ</p></a></div><div class="flex-none mt-auto bg-white rounded-b rounded-t-none overflow-hidden shadow-lg p-6"><div class="flex items-center justify-between"><img class="w-8 h-8 rounded-full mr-4 avatar" src="https://asteezy24.github.io/assets/images/image01.jpg" alt="Alex Stevens"/><p class="text-gray-600 text-xs md:text-sm">1 MIN READ</p></div></div></div></div></div></div><footer class="bg-gray-900"><div class="container max-w-6xl mx-auto flex items-center px-2 pt-2 pb-8"><div class="w-full mx-auto flex flex-wrap items-center"><div class="flex w-full md:w-1/2 justify-center md:justify-start text-white font-extrabold"><p><a class="text-gray-900 no-underline hover:text-gray-900 hover:no-underline" href="#"><span class="text-base text-gray-200">Swift Refresher</span></a></p></div><div class="flex w-full pt-2 content-center justify-between md:w-1/2 md:justify-end"><ul class="list-reset flex justify-center flex-1 md:flex-none items-center"><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="/">Latest Posts</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="https://github.com/JohnSundell/Publish">Publish</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline py-2 px-3 text-sm" href="https://ghost.org">Ghost</a></li><li><a class="inline-block text-gray-600 no-underline hover:text-gray-200 hover:underline px-3 text-sm" href="/feed.rss"><svg class="fill-current h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"></circle><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"></path></svg></a></li></ul></div></div></div></footer></body></html>