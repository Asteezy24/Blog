<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Swift Refresher</title><description>Keeping you up to date on the latest developments in the world of Swift &amp; iOS programming!</description><link>https://swiftrefresher.com</link><language>en</language><lastBuildDate>Thu, 21 Apr 2022 19:32:33 -0400</lastBuildDate><pubDate>Thu, 21 Apr 2022 19:32:33 -0400</pubDate><ttl>250</ttl><atom:link href="https://swiftrefresher.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://swiftrefresher.com/posts/blind-75-arrays</guid><title>Blind 75: Arrays</title><description>Arrays + Leetcode = Match made in heaven</description><link>https://swiftrefresher.com/posts/blind-75-arrays</link><pubDate>Wed, 16 Mar 2022 21:02:00 -0400</pubDate><content:encoded><![CDATA[<h1>TwoSum</h1><p>This is a classic introductory problem &amp; it is a good place for us to start our leetcode journey. Read over the problem statement below.</p><img src="https://swiftrefresher.com/twosum.png"/><p>Pretty straightforward right? Let's take this step by step and make sure we understand the solution. We need the indices of 2 numbers that add up to a target. We can assume there is one answer, and we may not use the same element twice. Easy enough.</p><h3>Brute Force</h3><p>A brute force solution here is pretty obvious, let's go through each element in the array, and iterate over every other element, to see if we add up to a target. This is a common brute force method for most array problems. This will give us a O(n²) time &amp; O(1) spacial solution. Let's write some pseudocode for this solution and test it. While testing, make sure to capture edge cases!</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">+</span> <span class="n">other</span> <span class="n">number</span> <span class="p">=</span> <span class="n">target</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">number</span> <span class="n">index</span><span class="p">,</span> <span class="n">other</span> <span class="n">number</span> <span class="n">index</span><span class="p">]</span>
</div></code></pre><p>It is time to consider some bottlenecks, and think how we can optimize our solution. Firstly, if you notice some nested for loops in your code, that is a code smell. Think how those can be optimized. In our case if we try to pass thru the array only once, while also sequentially finding the solution, we heavily optimize our solution.</p><h3>Approach 1</h3><h3>[ Sort + 2 pointer ]</h3><h3>[ O(nLog(n)) time + O(n) space ]</h3><p>For this specific problem we know we want 2 numbers that add up to a target. That is, X + Y = Z. If we have X, we know that we are searching for Z - Y. If we sort our array, we can make this search much faster.</p><p>Back to our above example, we have an array of [4, 2, 1, 3] and we need a target of 3. If we first sort the array, we can use 2 pointers to incrementally get closer to our target number. By sorting our array is [1, 2, 3, 4]. We have a left pointer at the beginning of the array and a right pointer at the end of the array. Let's add these numbers up. 1 + 4 = 5, which is greater than our target of 3. The sum is greater than our target, so let's move the right pointer inward. Now our pointers are targeted at 1, and 3. 1 + 3 = 4, a summation that is still greater than our target. So we move the right pointer inward once more. This makes our pointers at 1 and 2, and if we add those up we find our target.</p><p>Pseudocode:</p><pre><code><div class="highlight"><span></span><span class="bp">sort</span> <span class="n">array</span>
<span class="k">while</span> <span class="kr">left</span> <span class="n">pointer</span> <span class="o">&lt;</span> <span class="kr">right</span> <span class="n">pointer</span>
    <span class="n">add</span> <span class="n">up</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">pointers</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="p">=</span> <span class="n">target</span>
        <span class="k">return</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">pointer</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span>
        <span class="n">move</span> <span class="kr">right</span> <span class="n">pointer</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span>
        <span class="n">move</span> <span class="kr">left</span> <span class="n">pointer</span>
</div></code></pre><p>There are some considerations here. By sorting we can get, on average, O(nLog(n)) time performance. So by sorting and then searching our array we are looking at O(nLog(n)) + O(n) time complexity. Which comes out to be O(nLog(n)). This is a pretty significant time vs space tradeoff and this should be discussed with your interviewer.<br><br>Let's go into implementation now.</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for empty array + single element in array.</span>
<span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]()</span> <span class="p">}</span>

<span class="kd">let</span> <span class="nv">sorted</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">sorted</span><span class="p">()</span>
<span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">var</span> <span class="nv">rightPointer</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span>

<span class="c1">// Search our array</span>
<span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;</span> <span class="n">rightPointer</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">sum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="o">+</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="p">{</span>
        <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="p">{</span>
        <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">break</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Because the swift index(of:) function returns us an &#39;Array&lt;Int&gt;.Index?&#39; </span>
<span class="c1">// we need to manually get the integer Index value by doing one more loop.</span>
<span class="kd">let</span> <span class="nv">leftNum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">rightNum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span>

<span class="kd">var</span> <span class="nv">returnValue</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]()</span>

<span class="c1">// Beautiful swift! Reads just like english :) </span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="k">where</span> <span class="p">(</span><span class="n">num</span> <span class="p">==</span> <span class="n">leftNum</span> <span class="o">||</span> <span class="n">num</span> <span class="p">==</span> <span class="n">rightNum</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">returnValue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">returnValue</span>
</div></code></pre><p>Ta-Da! This is one passing solution to solve the 2 sum problem. This methodology will be the preferred method of solving in 3sum, 4sum and etc problems.</p><h3>Approach 2</h3><h3>[ Hash Table ]</h3><h3>[ O(n) time + space ]</h3><p>By using some auxiliary data structure for storage you can easily look up past calculations for your use case. In our case, we should try to optimize our O(n²) time solution into a O(n) time solution. For array problems this is the mecca. This brings us to our introduction of hash tables/dictionary's. We can have constant lookup in swift dictionaries.</p><p>In our case let's consider we loop through the array 1 time, and in a hash table, we store the key as the element of our array and the value as the index of each value. So our original array of [4, 2, 1, 3] turns into a dictionary of [4: 0, 2: 1, 1: 2, 3: 3]. Now in our problem, we can go through our array 1 time, and at each element we can see if the inverse of the target exists. Namely it comes down to this pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">add</span> <span class="n">to</span> <span class="n">dictionary</span><span class="p">.</span> <span class="p">[</span><span class="n">number</span><span class="p">:</span> <span class="n">index</span> <span class="n">of</span> <span class="n">number</span><span class="p">]</span>
    
<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">inverse</span> <span class="p">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">number</span>
    <span class="k">if</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">inverse</span><span class="p">]</span> <span class="n">exists</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">number</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">inverse</span><span class="p">]]</span>
</div></code></pre><p>After testing, we see this is a lot more efficient, and it works! We gave up some constant space in order for time efficiency, but these tradeoffs are things you can discuss with your interviewer. Now let's code our final solution. Don't forget to cover those edge cases, and to practice safe optional unwrapping!</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for empty array + single element in array.</span>
<span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[]</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span>
<span class="c1">// Create our hashtable mapping</span>
<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">hashTable</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="n">index</span>
<span class="p">}</span>
<span class="c1">// Now search our array for the inverse!</span>
<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">inverse</span> <span class="p">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">element</span>
    <span class="c1">// we should not be using the same element within itself. Make sure to read the problem carefully!</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">existingInverse</span> <span class="p">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">inverse</span><span class="p">],</span> <span class="n">unwrappedInverse</span> <span class="o">!=</span> <span class="n">index</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">existingInverse</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="p">[]</span> <span class="c1">// we have no solution. </span>
</div></code></pre><p>Nice work!</p><hr><h1>ThreeSum</h1><p>This problem builds off of our previous problem, with a little more complexity. Check out the problem statement below.</p><img src="https://swiftrefresher.com/threesum.png"/><p>If we remember one of the solutions for the TwoSum problem, when we sort the array then use 2 pointers to find our target it leads to decently efficient code.</p><h3>Brute Force</h3><p>With most array problems, the brute force solution is straightforward. By using nested loops, we can iterate on all possible answer combinations until we find the solution(s) we want. In this case, this is an O(n³) solution. With all of our "sum" problems we can represent the brute force as a O(nˣ) where x = the number 'sum' the problem is asking for.</p><p>Pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">secondNumber</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">for</span> <span class="n">thirdNumber</span> <span class="k">in</span> <span class="n">array</span>
            <span class="k">if</span> <span class="n">number</span> <span class="o">+</span> <span class="n">secondNumber</span> <span class="o">+</span> <span class="n">thirdNumber</span> <span class="p">=</span> <span class="mi">0</span> <span class="n">AND</span> <span class="n">we</span> <span class="n">have</span> <span class="n">not</span> <span class="n">added</span> <span class="n">this</span> <span class="n">answer</span> <span class="n">combination</span> <span class="n">before</span>
                <span class="n">add</span> <span class="n">these</span> <span class="n">numbers</span> <span class="n">to</span> <span class="n">our</span> <span class="k">return</span> <span class="n">value</span>
</div></code></pre><p>Obviously the nested nature of these arrays should be avoided. So let's take a step back and iterate on our approach from the TwoSum problem.</p><h3>Approach</h3><h3>[ Sort + 2 pointer ]</h3><h3>[ O(n²) time + O(n) space ]</h3><p>We know we need to add up to a target of 0, with 3 different numbers. In formulaic terms, we have X + Y + Z = 0. For each element in our array, we have one of the elements in our equation. So we are left with -Z = X + Y, where Z is our element in the array.</p><p>By sorting our array at the beginning of our function, we can reuse our TwoSum logic. Add up X + Y. If that sum is less than our target (-Z) we need to increase our sum &amp; vice versa. Since our array is sorted, and we can represent X and Y as leftPointer's and rightPointer's in our array, it is easy to increase and decrease our sum as needed. Namely we can do something similar to this.</p><pre><code><div class="highlight"><span></span><span class="bp">sort</span> <span class="n">array</span>
<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="bp">sorted</span> <span class="n">array</span>
    <span class="bp">find</span> <span class="n">the</span> <span class="n">targetNumber</span>
    <span class="bp">find</span> <span class="n">the</span> <span class="n">leftPointer</span>
    <span class="bp">find</span> <span class="n">the</span> <span class="n">rightPointer</span>
    
    <span class="k">while</span> <span class="n">leftPointer</span> <span class="n">less</span> <span class="n">than</span> <span class="n">rightPointer</span>
        <span class="n">sum</span> <span class="p">=</span> <span class="n">leftPointer</span> <span class="o">+</span> <span class="n">rightPointer</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="k">is</span> <span class="n">less</span> <span class="n">than</span> <span class="n">target</span>
            <span class="n">move</span> <span class="n">leftPointer</span> <span class="n">inward</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="k">is</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">target</span>
            <span class="n">move</span> <span class="n">rightPointer</span> <span class="n">inward</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="n">equals</span> <span class="n">target</span> <span class="n">AND</span> <span class="n">not</span> <span class="n">duplicated</span>
            <span class="n">we</span> <span class="n">have</span> <span class="n">our</span> <span class="n">combination</span><span class="p">!</span>
            <span class="n">add</span> <span class="n">to</span> <span class="n">answer</span>
            <span class="n">move</span> <span class="n">both</span> <span class="n">leftPointer</span> <span class="n">and</span> <span class="n">rightPointer</span> <span class="n">inward</span>
</div></code></pre><p>Some time + space considerations here. By sorting we have O(nLog(n)) and then searching every element in the array gives us O(nLog(n)) + O(n²). Since O(n²) is much greater than O(nLog(n)), the O(nLog(n)) cancels out and does not need to be considered in the final time complexity calculations, so the final time complexity is O(n²) time where n is the length of our input array. For space, we need to keep track of the answer in an array, so the space complexity is O(n) where n is the length of the answer.</p><p>Let's implement the real answer.</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for empty array + single element + only 2 elements in array.</span>
<span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[[</span><span class="nb">Int</span><span class="p">]]()</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nv">returnVal</span> <span class="p">=</span> <span class="p">[[</span><span class="nb">Int</span><span class="p">]]()</span>
<span class="kd">let</span> <span class="nv">sorted</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">sorted</span><span class="p">()</span>

<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="bp">sorted</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">target</span> <span class="p">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">element</span>
    <span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="kd">var</span> <span class="nv">rightPointer</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="c1">// search for our target, within bounds</span>
    <span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;</span> <span class="n">rightPointer</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">sum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="o">+</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="p">{</span>
            <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// Sum is too small, increase our sum</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="p">{</span>
            <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1">// Sum is too big, decrease our sum</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">sum</span> <span class="p">==</span> <span class="n">target</span> <span class="p">{</span>
            <span class="c1">// We found an answer!</span>
            <span class="kd">let</span> <span class="nv">correctAns</span> <span class="p">=</span> <span class="p">[</span><span class="n">element</span><span class="p">,</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">],</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]]</span>
            <span class="c1">// Preemptively move our pointers inward </span>
            <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="n">returnVal</span><span class="p">.</span><span class="bp">contains</span><span class="p">(</span><span class="n">correctAns</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// add to our answer</span>
                <span class="n">returnVal</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">correctAns</span><span class="p">)</span>
            <span class="p">}</span> 
        <span class="p">}</span>  
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">returnVal</span>
</div></code></pre><p>Boom! Nicely done.</p><hr><h1>Contains Duplicates</h1><p>This is a pretty straightforward problem, but builds our foundational knowledge when it comes to HashTables! Find the problem statement below.</p><img src="https://swiftrefresher.com/containsduplicates.png"/><p>Very easy problem to grasp. Now let's try to find ourselves a brute force solution, and optimize it.</p><h3>Brute Force</h3><p>A very easy brute force solution, leads us to an O(n²) time complexity solution with O(1) space. This would be to go by each element in the array, and have a nested loop to see if our outer element is found within our inner loop. Like so:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">number</span> <span class="n">equals</span> <span class="n">other</span> <span class="n">number</span> <span class="n">we</span> <span class="n">have</span> <span class="n">found</span> <span class="n">a</span> <span class="n">duplicate</span><span class="p">.</span>
</div></code></pre><p>By introducing a HashTable into the problem, we know that HashTable's have constant lookup, but at worst, they take up O(n) space where N = length of the input array. Also since HashTable's have unique keys, we will be able to store all of the elements in our array just once.</p><h3>Approach</h3><h3>[ HashTable + Consistent Lookup ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>We can initialize a HashTable at the beginning of our problem, where the key of the HashTable is the same type of element in our input array, in this case Integer. As we loop through our array, we can check if the HashTable already contains a key-element pair that matches Integer at each iteration of the loop. If the key-element pair exists, we can break out of the loop, and return true for our function. If the key-element pair does not exist, we can add it to the HashTable.</p><pre><code><div class="highlight"><span></span><span class="n">Create</span> <span class="n">HashTable</span> <span class="n">with</span> <span class="n">key</span> <span class="n">of</span> <span class="n">Integer</span> <span class="n">and</span> <span class="n">element</span> <span class="n">of</span> <span class="n">whatever</span> <span class="n">you</span> <span class="n">would</span> <span class="n">like</span> 

<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">if</span> <span class="n">element</span> <span class="n">exists</span> <span class="n">with</span> <span class="n">number</span> <span class="k">as</span> <span class="n">the</span> <span class="n">key</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="k">else</span>
        <span class="n">add</span> <span class="n">to</span> <span class="n">the</span> <span class="n">HashTable</span>
</div></code></pre><p>Pretty simple right! Like I mentioned above, the time and space are both O(n). This is why HashTables are so powerful, is because they give us consistent lookup time when we need some auxiliary storage in our problems. Now it is time to implement the real solution.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span> <span class="c1">// edge-case check against small or empty inputs</span>

<span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span> <span class="c1">// i opted for an Int:Int pair, but you could have easily done Int:Bool, etc. </span>
        
<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// loop our input array</span>
    <span class="k">if</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span> <span class="c1">// We have found a duplicate!</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="n">index</span> <span class="c1">// Add element to HashTable</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="kc">false</span> <span class="c1">// No duplicates here...</span>
</div></code></pre><p>Easy-Peasy.</p><hr><h1>Product Of Array Except Self</h1><p>This problem is our first introduction on how to traverse an array both forwards and backwards! Let's dive in.</p><img src="https://swiftrefresher.com/productexceptself.png"/><p>We need to come up with a brute force solution to start, and like every other array problem, we can nest iterations in order to get every possible combination in the array.</p><h3>Brute Force</h3><p>We can start at each point in a given array and calculate every other arrays product, and add it to a return value. This leads us to a O(n²) time complexity and an O(n) spatial complexity because we need to store the length of the return array in our function. This is O(n²) time due to the nested nature of our iterations within the array.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">iterate</span> <span class="n">through</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">array</span>
        <span class="n">calculate</span> <span class="n">the</span> <span class="n">product</span>
    <span class="n">add</span> <span class="n">product</span> <span class="n">to</span> <span class="k">return</span> <span class="n">value</span> 
</div></code></pre><h3>Approach</h3><h3>[ Forward + Backward Iteration ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>We can optimize this problem by filling in our return array only twice. We can loop forward through our auxiliary return array once, keep a running product at each iteration, and use the running product to fill our return value array. Then we can reset our running product count, and iterate our array backwards to keep a running count of all the values minus itself.</p><p>The thinking here is, as we iterate our array we can fill in our return value in place. On the first loop, returnArray[i] will contain proceeding product of nums[i] (exclusive). After the second loop, each returnArray[i] is updated by multiplying to succeeding product of nums[i].</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">running</span> <span class="bp">count</span> <span class="n">starting</span> <span class="n">at</span> <span class="mi">1</span>
<span class="n">create</span> <span class="k">return</span> <span class="n">array</span> <span class="n">of</span> <span class="n">all</span> <span class="mi">1</span><span class="err">&#39;</span><span class="n">s</span>

<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span> <span class="n">forward</span> <span class="n">direction</span>
    <span class="n">update</span> <span class="k">return</span> <span class="n">array</span> <span class="n">with</span> <span class="n">running</span> <span class="bp">count</span>
    <span class="n">update</span> <span class="n">running</span> <span class="bp">count</span> <span class="n">by</span> <span class="n">multiplying</span> <span class="n">number</span> <span class="n">to</span> <span class="n">existing</span> <span class="bp">count</span> 
    
<span class="n">reset</span> <span class="n">running</span> <span class="bp">count</span>

<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span> <span class="n">backwards</span> <span class="n">direction</span>
    <span class="n">update</span> <span class="k">return</span> <span class="n">array</span> <span class="n">by</span> <span class="n">multiplying</span> <span class="n">running</span> <span class="bp">count</span> <span class="n">by</span> <span class="n">number</span> <span class="k">in</span> <span class="n">input</span> <span class="n">array</span>
    <span class="n">update</span> <span class="n">running</span> <span class="bp">count</span> <span class="n">by</span> <span class="n">multiplying</span> <span class="n">number</span> <span class="n">to</span> <span class="n">existing</span> <span class="bp">count</span>
    
<span class="k">return</span>
</div></code></pre><p>This gives us an O(n) time solution since we only have to iterate twice, namely forward and backwards. O(2n) = O(n) on average. Space is still consistently O(n). Now let's implement the real solution.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[]</span> <span class="p">}</span> <span class="c1">// guard against edge cases</span>
<span class="kd">var</span> <span class="nv">auxArray</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">repeating</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">count</span><span class="p">:</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span><span class="p">)</span> <span class="c1">// create a return array of all 1&#39;s</span>
<span class="kd">var</span> <span class="nv">runningCount</span> <span class="p">=</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.&lt;</span><span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span> <span class="c1">// forward iteration</span>
    <span class="n">auxArray</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">runningCount</span>
    <span class="n">runningCount</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="c1">// update running count of product</span>
<span class="p">}</span>

<span class="n">runningCount</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// reset the running count</span>

<span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="bp">stride</span><span class="p">(</span><span class="n">from</span><span class="p">:</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">through</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">by</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// backward iteration</span>
    <span class="n">auxArray</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">*=</span> <span class="n">runningCount</span>
    <span class="n">runningCount</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="c1">// update running count of product</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">auxArray</span>
</div></code></pre><p>Good Job!</p><hr><h1>Valid Anagram</h1><p>This problem expands our knowledge on array best practices! Let's tackle it.</p><img src="https://swiftrefresher.com/validanagram.png"/><h3>Brute Force</h3><p>Let's start by thinking of a brute force solution. My brute force solution I came up with involved a little different of an approach as opposed to other array problems. Nesting arrays in this problem isn't quite where my head first went. Initially I thought it would be easiest to sort both input strings, and then go letter by letter to compare the two strings. When we find a deviation between the two, we do not have a valid anagram.</p><pre><code><div class="highlight"><span></span><span class="bp">sort</span> <span class="n">string</span> <span class="n">s</span>
<span class="bp">sort</span> <span class="n">string</span> <span class="n">t</span>

<span class="n">make</span> <span class="n">sure</span> <span class="n">they</span> <span class="n">are</span> <span class="n">the</span> <span class="n">same</span> <span class="n">length</span> 

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">s</span> <span class="n">or</span> <span class="n">t</span> <span class="n">length</span>
    <span class="k">if</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">s</span> <span class="n">does</span> <span class="n">not</span> <span class="bp">equal</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">t</span>
        <span class="k">return</span> <span class="kc">false</span>
        
<span class="k">if</span> <span class="n">we</span> <span class="kr">get</span> <span class="n">here</span><span class="p">,</span> <span class="n">we</span> <span class="n">have</span> <span class="n">a</span> <span class="n">valid</span> <span class="n">anagram</span>
</div></code></pre><p>Looping the strings is not the issue here. Sorting 2 different strings, and then looping is not very optimal. By sorting we can get, on average, O(nLog(n)) time performance. Make that sorting twice plus looping the strings we are looking at O(2nLog(n)) + O(n) time complexity. We can simplify this to O(3nLog(n)) -&gt; O(nLog(n)) time, with O(1) consistent space complexity.</p><p>We know we can do better though. It may be worth giving up our consistent space complexity to get a better time complexity.</p><h3>Approach</h3><h3>[ HashTable with letter occurrences ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>We can introduce our arrays best friend! A hash table. We can store the occurrences of each letter in our hashTable. Utilizing a hash table here gives us consistent O(1) lookup when we need to know how many times we have seen a character. We have 2 strings, for one string we can increase the number of occurrences, for another string we can decrease the number of occurrences. In a perfect world, our hash table should have values of all 0's if it is a valid anagram.</p><pre><code><div class="highlight"><span></span><span class="n">check</span> <span class="n">string</span> <span class="n">lengths</span> <span class="n">are</span> <span class="bp">equal</span>
<span class="n">create</span> <span class="n">hash</span> <span class="n">table</span>

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">s</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span> <span class="bp">contains</span> <span class="n">this</span> <span class="n">letter</span> <span class="n">already</span>
        <span class="n">increment</span> <span class="n">its</span> <span class="n">occurrence</span> <span class="n">number</span> <span class="n">by</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span> <span class="n">does</span> <span class="n">not</span> <span class="n">contain</span> <span class="n">this</span> <span class="n">letter</span>
        <span class="n">add</span> <span class="n">it</span> <span class="n">to</span> <span class="n">the</span> <span class="n">hash</span> <span class="n">table</span> <span class="n">with</span> <span class="n">an</span> <span class="n">occurrence</span> <span class="n">of</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">t</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span> <span class="bp">contains</span> <span class="n">this</span> <span class="n">letter</span> <span class="n">already</span>
        <span class="n">decrement</span> <span class="n">its</span> <span class="n">occurrence</span> <span class="n">number</span> <span class="n">by</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span> <span class="n">does</span> <span class="n">not</span> <span class="n">contain</span> <span class="n">this</span> <span class="n">letter</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="n">we</span> <span class="n">have</span> <span class="n">found</span> <span class="n">a</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">t</span> <span class="n">that</span> <span class="n">s</span> <span class="n">does</span> <span class="n">not</span> <span class="n">have</span>
        
<span class="k">for</span> <span class="n">values</span> <span class="k">in</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">value</span> <span class="k">is</span> <span class="n">not</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">false</span>

<span class="k">return</span> <span class="kc">true</span>
</div></code></pre><p>This solution contains 3 loops. This equates to O(3n) → O(n) on average time complexity. Our space complexity is O(n) where n is the number of unique characters in s and t. This can also be represented as O(max(s.length, t.length)) at worst case. It's time to bring it all together:</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">s</span><span class="p">.</span><span class="bp">count</span> <span class="p">==</span> <span class="n">t</span><span class="p">.</span><span class="bp">count</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span> <span class="c1">// edge case where our string lengths may not be equal</span>
<span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Character</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span>

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">existing</span> <span class="p">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">=</span> <span class="n">existing</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// if we have already seen this character, append its count by 1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// we have not seen this character yet, add to hash table</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">t</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">existing</span> <span class="p">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">=</span> <span class="n">existing</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// decrement the character occurrence by 1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span> <span class="c1">// t contains a letter s does not have. not a valid anagram</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">hashTable</span><span class="p">.</span><span class="n">values</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span> <span class="c1">// we have found a letter where s contains more occurrences than t, and vice versa</span>
<span class="p">}</span>
<span class="k">return</span> <span class="kc">true</span> <span class="c1">// valid!</span>
</div></code></pre><p>Nice!</p><hr>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/posts/how-to-solve-a-leetcode-problem</guid><title>How to solve a Leetcode problem</title><description>Leetcode. The bane of many a programmer</description><link>https://swiftrefresher.com/posts/how-to-solve-a-leetcode-problem</link><pubDate>Mon, 14 Mar 2022 22:15:00 -0400</pubDate><content:encoded><![CDATA[<h1>Overview</h1><p>Overall, you will find that many leetcode problems are similar to one another. Once you build a solid foundation of knowledge (Blind 75) you will be able to conquer any problem! Keep this in mind when you are looking for patterns within problems. If a string problem stumps you, try thinking of it from an array perspective and vice versa! When I think about Leetcode solutions, I take the following steps:</p><h3>The process</h3><ol><li>Clarify the question with your interviewer. ASK QUESTIONS! Don't rush into it.</li><li>Understand the problem. Know WHY the answers are correct vs incorrect.</li><li>Approach a Brute Force solution, in THEORY but do not code yet.</li><li>Write some pseudocode for your brute force solution.</li><li>Run through test cases, on your pseudocode to make sure it works. (Time permitting)</li><li>Identify bottlenecks, and optimize as necessary.</li><li>Code the final solution.</li><li>TEST!</li></ol><h3>Testing</h3><p>When testing our solutions, it's always good to think about edge cases to test against. This shows our interviewer our deep knowledge of the underlying data structure, as well as the ability to think outside of the box. Here is my (not so) exhaustive list of testing criteria for arrays and strings.</p><h5>Arrays</h5><ol><li>Nil input value</li><li>Empty array</li><li>Single value in array</li><li>Repeating values in the array</li><li>Large array</li></ol><h5>Strings</h5><ol><li>Nil input value</li><li>Empty string</li><li>Special characters in strings (ie. $%^&amp;#😎😃)</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/posts/arrays</guid><title>Arrays Overview</title><description>Programmers best friend</description><link>https://swiftrefresher.com/posts/arrays</link><pubDate>Thu, 3 Mar 2022 23:15:00 -0500</pubDate><content:encoded><![CDATA[<h1>Arrays</h1><h2>Overview</h2><p>I figured we could start with one of the simplest data structures on our journey. Array's are a swift collection type &amp; they can hold elements of a single type, whether it be Integers, Strings, or Structs/Classes. They are linear collections that are accessible using indexes starting at index Zero.</p><h3>Array's in Memory</h3><p>Swift arrays come in 2 different variations depending on how you initialize them:</p><p>Static arrays are an array implementation in which the size of the array is determined on initialization. Under the hood, the machine will allocate a fixed amount of memory to store this initialized array. Which is nice! But comes at a cost. In order to append values, the machine will copy the entire array over, and allocate new memory space for it + the new value you want to add. This is a linear operation.</p><p>Dynamic arrays are an array implementation that preemptively allocates DOUBLE the memory needed to store the arrays values. Therefore when you want to append a new value, that operation is constant time due to the already free space available to add the value into memory. When all the extra free space is filled up, the array is copied and stored elsewhere. This operation is Amortized constant time, when inserting at the end of the array.</p><h3>Under the hood Swift Implementation</h3><p>When looking through the swift source code on arrays, you will see the underlying implementation of arrays uses Structs. This means arrays are value types, and whenever you copy an array over to a new variable, the value of the array is copied and stored in a new memory address. Any changes to this copied variable will not affect the original array. For example:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">originalArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="kd">var</span> <span class="nv">copyArray</span> <span class="p">=</span> <span class="n">originalArray</span>
<span class="n">copyArray</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="bp">print</span><span class="p">(</span><span class="n">originalArray</span><span class="p">)</span> <span class="c1">// [1, 2, 3]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">copyArray</span><span class="p">)</span> <span class="c1">// [1, 2, 3, 4]</span>
</div></code></pre><p>To be even more efficient, Swift uses copy-on-write optimization for arrays. This means copies of arrays are stored at the same memory address until one of the copies is mutated. Then the array is stored into a new memory address. Keep this in mind when writing efficient code, because in swift copying the array over a bunch is not the time consuming event. The mutation of the copy is what will cost you in Big O time.</p><h3>Big O operations on Arrays</h3><ul><li>Accessing value at an index <strong>O(1)</strong></li><li>Update value at an index <strong>O(1)</strong></li><li>Insert value at beginning <strong>O(n)</strong></li><li>Insert value at middle <strong>O(n)</strong></li><li>Insert value at end:<ul><li>Dynamic arrays: Amortized <strong>O(1)</strong></li><li>Static arrays: <strong>O(n)</strong></li></ul></li></ul><ul><li>Remove value at beginning <strong>O(n)</strong></li><li>Remove value at middle <strong>O(n)</strong></li><li>Remove value at end <strong>O(1)</strong></li><li>Copy array <strong>O(n)</strong></li></ul><h3>Array Declarations</h3><p>Arrays are very easy to declare (dynamic arrays):</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">arrayOne</span> <span class="p">=</span> <span class="p">[</span><span class="nb">String</span><span class="p">]()</span>
<span class="kd">let</span> <span class="nv">arrayTwo</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span>
<span class="kd">let</span> <span class="nv">arrayThree</span> <span class="p">=</span> <span class="p">[</span><span class="n">CustomObjectOne</span><span class="p">,</span> <span class="n">CustomObjectTwo</span><span class="p">]</span>
</div></code></pre><p>The swift compiler does some really cool things under the hood to infer the underlying type based on how you declare the variable.</p><p>You can also determine the size of the array &amp; repeated values of the array on variable declaration like so (static array):</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">arrayFour</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">repearing</span><span class="p">:</span> <span class="s">&quot;Four&quot;</span> <span class="bp">count</span><span class="p">:</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">// [&quot;Four&quot;, &quot;Four&quot;, &quot;Four&quot;, &quot;Four&quot;, &quot;Four&quot;, &quot;Four&quot;]</span>
</div></code></pre><h2>Operations on Arrays</h2><p>Inserting elements in arrays is simple, there are a couple main API's depending on your use case:</p><pre><code><div class="highlight"><span></span><span class="n">arrayFive</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="c1">// at to the end</span>
<span class="n">arrayFive</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">contentsOf</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span> <span class="c1">// add a sequence</span>
<span class="c1">// [1, 2, 8, 0, 7]</span>

<span class="n">arrayFive</span><span class="p">.</span><span class="bp">insert</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">at</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// 0-based index</span>
<span class="c1">// [1, 2, 8, 9, 0, 7]</span>
</div></code></pre><p>Here is how to delete elements in an array:</p><pre><code><div class="highlight"><span></span><span class="n">arrayFive</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span>
<span class="n">arrayFive</span><span class="p">.</span><span class="bp">removeLast</span><span class="p">()</span>
<span class="c1">// [2, 8, 9, 0]</span>

<span class="n">arrayFive</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">at</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> 
<span class="c1">// remove index 0</span>
<span class="c1">// [8, 9, 0]</span>
</div></code></pre><p>By accessing an element on an array you can substitute the value in place:</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="kd">let</span> <span class="nv">element</span> <span class="p">=</span> <span class="n">arrayFive</span><span class="p">.</span><span class="n">firstIndex</span><span class="p">(</span><span class="n">of</span><span class="p">:</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">arrayFive</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="mi">9</span>
<span class="p">}</span>
<span class="c1">// [9, 9, 0]</span>
</div></code></pre><h2>Higher Order Functions</h2><h3>Sort</h3><p>Say you have a collection of elements in the form of an array, and you want to sort these elements by some sort of predicate. The swift collection type comes with the built in sorted by function. This function returns a new array from your desired sorting mechanism. For example:</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="p">(</span><span class="n">Base</span><span class="p">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">Base</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="nb">Bool</span><span class="p">)</span> <span class="kr">rethrows</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">Base</span><span class="p">.</span><span class="n">Element</span><span class="p">]</span> 
</div></code></pre><p>The sorted by function takes a predicate in which you can define how to sort your elements.</p><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">FooStruct</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">value</span><span class="p">:</span> <span class="nb">Int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">nonSortedArray</span> <span class="p">=</span> <span class="p">[</span><span class="n">FooStruct</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="mi">15</span><span class="p">),</span> <span class="n">FooStruct</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">),</span> <span class="n">FooStruct</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="mi">9</span><span class="p">)]</span>
<span class="c1">// Trailing closure notation</span>
<span class="kd">var</span> <span class="nv">sortedArrayOne</span> <span class="p">=</span> <span class="n">nonSortedArray</span><span class="p">.</span><span class="bp">sorted</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="k">in</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">value</span>
<span class="p">}</span>
<span class="c1">// Shorthand notation</span>
<span class="kd">var</span> <span class="nv">sortedArrayTwo</span> <span class="p">=</span> <span class="n">nonSortedArray</span><span class="p">.</span><span class="bp">sorted</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="nv">$1</span><span class="p">.</span><span class="n">value</span> <span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">sortedArrayTwo</span><span class="p">)</span> <span class="c1">// [FooStruct(value: 3), FooStruct(value: 9), FooStruct(value: 15)] </span>
</div></code></pre><h3>Map</h3><p>The main purpose of Map is to iterate on every element in the array, but instead of sorting the elements, you can transform each element based on a closure you pass into it. Here is the underlying implementation:</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">map</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">transform</span><span class="p">:</span> <span class="p">(</span><span class="kc">Self</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">T</span><span class="p">)</span> <span class="kr">rethrows</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span>
</div></code></pre><p>Given the return type of the map function is T, we can pass in one type of array, and return a different type of array. For example taking in an array of numbers, mapping over them, and returning that array represented in String form.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">newArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="bp">map</span> <span class="p">{</span> <span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span>
    <span class="k">return</span> <span class="nb">String</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="p">}</span>
</div></code></pre><h3>Filter</h3><p>You can specify a filter in the form of a closure, and you can filter an array given your criteria.</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">filter</span><span class="p">(</span><span class="kc">_</span> <span class="n">isIncluded</span><span class="p">:</span> <span class="p">@</span><span class="n">escaping</span> <span class="p">(</span><span class="kc">Self</span><span class="p">.</span><span class="n">Elements</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">LazyFilterSequence</span><span class="p">&lt;</span><span class="kc">Self</span><span class="p">.</span><span class="n">Elements</span><span class="p">&gt;</span>
</div></code></pre><p>For example lets get all numbers from our array that are greater than 1.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">filteredArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="bp">map</span><span class="p">{</span> <span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">1</span>
<span class="p">}</span>
</div></code></pre><h3>Reduce</h3><p>This function allows us to combine all the elements in a collection, and return a unified common (and also generic) type!</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">reduce</span><span class="p">&lt;</span><span class="n">Result</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">initialResult</span><span class="p">:</span> <span class="n">Result</span><span class="p">,</span> <span class="kc">_</span> <span class="n">nextPartialResult</span><span class="p">:</span> <span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="n">Bound</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">Result</span><span class="p">)</span> <span class="kr">rethrows</span> <span class="p">-&gt;</span> <span class="n">Result</span>
</div></code></pre><p>Let's say we want to take all of our numbers in an array, and combine them into a single long String.</p><pre><code><div class="highlight"><span></span><span class="c1">// Long version</span>
<span class="kd">let</span> <span class="nv">reduced</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">].</span><span class="bp">reduce</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{(</span><span class="n">result</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="k">in</span> 
    <span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="nb">String</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Inline version</span>
<span class="kd">let</span> <span class="nv">reduced</span> <span class="p">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">].</span><span class="bp">reduce</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">+</span> <span class="nb">String</span><span class="p">(</span><span class="nv">$1</span><span class="p">)</span> <span class="p">}</span>
</div></code></pre><h3>FlatMap</h3><p>This takes in a closure and applies this closure to every element in the array. It returns the flattened sequence post traversal.</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">flatMap</span><span class="p">&lt;</span><span class="n">SegmentOfResult</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">transform</span><span class="p">:</span> <span class="p">((</span><span class="n">key</span><span class="p">:</span> <span class="n">Key</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Value</span><span class="p">))</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">SegmentOfResult</span><span class="p">)</span> <span class="kr">rethrows</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">SegmentOfResult</span><span class="p">.</span><span class="n">Element</span><span class="p">]</span> <span class="k">where</span> <span class="n">SegmentOfResult</span> <span class="p">:</span> <span class="n">Sequence</span>
</div></code></pre><p>Remember that map can return a different array type than was traversed upon. But with FlatMap we can transform, and then flatten. Typically this function is used in sequences of sequences.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">strings</span> <span class="p">=</span> <span class="p">[[</span><span class="s">&quot;Hello&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s">&quot;GoodBye&quot;</span><span class="p">]]</span>
<span class="kd">let</span> <span class="nv">finalStrings</span> <span class="p">=</span> <span class="n">strings</span><span class="p">.</span><span class="n">flatMap</span><span class="p">({</span> <span class="nv">$0</span> <span class="p">})</span>
<span class="bp">print</span><span class="p">(</span><span class="n">finalStrings</span><span class="p">)</span> <span class="c1">// [&quot;Hello transformed&quot;, &quot;Goodbye transformed&quot;]</span>
</div></code></pre><h3>CompactMap</h3><p>This function is frequently used with sequences that contain optionals. It is a safe way to traverse an array, and safely unwrap the value, and return the new sequence</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">compactMap</span><span class="p">&lt;</span><span class="n">ElementOfResult</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">transform</span><span class="p">:</span> <span class="p">(</span><span class="n">Base</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">ElementOfResult</span><span class="p">?)</span> <span class="kr">rethrows</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">ElementOfResult</span><span class="p">]</span>
</div></code></pre><p>For example:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">optionals</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">?]</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">finalOptionals</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]</span> <span class="p">=</span> <span class="n">optionals</span><span class="p">.</span><span class="n">compactMap</span><span class="p">({</span> <span class="nv">$0</span> <span class="p">})</span>
<span class="bp">print</span><span class="p">(</span><span class="n">finalOptionals</span><span class="p">)</span> <span class="c1">// [1, 6, 7]</span>
</div></code></pre><h2>Array Slicing</h2><p>Slicing arrays, and getting specific ranges of arrays in swift can be slightly tricky as opposed to other programming languages.</p><h3>Ranges</h3><p>Starting in Swift 5, you can use the subscript of an arrays range, to get specific parts of an array. You use the swift built in Range type for this.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">test</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">test2</span> <span class="p">=</span> <span class="n">test</span><span class="p">[</span><span class="mf">0.</span><span class="p">.&lt;</span><span class="mi">2</span><span class="p">]</span> <span class="c1">// Give us the indices from the first array 0 up to, but not including the 2nd zero based index.</span>
<span class="bp">print</span><span class="p">(</span><span class="n">test2</span><span class="p">)</span> <span class="c1">// [3, 2]</span>

<span class="kd">let</span> <span class="nv">nums</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">99</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">nums2</span> <span class="p">=</span> <span class="n">nums</span><span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="mi">5</span><span class="p">]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span> <span class="c1">// [10, 3, 4, 2, 11, 14]</span>
</div></code></pre><h3>Prefix/Suffix</h3><p>There are also built in swift functions for getting the beginning and end sections of an array. All you need to do is pass the X number of prefixed or suffixed values you want from the array as a parameter in the function. Prefix is for the first X values from the array, and suffix is for the last X values you want from the array.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">longNums</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">88</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">312</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">firstThree</span> <span class="p">=</span> <span class="n">longNums</span><span class="p">.</span><span class="kr">prefix</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">lastThree</span> <span class="p">=</span> <span class="n">longNums</span><span class="p">.</span><span class="bp">suffix</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="bp">print</span><span class="p">(</span><span class="n">firstThree</span><span class="p">)</span> <span class="c1">// [10, 3, 2]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">lastThree</span><span class="p">)</span> <span class="c1">// [99, 100, 312]</span>
</div></code></pre><h2>Conclusion</h2><p>And thats it! You are now a Swift Array master, so give yourself a pat on the back. Coming soon we will be taking the arrays, and giving some real life application in Leetcode Problems. We will go over common tips &amp; tricks you will encounter in Leetcode array problems. Stay Tuned!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/posts/about</guid><title>About</title><description>A little about myself 😄</description><link>https://swiftrefresher.com/posts/about</link><pubDate>Thu, 3 Mar 2022 22:15:00 -0500</pubDate><content:encoded><![CDATA[<h2>Welcome!</h2><p>Hello everyone! My name is Alex Stevens, and I decided to do what a million other people have already done. Start a Swift blog. I feel this will be a good way to advance my iOS domain knowledge, as well as serve as a point of reference for future job interviews. I plan to cover all aspects of iOS Development from Computer Science algorithms, to App Extensions, to SwiftUI/Combine. I hope everyone joins me in on this journey, and I hope this will be a good resource to any iOS Engineer out there, no matter what part of your journey you are on. From a new grad, or a seasoned engineer looking to crack into the mobile development space, welcome! --Alex</p>]]></content:encoded></item></channel></rss>