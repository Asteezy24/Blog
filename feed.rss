<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Swift Refresher</title><description>Keeping you up to date on the latest developments in the world of Swift &amp; iOS programming!</description><link>https://swiftrefresher.com</link><language>en</language><lastBuildDate>Fri, 27 Jan 2023 11:36:27 -0500</lastBuildDate><pubDate>Fri, 27 Jan 2023 11:36:27 -0500</pubDate><ttl>250</ttl><atom:link href="https://swiftrefresher.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://swiftrefresher.com/leetcode/blind-75-trees</guid><title>Blind 75: Trees</title><description>Everything you need to know about Trees</description><link>https://swiftrefresher.com/leetcode/blind-75-trees</link><pubDate>Mon, 24 Oct 2022 08:02:00 -0400</pubDate><content:encoded><![CDATA[<h1>Intro</h1><p>A tree is a data structure that consists of nodes, with values and pointers to child nodes, which recursively form subtrees. Lets understand the structure of a Tree. Trees have a root node, and each node has 0 or more child nodes. Trees cannot contain cycles -- that is, Trees are top down and a node cannot reference anything above itself. Typically, tree questions are riddled with ambiguity and incorrect assumptions. Be careful! Always clarify with your interviewer all the details of the question.</p><p>The path from the root node to the leaf node is known as a 'branch'. A trees height, is the length of its longest branch. The depth of a tree, is the distance of root to node level.</p><p>You can think of trees like graphs that are acyclic, connected, directed, with an explicit root node, and all nodes have a single parent.</p><h3>Types of Trees</h3><ul><li>Binary Tree<ul><li>A binary tree is when each node has up to 2 children nodes. Not all trees are considered Binary trees</li><li>A node is called a "leaf" when it has no children nodes attached to itself</li></ul></li></ul><ul><li>Binary Search Tree<ul><li>A binary search tree is when every node fits into an ordering system. When all left descendants ≤ the current node value ≤ all right descendants</li><li>Some binary search trees may or may not have duplicate values. <strong>Clarify this</strong>!</li></ul></li></ul><ul><li>Balanced Tree<ul><li>A balanced tree is when left and right subtrees are the same size</li></ul></li></ul><ul><li>Complete Binary Tree<ul><li>A complete binary tree is when every level of the tree is filled from left to right</li></ul></li></ul><ul><li>Full Binary Tree<ul><li>A full binary tree is when every node has 0 or 2 children -- aka there are no nodes with only 1 child node</li></ul></li></ul><ul><li>Perfect Binary Tree<ul><li>A perfect binary tree is when the tree is both full and complete. All leaf nodes are at the same level, and this level has the maximum amount of nodes</li><li>Perfect trees have 2ᵏ-1 nodes, where k is the number of levels in a tree</li><li>Never assume a tree is perfect in an interview!</li></ul></li></ul><h3>Binary Tree Traversals</h3><p>There are 3 main methods of traversing a binary tree: in-order traversal, pre-order traversal, and post-order traversal. In a pre-order traversal, we arrive at the root node first, then traverse the left side, then the right side. In post-order traversal, we traverse the left side, then the right side, then the root node. And finally in in-order traversal we traverse the left side, then the root node, then the right side. An easy way to think of these is the in reference to the root node. The order in which we traverse depends on when we visit the root node. For example, post-order traversal has us visit the root node last (or post-everything else).</p><h3>Binary Heaps</h3><p>A min heap is a complete binary tree, where each node is smaller than its children. The root node is the minimum of the entire structure. A max heap is the same rules but vice versa -- the root node is the maximum &amp; nodes are larger than its children.</p><p>We should take a look at some operations on a min/max heap:</p><ul><li>When we insert into a heap, we insert the new value at the bottom - right most spot to maintain the completeness of the tree. Then we will fix the tree by swapping the new element with its parent until we find the correct spot. All-in-all this will take O(logN) time.</li><li>Extracting the min/max element is easy. We remove the root node, and swap with the last element. Then we bubble down the new element until it is in place. Swap as we go down. All-in-all this will take O(logN) time.</li></ul><h3>Tries</h3><p>Tries (or prefix tree) is a variant of a n-ary tree in which characters are stored at each node. Each path down the tree represents a word. Tries are most commonly used to store entire english language for quick prefix lookups. Hash Tables are fast, but cannot tell us valid prefixes of words.</p><hr><h1>Invert Binary Tree</h1><p>The worlds most popular tree problem!! Time to dive in.</p><img src="https://swiftrefresher.com/invertbinarytree.png"/><p>So as you will find with most Tree problems, we can solve this recursively or iteratively. Lets go over both, but keep in mind! We lose some space efficiency when we go with a recursive solution.</p><h3>[ Recursive ]</h3><h3>[ O(n) worst time + O(n) space ]</h3><p>So at first glance, the recursive solution would actually be pretty easy. When I solve recursive problems, I start at the base case, and build out from there. In this problem, our base case is if the root node is nil, we should return nil in our function. Another base case is if the root has no children, we just return the root. After that, it is about swapping the left and right side.</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">input</span> <span class="k">is</span> <span class="kc">nil</span> <span class="k">return</span> <span class="kc">nil</span>
<span class="bp">swap</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">of</span> <span class="n">the</span> <span class="n">root</span>
<span class="k">return</span> <span class="n">the</span> <span class="n">root</span>
</div></code></pre><p>As we discussed earlier, the space complexity here, is O(n) where n is the number of nodes in the call stack. We know at every level, we will need to recurse the left and right nodes to swap them. The time complexity here is O(k) where K represents the number of nodes in the tree. We know we need to swap all of them at least once.<br><br><br>The final code is pretty simple:</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">root</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
<span class="kd">let</span> <span class="nv">left</span> <span class="p">=</span> <span class="n">invertTree</span><span class="p">(</span><span class="n">root</span><span class="p">?.</span><span class="kr">left</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">right</span> <span class="p">=</span> <span class="n">invertTree</span><span class="p">(</span><span class="n">root</span><span class="p">?.</span><span class="kr">right</span><span class="p">)</span>
<span class="n">root</span><span class="p">?.</span><span class="kr">left</span> <span class="p">=</span> <span class="kr">right</span>
<span class="n">root</span><span class="p">?.</span><span class="kr">right</span> <span class="p">=</span> <span class="kr">left</span>
<span class="k">return</span> <span class="n">root</span>
</div></code></pre><h3>[ Iterative with a Queue (BFS) ]</h3><h3>[ O(n) worst time + O(n) space ]</h3><p>We can use Breadth-First search for an iterative solution. In Swift, a Queue is really just an array, where we utilize the <strong>removeFirst()</strong> function on sequences to simulate array removal. First we want to add the root node to our array. While our queue is not empty, its safe to assume we have more nodes to visit, and to invert. At every step, we will remove the first element from our queue, and invert it. It follows very similar logic to our recursive solution, we just have another data structure involved.</p><pre><code><div class="highlight"><span></span><span class="n">create</span> <span class="n">a</span> <span class="n">queue</span>
<span class="n">add</span> <span class="n">root</span> <span class="n">to</span> <span class="n">queue</span>
<span class="k">while</span> <span class="n">queue</span> <span class="k">is</span> <span class="n">not</span> <span class="n">empty</span>
    <span class="n">pop</span> <span class="bp">first</span> <span class="n">element</span> <span class="k">in</span> <span class="n">queue</span>
    <span class="n">invert</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> 
    <span class="n">add</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span>
</div></code></pre><p>The time complexity here once again is O(N) because we need to visit every node to invert it. Our space complexity is lightened due to the lack of recursive call stack, but we lose that efficiency by introducing a Queue that grows with every node we have added to it. This on average comes out to be O(n) as well.</p><p>Here is the final implementation:</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nv">queue</span> <span class="p">=</span> <span class="p">[</span><span class="n">TreeNode</span><span class="p">?]()</span>
<span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

<span class="k">while</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">node</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">node</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">continue</span> <span class="p">}</span>
    <span class="kd">let</span> <span class="nv">left</span> <span class="p">=</span> <span class="n">node</span><span class="p">?.</span><span class="kr">left</span>
    <span class="kd">let</span> <span class="nv">right</span> <span class="p">=</span> <span class="n">node</span><span class="p">?.</span><span class="kr">right</span>
    <span class="n">node</span><span class="p">?.</span><span class="kr">left</span> <span class="p">=</span> <span class="kr">right</span>
    <span class="n">node</span><span class="p">?.</span><span class="kr">right</span> <span class="p">=</span> <span class="kr">left</span>
    
    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">?.</span><span class="kr">left</span><span class="p">)</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">?.</span><span class="kr">right</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">root</span>
</div></code></pre><hr><h1>Maximum Depth of Binary Tree</h1><p>Building upon our previous knowledge, we are presented with the following:</p><img src="https://swiftrefresher.com/maximumdepthofbinarytree.png"/><p>Not too bad! This too, can be solved iteratively or recursively.</p><h3>[ Recursive ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>The idea behind the recursive solution, is very similar to the "Invert Binary Tree" problem we saw earlier. We want to traverse every node, and at each level, we want to keep track of the depth at any given moment. For example, if we have a tree with 1 parent node and 2 children nodes, the maximum depth will be whichever side (left or right) has a larger depth.</p><p>Solving for the base case first, the base case is if the root node is nil, we return a depth of 0. Ultimately we want to append 1 to every level node we are at, and append 1 to the current depth. Something like this:</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">root</span> <span class="k">is</span> <span class="kc">nil</span> <span class="k">return</span> <span class="mi">0</span>
<span class="kr">get</span> <span class="n">depth</span> <span class="n">of</span> <span class="kr">left</span><span class="p">,</span> <span class="n">recursively</span>
<span class="kr">get</span> <span class="n">depth</span> <span class="n">of</span> <span class="kr">right</span><span class="p">,</span> <span class="n">recursively</span> 
<span class="kr">get</span> <span class="n">the</span> <span class="bp">max</span> <span class="n">of</span> <span class="kr">left</span> <span class="n">vs</span> <span class="kr">right</span>
<span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">the</span> <span class="n">maximum</span> <span class="n">side</span>
</div></code></pre><p>The time complexity here is pretty simple. We traverse all nodes, both left and right. So the time complexity is O(n) where n is the number of nodes in the tree. The space complexity would be constant, except we need to keep track of the call stack for all the recursive calls. So in this case the space complexity is O(n) where n is the number of nodes in the call stack.</p><p>The real implementation is pretty simple, like so:</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">root</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>
<span class="kd">let</span> <span class="nv">left</span> <span class="p">=</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">?.</span><span class="kr">left</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">right</span> <span class="p">=</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">?.</span><span class="kr">right</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">maxi</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="kr">left</span><span class="p">,</span> <span class="kr">right</span><span class="p">)</span>
<span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">maxi</span> 
</div></code></pre><p>But now for the real test...the iterative solution!</p><h3>[ Iterative with a Stack (BFS) ]</h3><h3>[ O(n) worst time + O(n) space ]</h3><p>This is very similar to the invert binary tree problem, except our queue structure will be a little different. We want to, at each queue node, hold the depth of our tree node &amp; the node itself. For example, if I have a tree with a root node of (3), our queue will hold this node as a tuple of (3, 1) where 1 is the depth of the node at the given time. Other than that, we essentially have the same problem as the invert binary tree.</p><pre><code><div class="highlight"><span></span><span class="n">create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">of</span> <span class="n">tuples</span>
<span class="n">append</span> <span class="n">the</span> <span class="n">root</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span>
<span class="k">while</span> <span class="n">the</span> <span class="n">queue</span> <span class="k">is</span> <span class="n">not</span> <span class="n">empty</span>
    <span class="n">remove</span> <span class="bp">first</span> <span class="n">node</span> <span class="n">item</span> <span class="n">from</span> <span class="n">the</span> <span class="n">queue</span>
    <span class="n">update</span> <span class="n">global</span> <span class="bp">max</span> <span class="n">from</span> <span class="n">our</span> <span class="n">queue</span> <span class="n">value</span>
    <span class="k">if</span> <span class="n">there</span> <span class="k">is</span> <span class="n">a</span> <span class="kr">left</span> <span class="n">value</span> <span class="k">for</span> <span class="n">our</span> <span class="n">queue</span> <span class="n">node</span>
        <span class="n">add</span> <span class="n">the</span> <span class="kr">left</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">and</span> <span class="n">append</span> <span class="n">the</span> <span class="n">depth</span> <span class="n">by</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">there</span> <span class="k">is</span> <span class="n">a</span> <span class="kr">right</span> <span class="n">value</span> <span class="k">for</span> <span class="n">our</span> <span class="n">queue</span> <span class="n">node</span>
        <span class="n">add</span> <span class="n">the</span> <span class="kr">right</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">and</span> <span class="n">append</span> <span class="n">the</span> <span class="n">depth</span> <span class="n">by</span> <span class="mi">1</span>
        
<span class="k">return</span> <span class="n">the</span> <span class="n">global</span> <span class="bp">max</span>
</div></code></pre><p>Nothing much has changed here in terms of time complexity, as we still need to visit every single node in the tree. This comes out to O(n) time, and meanwhile our space complexity is lightened due to the lack of recursive call stack, but we lose that efficiency by introducing a Queue that grows with every node we have added to it. This on average comes out to be O(n) as well.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nv">queue</span> <span class="p">=</span> <span class="p">[(</span><span class="n">TreeNode</span><span class="p">?,</span> <span class="nb">Int</span><span class="p">)]()</span>
<span class="kd">var</span> <span class="nv">globalMax</span> <span class="p">=</span> <span class="mi">0</span>
<span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="k">while</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span>
    <span class="n">globalMax</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">globalMax</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">left</span> <span class="p">=</span> <span class="n">node</span><span class="p">?.</span><span class="kr">left</span> <span class="p">{</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="kr">left</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">}</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">right</span> <span class="p">=</span> <span class="n">node</span><span class="p">?.</span><span class="kr">right</span> <span class="p">{</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="kr">right</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">globalMax</span>
</div></code></pre><p>Woohoo!</p><hr><h1>Same Tree</h1><p>Building upon our previous knowledge, we are presented with the following:</p><img src="https://swiftrefresher.com/sametree.png"/><p>And you probably guessed it! We need to traverse our 2 input trees similar to the other problems. We can go about this recursively with DFS or using BFS and a queue</p><h3>[ Recursive ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>So the trick here is, if we go with a recursive solution, we need to cover all base cases. Since there are 2 trees, and every node on the tree has a chance to be nullable, we need to really think about this.</p><p>The base cases that come to mind, are:</p><ol><li>If both of the root nodes are null, return true as they are equal</li><li>If ONE of the root nodes is null, return false, as one is null and one is not, representing inequality</li><li>If the values of the nodes is not equal, then return false, as the nodes are not the same.</li></ol><p>Other than that, it is business as usual! We need to recurse left, and recurse right. As long as the left and right subtrees are equal, we have the same tree!</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">both</span> <span class="n">p</span> <span class="n">and</span> <span class="n">q</span> <span class="n">are</span> <span class="n">null</span> <span class="k">return</span> <span class="kc">true</span>
<span class="k">if</span> <span class="n">either</span> <span class="n">p</span> <span class="n">or</span> <span class="n">q</span> <span class="k">is</span> <span class="n">null</span> <span class="k">return</span> <span class="kc">false</span>
<span class="k">if</span> <span class="n">p</span> <span class="n">value</span> <span class="n">does</span> <span class="n">not</span> <span class="bp">equal</span> <span class="n">q</span> <span class="n">value</span> <span class="k">return</span> <span class="kc">false</span> 

<span class="n">recurse</span> <span class="kr">left</span>
<span class="n">recurse</span> <span class="kr">right</span>

<span class="k">if</span> <span class="kr">left</span> <span class="k">is</span> <span class="n">valid</span> <span class="n">AND</span> <span class="kr">right</span> <span class="k">is</span> <span class="n">valid</span><span class="p">,</span> <span class="k">return</span> <span class="kc">true</span>
</div></code></pre><p>The time complexity here is pretty simple: O(n) where n is equal to the number of nodes in the larger tree. We will need to visit every node in both so our time is limited to the larger tree. The space complexity here is O(n) where...you guessed it...n is equal to the recursive call stack! Same as the others.</p><p>Final product is like so:</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">p</span> <span class="p">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="n">q</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span> <span class="c1">// if both are nil </span>
<span class="k">if</span> <span class="n">p</span> <span class="p">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="n">q</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span> <span class="c1">// if one is nil</span>
<span class="k">if</span> <span class="n">p</span><span class="p">!.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">q</span><span class="p">!.</span><span class="n">val</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span> <span class="c1">// not equal values</span>
<span class="kd">let</span> <span class="nv">isLeftValid</span> <span class="p">=</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="p">!.</span><span class="kr">left</span><span class="p">,</span> <span class="n">q</span><span class="p">!.</span><span class="kr">left</span><span class="p">)</span> <span class="c1">// recurse left</span>
<span class="kd">let</span> <span class="nv">isRightValid</span> <span class="p">=</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="p">!.</span><span class="kr">right</span><span class="p">,</span> <span class="n">q</span><span class="p">!.</span><span class="kr">right</span><span class="p">)</span> <span class="c1">// recurse right</span>
<span class="k">return</span> <span class="n">isLeftValid</span> <span class="o">&amp;&amp;</span> <span class="n">isRightValid</span> <span class="c1">// return left and right are simultaneously valid </span>
</div></code></pre><h3>[ Iterative with a Queue (BFS) ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>So just like our other problems, to eliminate recursion we can introduce a new data structure to traverse the tree. We still need to keep our base cases in check though, as when we remove elements from the queue, we will make sure they follow our earlier rules</p><pre><code><div class="highlight"><span></span><span class="n">add</span> <span class="n">p</span> <span class="n">and</span> <span class="n">q</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span>
<span class="k">while</span> <span class="n">the</span> <span class="n">queue</span> <span class="k">is</span> <span class="n">not</span> <span class="n">empty</span> 
    <span class="n">remove</span> <span class="bp">first</span> <span class="n">from</span> <span class="n">queue</span> <span class="n">representing</span> <span class="n">p</span>
    <span class="n">remove</span> <span class="bp">first</span> <span class="n">from</span> <span class="n">queue</span> <span class="n">representing</span> <span class="n">q</span>
    <span class="n">check</span> <span class="n">our</span> <span class="n">bases</span> <span class="n">cases</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">the</span> <span class="n">values</span> <span class="n">are</span> <span class="n">not</span> <span class="bp">equal</span><span class="p">,</span> <span class="n">or</span> <span class="n">only</span> <span class="n">ONE</span> <span class="k">is</span> <span class="kc">nil</span> <span class="k">return</span> <span class="kc">false</span>
    <span class="n">add</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">of</span> <span class="n">each</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span>
</div></code></pre><p>The time complexity is O(n) where n is equal to the number of nodes in the larger tree. We stil need to visit every node in both trees so the time is constrained to the larger tree. And the introduction of the queue keeps our space complexity here at O(n) where n is the number of nodes in the queue at any given time. For the final implementation:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">p</span> <span class="p">=</span> <span class="n">p</span>
<span class="kd">var</span> <span class="nv">q</span> <span class="p">=</span> <span class="n">q</span>
<span class="kd">var</span> <span class="nv">queue</span> <span class="p">=</span> <span class="p">[</span><span class="n">p</span> <span class="p">,</span><span class="n">q</span><span class="p">]</span>

<span class="k">while</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span>
    <span class="n">p</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span>
    <span class="n">q</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">p</span> <span class="p">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="n">q</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span><span class="k">continue</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">p</span> <span class="p">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="n">q</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span><span class="k">return</span> <span class="kc">false</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">p</span><span class="p">!.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">q</span><span class="p">!.</span><span class="n">val</span> <span class="p">{</span><span class="k">return</span> <span class="kc">false</span><span class="p">}</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">!.</span><span class="kr">left</span><span class="p">)</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">q</span><span class="p">!.</span><span class="kr">left</span><span class="p">)</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">!.</span><span class="kr">right</span><span class="p">)</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">q</span><span class="p">!.</span><span class="kr">right</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">return</span> <span class="kc">true</span>
</div></code></pre><hr><h1>Subtree of Another Tree</h1><p>Time to continue our tree journey with another example!</p><img src="https://swiftrefresher.com/subtreeofanothertree.png"/><p>Just like every other problem we have encountered, we can solve this recursively or iteratively using BFS/DFS!</p><h3>[ Recursive ]</h3><h3>[ O(n · m) time + O(n + m) space ]</h3><p>To make this problem a little easier, we can break out the "is same tree" functionality into its own function. This makes it unit testable, as well as easier to read from a code perspective. Once we break out this out into another function, it makes our problem much easier. We can traverse our root tree using DFS &amp; if our current root at a given time is equal to the subroot, we can return true. Since this is a recursive function, if somewhere on the left or right of our tree, we have a subtree, we can return true.</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">root</span> <span class="k">is</span> <span class="kc">nil</span> <span class="k">return</span> <span class="kc">false</span>
<span class="k">is</span> <span class="n">current</span> <span class="n">root</span> <span class="o">&amp;</span> <span class="n">subroot</span> <span class="n">are</span> <span class="n">the</span> <span class="n">same</span> <span class="k">return</span> <span class="kc">true</span>
<span class="n">recurse</span> <span class="kr">left</span>
<span class="n">recurse</span> <span class="kr">right</span>
<span class="k">return</span> <span class="kr">left</span> <span class="n">OR</span> <span class="kr">right</span> <span class="kc">true</span>
</div></code></pre><p>The time complexity for our solution here is a little complex. Checking if a root &amp; subroot are the same tree, requires us to traverse every node of our subtree &amp; root tree. This is M · N where M is the number of nodes in the root tree, and N is the number of nodes in the subtree. We need to traverse our entire tree M, and at every step we traverse our N subtree looking for a similarity. This comes out to O(M·N) time complexity. The space complexity here is O(n + m) where N is the number of calls in the stack for traversing our root node in a dfs fashion. At every recursive call, we call our "is same tree" function, so M is representative of the number of "is same tree" function calls in the stack. This evens out to O(n + m) space.</p><p>The final implementation comes out to the following:</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">isSubtree</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?,</span> <span class="kc">_</span> <span class="n">subRoot</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">dfs</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?,</span> <span class="kc">_</span> <span class="n">subRoot</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">root</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span>
    <span class="kd">let</span> <span class="nv">left</span> <span class="p">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">?.</span><span class="kr">left</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">right</span> <span class="p">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">?.</span><span class="kr">right</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span>
    <span class="k">return</span> <span class="kr">left</span> <span class="o">||</span> <span class="kr">right</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="kc">_</span> <span class="n">one</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?,</span> <span class="kc">_</span> <span class="n">two</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">one</span> <span class="p">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="n">two</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">one</span> <span class="p">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="n">two</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">one</span><span class="p">?.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">two</span><span class="p">?.</span><span class="n">val</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="kd">let</span> <span class="nv">isLeftValid</span> <span class="p">=</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">one</span><span class="p">?.</span><span class="kr">left</span><span class="p">,</span> <span class="n">two</span><span class="p">?.</span><span class="kr">left</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">isRightValid</span> <span class="p">=</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">one</span><span class="p">?.</span><span class="kr">right</span><span class="p">,</span> <span class="n">two</span><span class="p">?.</span><span class="kr">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">isLeftValid</span> <span class="o">&amp;&amp;</span> <span class="n">isRightValid</span>
<span class="p">}</span>
</div></code></pre><h3>[ Iterative with a Queue (BFS) ]</h3><h3>[ O(n + m) time + O(n + m) space ]</h3><p>The idea here is the exact same as other iterative BFS problems. We need to use a queue and pop nodes off of the queue to perform our checking logic.</p><pre><code><div class="highlight"><span></span><span class="n">add</span> <span class="n">root</span> <span class="n">and</span> <span class="n">subroot</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span>
<span class="k">while</span> <span class="n">the</span> <span class="n">queue</span> <span class="k">is</span> <span class="n">not</span> <span class="n">empty</span> 
    <span class="n">remove</span> <span class="bp">first</span> <span class="n">from</span> <span class="n">queue</span> <span class="n">representing</span> <span class="n">root</span>
    <span class="n">remove</span> <span class="bp">first</span> <span class="n">from</span> <span class="n">queue</span> <span class="n">representing</span> <span class="n">subroot</span>
    <span class="k">if</span> <span class="n">root</span> <span class="n">and</span> <span class="n">subroot</span> <span class="n">are</span> <span class="n">same</span> <span class="n">tree</span> <span class="k">return</span> <span class="kc">true</span>
    <span class="n">add</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">of</span> <span class="n">each</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span>
<span class="k">return</span> <span class="kc">false</span>
</div></code></pre><p>Space complexity as we know is O(n + m). N is representative of the space of our queue at any given moment, where m is the number of "is same tree" function calls. Time complexity is once again, O(n + m) for the reasons stated above.</p><p>Here is the final implementation:</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">isSubtree</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?,</span> <span class="kc">_</span> <span class="n">subRoot</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">bfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">bfs</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?,</span> <span class="kc">_</span> <span class="n">subRoot</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="kd">var</span> <span class="nv">queue</span> <span class="p">=</span> <span class="p">[</span><span class="n">TreeNode</span><span class="p">?]()</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

    <span class="k">while</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">node</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">node</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">continue</span> <span class="p">}</span>
        <span class="k">if</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">?.</span><span class="kr">left</span><span class="p">)</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">?.</span><span class="kr">right</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="kc">_</span> <span class="n">one</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?,</span> <span class="kc">_</span> <span class="n">two</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">one</span> <span class="p">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="n">two</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">one</span> <span class="p">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="n">two</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">one</span><span class="p">?.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">two</span><span class="p">?.</span><span class="n">val</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="kd">let</span> <span class="nv">isLeftValid</span> <span class="p">=</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">one</span><span class="p">?.</span><span class="kr">left</span><span class="p">,</span> <span class="n">two</span><span class="p">?.</span><span class="kr">left</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">isRightValid</span> <span class="p">=</span> <span class="n">isSameTree</span><span class="p">(</span><span class="n">one</span><span class="p">?.</span><span class="kr">right</span><span class="p">,</span> <span class="n">two</span><span class="p">?.</span><span class="kr">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">isLeftValid</span> <span class="o">&amp;&amp;</span> <span class="n">isRightValid</span>
<span class="p">}</span>
</div></code></pre><hr><h1>Lowest Common Ancestor of a Binary Search Tree</h1><p>Turn up the heat a little!</p><img src="https://swiftrefresher.com/lcaofbinarysearchtree.png"/><p>To start here we should revisit the definition of a Binary Search Tree..."A binary search tree is when every node fits into an ordering system. When all left descendants ≤ the current node value ≤ all right descendants". When you see a BST being stated in the problem statement, we should know to use the BST characteristics to our advantage. We should immediately think to compare the children node values to the root value, and vice versa.</p><h3>[ Recursive ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>For our problem at hand we should check P and Qs value relative to the root. If both P and Q are greater than the root, we should repeat our search in the right half of the tree. If both P and Q are less than the root, we should repeat our search in the left half of the tree. And if neither of those cases are true, we should return our root node, because we cannot go any deeper in the tree.</p><p>This is fairly straight forward, but what about the edge cases where either P or Q is equal to the root node? Well this should not change much in our case. This is because since either P or Q is equal to the root, we know neither the left or right subtrees would contain the value we are searching for.</p><p>Here is a high level implementation:</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">P</span> <span class="n">and</span> <span class="n">Q</span> <span class="n">are</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">root</span>
    <span class="n">search</span> <span class="kr">right</span> <span class="n">subtree</span>
<span class="k">if</span> <span class="n">P</span> <span class="n">and</span> <span class="n">Q</span> <span class="n">are</span> <span class="n">less</span> <span class="n">than</span> <span class="n">root</span>
    <span class="n">search</span> <span class="kr">left</span> <span class="n">subtree</span>
<span class="k">else</span>
    <span class="k">return</span> <span class="n">root</span>
</div></code></pre><p>The space complexity here is O(n) where N is the number of recursive calls on the call stack at any given time, this should be roughly equal to the height of the Tree. The time complexity is roughly equal to the number of nodes in the tree, and this is because at the worst case, we need to traverse down to the bottom of the entire tree through every node...O(n). This time complexity assumes the tree is not balanced.<br><br>The final implementation is as follows:</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">p</span> <span class="p">=</span> <span class="n">p</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">q</span> <span class="p">=</span> <span class="n">q</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
<span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">.</span><span class="n">val</span> <span class="p">{</span> <span class="c1">// search right</span>
    <span class="k">return</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">right</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">.</span><span class="n">val</span> <span class="p">{</span> <span class="c1">// search left</span>
    <span class="k">return</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">left</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">root</span>
<span class="p">}</span>
</div></code></pre><h3>[ Iterative ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>The iterative solution follows the same pattern as the recursive, without the recursion.</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">a</span> <span class="n">current</span> <span class="n">node</span> <span class="n">to</span> <span class="n">traverse</span> <span class="n">the</span> <span class="n">tree</span>
<span class="k">while</span> <span class="n">the</span> <span class="n">current</span> <span class="k">is</span> <span class="n">not</span> <span class="kc">nil</span>
    <span class="k">if</span> <span class="n">P</span> <span class="n">and</span> <span class="n">Q</span> <span class="n">are</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">root</span>
        <span class="n">assign</span> <span class="n">current</span> <span class="n">to</span> <span class="kr">right</span> <span class="n">node</span>
    <span class="k">if</span> <span class="n">P</span> <span class="n">and</span> <span class="n">Q</span> <span class="n">are</span> <span class="n">less</span> <span class="n">than</span> <span class="n">root</span>
        <span class="n">assign</span> <span class="n">current</span> <span class="n">to</span> <span class="kr">left</span> <span class="n">node</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">root</span>
<span class="k">return</span> <span class="n">current</span>
</div></code></pre><p>The space complexity here is obviously improved without the recursion. This equates out to O(1) space. The time complexity is O(n) because we need to possibly traverse every node in the entire tree. If the tree is balanced though this would be an O(logN) time complexity.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">first</span> <span class="p">=</span> <span class="n">p</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">second</span> <span class="p">=</span> <span class="n">q</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nv">current</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?</span> <span class="p">=</span> <span class="n">root</span>
<span class="k">while</span> <span class="kd">let</span> <span class="nv">node</span> <span class="p">=</span> <span class="n">current</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="bp">first</span><span class="p">.</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">second</span><span class="p">.</span><span class="n">val</span> <span class="p">{</span>
        <span class="n">current</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="kr">right</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="bp">first</span><span class="p">.</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">second</span><span class="p">.</span><span class="n">val</span> <span class="p">{</span>
        <span class="n">current</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="kr">left</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">current</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">current</span>
</div></code></pre><p>Keep it rolling!</p><hr><h1>Binary Tree Level Order Traversal</h1><p>Lets take a peek at the next tree challenge</p><img src="https://swiftrefresher.com/binarytreelevelordertraversal.png"/><p>If this problem looks familiar...its because it is! We have had some tree problems in the past where we traverse the tree with BFS (Breadth First Search). And this problem is eerily similar! We just have a slight wrinkle on what we should be doing at any given tree level.</p><h3>[ BFS with Extra Loop ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>The idea here is, we use a queue like we would any other BFS tree traversal. But the difference is, while our queue is not empty, we want to keep a count of how big our queue is. While the queue has a count greater than or equal to zero, we want to pop values, and add child values to the queue. After we have popped values from the queue all the way until the queue is empty, we know we have traversed a level, and we can add the traversed values to our return array.</p><p>It is important to emphasize, the trick here is keep tracking of how big the queue is at every level, with its own variable.</p><p>We should note that the problem is asking for a LEVEL order traversal, aka root, left, and then right.</p><pre><code><div class="highlight"><span></span><span class="n">create</span> <span class="n">queue</span>
<span class="n">add</span> <span class="n">root</span> <span class="n">to</span> <span class="n">queue</span>

<span class="k">while</span> <span class="n">queue</span> <span class="k">is</span> <span class="n">not</span> <span class="n">empty</span>
    <span class="kr">get</span> <span class="n">length</span> <span class="n">of</span> <span class="n">current</span> <span class="n">queue</span>
    <span class="n">create</span> <span class="n">an</span> <span class="n">array</span> <span class="n">to</span> <span class="n">track</span> <span class="n">this</span> <span class="n">level</span>
    <span class="k">for</span> <span class="n">element</span> <span class="k">in</span> <span class="n">length</span> <span class="n">of</span> <span class="n">queue</span>
        <span class="n">remove</span> <span class="bp">first</span> <span class="n">value</span> <span class="n">from</span> <span class="n">queue</span>
        <span class="n">add</span> <span class="n">value</span> <span class="n">to</span> <span class="n">this</span> <span class="n">level</span> <span class="n">array</span>
        <span class="n">add</span> <span class="kr">left</span> <span class="n">child</span> <span class="n">to</span> <span class="n">queue</span>
        <span class="n">add</span> <span class="kr">right</span> <span class="n">child</span> <span class="n">to</span> <span class="n">queue</span>
    <span class="n">add</span> <span class="n">this</span> <span class="n">level</span> <span class="n">array</span> <span class="n">to</span> <span class="k">return</span> <span class="n">value</span>
    
<span class="k">return</span> <span class="n">nested</span> <span class="n">array</span> <span class="n">we</span> <span class="n">created</span>
</div></code></pre><p>The space complexity here is O(n) because of the queue data structure we are using. In a Binary tree we can have at most O(₁/₂n) values on it at any given time. The time complexity here is O(n) because we will only ever visit each node one time.</p><p>Here is the final implementation!</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[]</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nv">result</span> <span class="p">=</span> <span class="p">[[</span><span class="nb">Int</span><span class="p">]]()</span>
<span class="kd">var</span> <span class="nv">queue</span><span class="p">:</span> <span class="p">[</span><span class="n">TreeNode</span><span class="p">?]</span> <span class="p">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>

<span class="k">while</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">count</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="kd">var</span> <span class="nv">currentIterativeArray</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]()</span>
     <span class="k">while</span> <span class="bp">count</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
       <span class="k">if</span> <span class="kd">let</span> <span class="nv">node</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span> <span class="p">{</span>
           <span class="n">currentIterativeArray</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
           <span class="bp">count</span> <span class="o">-=</span> <span class="mi">1</span>
           <span class="k">if</span> <span class="kd">let</span> <span class="nv">left</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="kr">left</span> <span class="p">{</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="kr">left</span><span class="p">)</span> <span class="p">}</span>
           <span class="k">if</span> <span class="kd">let</span> <span class="nv">right</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="kr">right</span> <span class="p">{</span> <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="kr">right</span><span class="p">)</span> <span class="p">}</span>
       <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentIterativeArray</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">result</span>
</div></code></pre><p>Like I said in the beginning, it is a pretty straight forward BFS with a little wrinkle!</p><hr><h1>Validate Binary Search Tree</h1><p>Now this one is a little tricky...</p><img src="https://swiftrefresher.com/validatebinarysearchtree.png"/><p>Lets make sure we are reading the problem correctly! The first thing to call out is the definition of a BST. The left subtree of a node must be less than the root node. NOT less than or equal to, only less than. Same thing with the right side, the right subtree must be greater than the node. Also, pay attention to the wording, if a node is on the left side of the top most root, it must be less than the value of the root. It does not matter if the node is 4 levels down from the top. If it is on the left side of the tree, then we should ensure its value is less than the root node value.</p><h3>[ DFS with Comparison ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>So typically when validating a binary tree we would use DFS. But this time its a little different, and that is because of the BST definition, we can compare a roots value to its left and right value, but that does not help us as we get further and further down the tree. We lose track of the root node value.</p><p>So the trick here is to recognize what we are doing at each node and each level. Say we have a tree with a topmost root node value of 5. We know for this to be valid, 5 must be less than -∞ and greater than ∞. Next lets say the topmost node value of 5, has a left side child of 3. For this 3 to be a valid node, we know 3 must be less than -∞ BUT greater than 5. Consider 5 has a right child node of 7. 7 must be greater than 5, but less than ∞.</p><p>The point here being, we need to make a comparison at each node. When we recursively travel through our tree, we need to just send the comparison values down the call stack. When recursing left, we know the minimum should be the current minimum, but the maximum should be the root node value (parent). Vice versa with the right side. Something like this:</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">node</span> <span class="k">is</span> <span class="kc">nil</span> <span class="k">return</span> <span class="kc">true</span>
<span class="k">if</span> <span class="n">our</span> <span class="n">node</span> <span class="k">is</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">the</span> <span class="n">minimum</span> <span class="n">value</span><span class="p">,</span> <span class="n">or</span><span class="p">,</span> <span class="n">the</span> <span class="n">node</span> <span class="k">is</span> <span class="n">less</span> <span class="n">than</span> <span class="n">the</span> <span class="n">maximum</span> <span class="n">value</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="k">return</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">subtrees</span> <span class="n">are</span> <span class="n">valid</span><span class="p">,</span> <span class="k">while</span> <span class="n">passing</span> <span class="n">the</span> <span class="n">new</span> <span class="bp">min</span> <span class="o">&amp;</span> <span class="bp">max</span> <span class="n">values</span>
</div></code></pre><p>The time complexity here is pretty straightforward as we need to visit every node here once. The comparison itself is constant time, but the time comes out to O(n) where n is the number of nodes in the tree. The space complexity here as we have seen is O(n), due to the recursive nature of the solution. We need to host at most n number of recursive calls when we traverse the tree. N in this case stands for the height of the tree, which evens out to O(n) time.</p><p>The final implementation is as follows:</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">isBst</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="bp">min</span><span class="p">:</span> <span class="nb">Int</span><span class="p">.</span><span class="bp">min</span><span class="p">,</span> <span class="bp">max</span><span class="p">:</span> <span class="nb">Int</span><span class="p">.</span><span class="bp">max</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kd">func</span> <span class="nf">isBst</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?,</span> <span class="bp">min</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="bp">max</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="bp">min</span> <span class="o">||</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="bp">max</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">isBst</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">left</span><span class="p">,</span> <span class="bp">min</span><span class="p">:</span> <span class="bp">min</span><span class="p">,</span> <span class="bp">max</span><span class="p">:</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isBst</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">right</span><span class="p">,</span> <span class="bp">min</span><span class="p">:</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="bp">max</span><span class="p">:</span> <span class="bp">max</span><span class="p">)</span>
<span class="p">}</span>
</div></code></pre><p>We just need to be careful on this one! Do not blindly implement DFS, make sure we are understanding the problem.</p><hr><h1>Kth Smallest Element in a BST</h1><p>Keep chugging along!</p><img src="https://swiftrefresher.com/kthsmallestinbst.png"/><p>So here we have another BST problem. We should make sure we remember that a BST is a tree where all elements on the left side of the tree are less than the root, and all elements in the right subtree are greater than the root. Also we should remember how we normally traverse trees in general, here we will be using DFS.</p><h3>[ DFS inorder traversal ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>So we should consider the smart way to go about this. If we remember, Inorder traversal is when we visit the entire left side, then the root, then the right subtree. If we do an Inorder traversal on a BST, and we store the elements in an array as we visit them, we will end up with an array of all the nodes in order from smallest to largest!</p><p>This will make our lives a lot easier, if we want to find the kth-smallest element (1 indexed) we can then just return the kth - 1 element in our array we have created.</p><pre><code><div class="highlight"><span></span><span class="n">build</span> <span class="n">our</span> <span class="n">list</span>
<span class="k">return</span> <span class="n">the</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span> <span class="n">element</span> <span class="n">of</span> <span class="n">the</span> <span class="n">list</span>


<span class="n">build</span> <span class="n">list</span> <span class="n">function</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">root</span> <span class="k">is</span> <span class="kc">nil</span><span class="p">,</span> <span class="k">return</span> <span class="n">empty</span> <span class="n">array</span>
    <span class="n">add</span> <span class="n">root</span> <span class="n">value</span> <span class="n">to</span> <span class="n">new</span> <span class="n">list</span>
    <span class="n">recurse</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">get</span> <span class="kr">left</span> <span class="n">array</span>
    <span class="n">recurse</span> <span class="kr">right</span> <span class="n">and</span> <span class="kr">get</span> <span class="kr">right</span> <span class="n">array</span>
    <span class="k">return</span> <span class="kr">left</span> <span class="n">array</span> <span class="o">+</span> <span class="n">root</span> <span class="n">array</span> <span class="o">+</span> <span class="kr">right</span> <span class="n">array</span>
</div></code></pre><p>The time complexity here is O(n) where n is the number of nodes in the tree, we need to visit every node once to build the array. Arrays offer constant time lookup when accessing a value, so we can ignore the time complexity there. The space complexity is O(n) because we are building an array where the size of the array is how many nodes are in the tree. We are also recursively traversing the tree, so we need O(n) at most calls in the recursive call stack. This will even out to O(n) on average.</p><p>Here is the final implementation!</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">kthSmallest</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?,</span> <span class="kc">_</span> <span class="n">k</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="kd">var</span> <span class="nv">list</span> <span class="p">=</span> <span class="n">buildList</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">list</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> 
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">buildList</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[]</span> <span class="p">}</span>
    <span class="kd">var</span> <span class="nv">list</span> <span class="p">=</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span>
    <span class="kd">let</span> <span class="nv">left</span> <span class="p">=</span> <span class="n">buildList</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">left</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">right</span> <span class="p">=</span> <span class="n">buildList</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="kr">left</span> <span class="o">+</span> <span class="n">list</span> <span class="o">+</span> <span class="kr">right</span>
<span class="p">}</span>
</div></code></pre><p>Easy!</p><h3>[ BFS with a Stack ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>I think it would also be intelligent here to mention, we do not always have to traverse the tree using DFS, we can of course use BFS with a Stack like structure. It carries very similar logic to our DFS logic, but we save ourselves from the recursion. We will go as far left in our tree as possible and find the smallest value. After that, we will pop the parent and traverse right. All the while we need to keep a count of the values rankings. Every time we pop a value from the stack, we can decrement our K value count.</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">iterativeStack</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?,</span> <span class="kc">_</span> <span class="n">k</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">stack</span> <span class="p">=</span> <span class="p">[</span><span class="n">TreeNode</span><span class="p">]()</span>
    <span class="kd">var</span> <span class="nv">count</span> <span class="p">=</span> <span class="n">k</span>
    <span class="kd">var</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span>
    
    <span class="c1">// Go as far left as we can</span>
    <span class="k">while</span> <span class="n">root</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">!)</span>
        <span class="n">root</span> <span class="p">=</span> <span class="n">root</span><span class="p">?.</span><span class="kr">left</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="bp">count</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">node</span> <span class="p">=</span> <span class="n">stack</span><span class="p">.</span><span class="bp">removeLast</span><span class="p">()</span>
        <span class="bp">count</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">count</span> <span class="p">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// When our K value count is now at 0, we know we have found the right value. </span>
            <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
        <span class="p">}</span>
        <span class="kd">var</span> <span class="nv">rightNode</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="kr">right</span>
        <span class="k">while</span> <span class="n">rightNode</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">rightNode</span><span class="p">!)</span>
            <span class="n">rightNode</span> <span class="p">=</span> <span class="n">rightNode</span><span class="p">?.</span><span class="kr">left</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</div></code></pre><p>Nice!</p><hr><h1>Construct Binary Tree from Preorder and Inorder Traversal</h1><p>Hope you remembered how to traverse a tree! This one is all about testing your inner tree knowledge.</p><img src="https://swiftrefresher.com/constructbinarytreefrompreorderinorder.png"/><p>In concept this is a straight forward problem, it just takes a little creativity arriving at the solution. We will be using DFS for this problem, which means recursion.</p><h3>[ DFS recursive build ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>Lets think about what preorder traversal means. Preorder traversal is arriving at the root first, then left subtree, then right subtree. This means in our example problem, our preorder array is [3,9,20,15,7], and the first element of this array is 3. Thus we know our root of our entire tree is 3. Cool. Now what?</p><p>Now lets think about inorder traversal. Inorder traversal is arriving at the left node first, then the root node, then the right now. So taking what we know from preorder traversal, we know our root is 3. If we find the value of 3 in our inorder traversal array, we can partition the array to know which values are in the left and right subtrees. For example, our inorder array is [9,3,15,20,7]. By finding the root value of 3, we can split our array up into 2 parts. We now know that the left subtree consists of [9]. While the right subtree consists of [15, 20, 7]. What next?</p><p>This pivot point I will refer to as "Mid". In our above example, our midpoint is 3. There is a "gotcha" to this problem as well. We should be careful when there is no left subtree to populate, that is when we should move on to the right subtree. If this midpoint has an index of 0, its time to move on to the right side. Lets see an example. If our preorder array is [7, 10]. And our inorder array is [7, 10]. Our midpoint here would be 7. We can see our midpoint in our inorder array has a midpoint of 0. This is because there is nothing to add to the left subtree and we should move on!</p><p>We can recursively repeat this process for our left and right subtrees, excluding values we do not need. So to find the right subtree for 3 for example, our preorder array would be [20, 15, 7]. Our inorder array will be [15, 20, 7]. Rinse and repeat!</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">either</span> <span class="n">inorder</span> <span class="n">or</span> <span class="n">preorder</span> <span class="k">is</span> <span class="n">empty</span><span class="p">,</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">(</span><span class="n">base</span> <span class="k">case</span><span class="p">)</span>

<span class="n">create</span> <span class="n">root</span> <span class="n">node</span> <span class="n">from</span> <span class="n">preorder</span> <span class="n">arrays</span> <span class="bp">first</span> <span class="n">value</span>
<span class="bp">find</span> <span class="n">midpoint</span> <span class="k">in</span> <span class="n">inorder</span> <span class="n">array</span>

<span class="bp">find</span> <span class="kr">left</span> <span class="n">of</span> <span class="n">root</span> <span class="n">by</span> <span class="n">recursing</span> <span class="kr">left</span> <span class="n">subtree</span>
<span class="bp">find</span> <span class="kr">right</span> <span class="n">of</span> <span class="n">root</span> <span class="n">by</span> <span class="n">recursing</span> <span class="kr">right</span> <span class="n">subtree</span>

<span class="k">return</span> <span class="n">root</span>
</div></code></pre><p>Given this is a recursive solution, the space complexity here is O(n) where n is the height of the call stack at any given time. The time complexity here is O(n) worst case, where the biggest time constraint is finding the midpoint in the inorder array. We may have to search the entire array to find it. Time to implement!</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">preorder</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="o">||</span> <span class="n">inorder</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nv">rootNode</span> <span class="p">=</span>  <span class="n">TreeNode</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">mid</span> <span class="p">=</span> <span class="n">inorder</span><span class="p">.</span><span class="n">firstIndex</span><span class="p">(</span><span class="n">of</span><span class="p">:</span> <span class="n">rootNode</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">mid</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// if we have a left side to populate</span>
        <span class="kd">let</span> <span class="nv">leftPreorder</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mf">1.</span><span class="p">..</span><span class="n">mid</span><span class="p">])</span>
        <span class="kd">let</span> <span class="nv">leftInorder</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">inorder</span><span class="p">[</span><span class="mf">0.</span><span class="p">.&lt;</span><span class="n">mid</span><span class="p">])</span>
        <span class="n">rootNode</span><span class="p">.</span><span class="kr">left</span> <span class="p">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">leftPreorder</span><span class="p">,</span> <span class="n">leftInorder</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nv">rightPreorder</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="n">mid</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">.&lt;</span><span class="n">preorder</span><span class="p">.</span><span class="bp">count</span><span class="p">])</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">rightPreorder</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">rightInorder</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">inorder</span><span class="p">[</span><span class="n">mid</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">.&lt;</span><span class="n">inorder</span><span class="p">.</span><span class="bp">count</span><span class="p">])</span>
                <span class="bp">print</span><span class="p">(</span><span class="n">rightInorder</span><span class="p">)</span>

    <span class="n">rootNode</span><span class="p">.</span><span class="kr">right</span> <span class="p">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">rightPreorder</span><span class="p">,</span> <span class="n">rightInorder</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">rootNode</span>
</div></code></pre><p>Almost done!</p><hr><h1>Binary Tree Maximum Path Sum</h1><p>And now we enter the hard realm 👀</p><img src="https://swiftrefresher.com/binarytreemaxpathsum.png"/><p>This is an decently solvable hard leetcode problem, we just need to remember our tree fundamentals when it comes to DFS.</p><h3>[ DFS recursion w/ optimization ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>I think for this problem, understanding what the problem is asking is of the most importance. A path, in this case, is the ability to split the path of a node only once. And by this I mean, say we have a tree with a root of 1, and children of 2 and 3. We can only split our path once at the topmost root node of 1. We cannot say, go from 1 to 2, then back to 1, then to 3. We only split once. In the case where we are in a subtree and we have already split, we should be choosing the left or right path that is greater.</p><p>Also, some of the nodes may be negative. So this should affect the decision we are making when its time to choose a path. If we have to split between left and right, and one direction gives us a negative value, we should avoid it. It is possible negative values are a part of our path, we should just be methodical about when to use them.</p><p>So lets think about how we would go about solving this. I think at first it should be pretty clear that we will be recursively using DFS to eliminate repeated work. We want to, at each node in our tree, figure out if splitting at the current node and combining the left and right subtrees is greater, or if we have already split what is the maximum path using either the left OR right subtree.</p><p>Thinking recursively lets start with a base case. If the root of our tree is nil, we should return a max path of zero. Easy. We will then recurse left and right. We need to determine if the left max path is less than 0. If it is, we should not use this value as it will not optimize our path. Nice.</p><p>For this problem, we should be keeping a global max path variable, this keeps our code clean when determining the max path of the entire structure. At every iteration we should determine which is bigger: the current global max path sum, or splitting at the current node. Splitting at the current node can be represented as root + left max + right max.</p><p>Now lets assume we have already split earlier in our traversal, and we are deep into our tree structure. In this case, for our subtree we should just be returning what the maximum unidirectional path is to our parent. In this case we will just add the root to the maximum of the left vs right subtrees. Slightly different. Recapping all of that, some pseudocode looks like this:</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">root</span> <span class="k">is</span> <span class="kc">nil</span> <span class="k">return</span> <span class="mi">0</span>

<span class="n">keep</span> <span class="n">global</span> <span class="bp">max</span> <span class="n">path</span> <span class="n">sum</span><span class="p">,</span> <span class="n">starting</span> <span class="n">value</span> <span class="k">is</span> <span class="n">our</span> <span class="n">root</span> <span class="n">value</span>


<span class="kr">get</span> <span class="kr">left</span> <span class="n">value</span> <span class="n">by</span> <span class="n">recursing</span>
<span class="kr">get</span> <span class="kr">right</span> <span class="n">value</span> <span class="n">by</span> <span class="n">recursing</span>
<span class="k">if</span> <span class="kr">left</span> <span class="n">value</span> <span class="k">is</span> <span class="n">less</span> <span class="n">than</span> <span class="n">zero</span><span class="p">,</span> <span class="n">use</span> <span class="mi">0</span> <span class="n">instead</span>
<span class="k">if</span> <span class="kr">right</span> <span class="n">value</span> <span class="k">is</span> <span class="n">less</span> <span class="n">than</span> <span class="n">zero</span><span class="p">,</span> <span class="n">use</span> <span class="mi">0</span> <span class="n">instead</span>

<span class="n">update</span> <span class="n">global</span> <span class="bp">max</span> <span class="n">with</span> <span class="n">whichever</span> <span class="k">is</span> <span class="n">greater</span><span class="p">:</span> <span class="n">the</span> <span class="n">global</span> <span class="bp">max</span><span class="p">,</span> <span class="n">or</span> <span class="k">if</span> <span class="n">we</span> <span class="bp">split</span> <span class="n">at</span> <span class="n">this</span> <span class="n">present</span> <span class="n">node</span><span class="p">.</span> <span class="n">root</span> <span class="o">+</span> <span class="kr">left</span> <span class="o">+</span> <span class="kr">right</span>

<span class="k">return</span> <span class="n">to</span> <span class="n">our</span> <span class="n">parent</span><span class="p">,</span> <span class="n">assuming</span> <span class="n">we</span> <span class="n">already</span> <span class="bp">split</span><span class="p">.</span> <span class="n">root</span> <span class="o">+</span> <span class="bp">max</span> <span class="n">of</span> <span class="kr">left</span> <span class="n">vs</span> <span class="kr">right</span>
</div></code></pre><p>Due to the recursion, the space complexity here is O(n) where n represents the maximum size of the call stack at any given time. This is also equal to the height of the tree. If it is a balanced tree then the space complexity is O(logn). The time complexity here is O(n) because we need to visit every node in the tree only once.</p><p>And finally here is the implementation:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">result</span> <span class="p">=</span> <span class="n">root</span><span class="p">!.</span><span class="n">val</span>

<span class="kd">func</span> <span class="nf">recurse</span><span class="p">(</span><span class="kc">_</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="kd">let</span> <span class="nv">left</span> <span class="p">=</span> <span class="n">recurse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">left</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">right</span> <span class="p">=</span> <span class="n">recurse</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">right</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">leftMax</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="kr">left</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">rightMax</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="kr">right</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">result</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">leftMax</span> <span class="o">+</span> <span class="n">rightMax</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="bp">max</span><span class="p">(</span><span class="n">leftMax</span><span class="p">,</span> <span class="n">rightMax</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">recurse</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
</div></code></pre><p>Only one more to go!</p><hr><h1>Serialize and Deserialize Binary Tree</h1><p>and here we are, the final problem in our tree journey. Lets dive in!</p><img src="https://swiftrefresher.com/serializedeserializetree.png"/><p>I think to start, we need to break this problem down into 2 parts, the serialization and the deserialization. And, as with most tree problems, we can use either BFS or DFS to solve this. I will be going over both for posterity 😎</p><p>No matter if you use BFS or DFS, the idea behind a solution is the same. We know to serialize we want to make the tree into a string. Lets say we have a tree where the root is 1, and it has children of 2 &amp; 3. If we use DFS, the string will be "1, 2, nil, nil, 3, nil, nil". We will want to add all children of nodes, even if they are nil. We want to also add the differentiator between nil and non nil nodes. This is because we need to know in DFS when to move on from the left subtree and go to the right subtree. In this case we used "nil" but you can use anything you want like "null", "next" or even "🔥". We also want to comma separate our values so we know if a value in the string is "12" meaning 1 node of value 12, or 2 values with the values of "1" &amp; "2".</p><p>Using this same logic our string for a BFS solution would be "1, 2, 3, nil, nil, nil, nil", due to the nature of BFS we are looking at the tree on a level by level basis.</p><h2>Serialization</h2><h3>[ DFS recursive string creation ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>For DFS, we know we will be recursively traveling down the tree until we reach our base case to end our recursion. We will also be traveling the left and right subtrees from our root. This solution is pretty straight forward. If we find a nil root, we will be adding "nil" to our string. Else we need to add subtree strings to our root.</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">a</span> <span class="n">global</span> <span class="k">return</span> <span class="n">string</span>

<span class="k">if</span> <span class="n">root</span> <span class="k">is</span> <span class="kc">nil</span> 
    <span class="k">return</span> <span class="n">string</span> <span class="o">+=</span> <span class="s">&quot;nil,&quot;</span>
    <span class="k">break</span> <span class="n">from</span> <span class="n">recursion</span>
<span class="k">return</span> <span class="n">string</span> <span class="o">+=</span> <span class="n">root</span> <span class="n">value</span> <span class="o">+</span> <span class="s">&quot;,&quot;</span>
<span class="k">return</span> <span class="n">string</span> <span class="o">+=</span> <span class="kr">left</span> <span class="n">subtree</span> <span class="n">recursed</span>
<span class="k">return</span> <span class="n">string</span> <span class="o">+=</span> <span class="kr">right</span> <span class="n">subtree</span> <span class="n">recursed</span>
</div></code></pre><p>Space complexity here is O(n) where n is the height of the tree, and the max size of the call stack at any given time. We have to visit every node and at each iteration we are doing constant addition, so the time complexity is O(n) where n is the# of nodes in a tree.</p><p>Something like this:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">result</span> <span class="p">=</span> <span class="s">&quot;&quot;</span>

<span class="k">guard</span> <span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">root</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;null,&quot;</span>
    <span class="k">return</span> 
<span class="p">}</span>
<span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="si">\(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="si">)</span><span class="s">,&quot;</span>
<span class="n">result</span> <span class="o">+=</span> <span class="n">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">left</span><span class="p">)</span>
<span class="n">result</span> <span class="o">+=</span> <span class="n">serialize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="kr">right</span><span class="p">)</span>

<span class="k">return</span> <span class="n">result</span>
</div></code></pre><h3>[ BFS Queue string creation ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>As is usually the case with BFS, its a little more complicated due to the use of a Queue, but still not too bad. Here we will be keeping an array of values, and at the end, manually do the comma separation. This is just to give a different look at the problem.</p><p>First we will add the root of our tree to the queue. Then while the queue is not empty, we will add non nil values to our values array. If we find a nil value, we will add "nil" to our values array. For every node we pop we will add its children to the queue regardless of optionality. Like this:</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">a</span> <span class="n">queue</span>
<span class="n">keep</span> <span class="n">a</span> <span class="n">list</span> <span class="n">of</span> <span class="n">values</span>

<span class="k">while</span> <span class="n">queue</span> <span class="k">is</span> <span class="n">not</span> <span class="n">empty</span>
    <span class="n">pop</span> <span class="bp">first</span> <span class="n">from</span> <span class="n">queue</span>
    <span class="n">add</span> <span class="n">node</span> <span class="n">to</span> <span class="n">values</span> <span class="n">array</span>
    <span class="n">add</span> <span class="kr">left</span> <span class="n">child</span> <span class="n">to</span> <span class="n">queue</span>
    <span class="n">add</span> <span class="kr">right</span> <span class="n">child</span> <span class="n">to</span> <span class="n">queue</span>
    <span class="k">if</span> <span class="n">node</span> <span class="k">is</span> <span class="kc">nil</span> <span class="n">add</span> <span class="s">&quot;nil&quot;</span> <span class="n">to</span> <span class="n">values</span> <span class="n">array</span>
    
<span class="k">return</span> <span class="n">values</span> <span class="n">array</span><span class="p">,</span> <span class="n">but</span> <span class="n">comma</span> <span class="n">separated</span>
</div></code></pre><p>Space complexity here is O(2n) which evens out to O(n) due to the queue we need to keep track of our nodes. We will always add nodes to our queue for every node (and child node) we have. This evens out to O(n) time complexity.</p><p>Here is the final implementation:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">vals</span> <span class="p">=</span> <span class="p">[</span><span class="nb">String</span><span class="p">]()</span>
<span class="kd">var</span> <span class="nv">queue</span><span class="p">:</span> <span class="p">[</span><span class="n">TreeNode</span><span class="p">?]</span> <span class="p">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>

<span class="k">while</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">node</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">vals</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;</span><span class="si">\(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="kr">left</span><span class="p">)</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="kr">right</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">vals</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;nil&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">vals</span><span class="p">.</span><span class="n">joined</span><span class="p">(</span><span class="n">separator</span><span class="p">:</span> <span class="s">&quot;,&quot;</span><span class="p">)</span>
</div></code></pre><p>Ok we are serialized and good to go!</p><h2>Deserialization</h2><h3>[ DFS recursive ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>The idea here is the same with serializing DFS. But we just want to be careful when we approach a nil value. A simple way to get around this is using Swifts Int initializer. If we pass "2" into the initializer, Swift will give us 2. If we try to pass "nil", the initializer will conveniently fail.</p><pre><code><div class="highlight"><span></span><span class="n">separate</span> <span class="n">our</span> <span class="n">string</span> <span class="n">into</span> <span class="n">a</span> <span class="n">comma</span> <span class="n">separated</span> <span class="n">array</span>

<span class="n">pop</span> <span class="n">the</span> <span class="bp">first</span> <span class="n">from</span> <span class="n">the</span> <span class="n">array</span>
<span class="k">try</span> <span class="n">to</span> <span class="n">convert</span> <span class="n">the</span> <span class="n">value</span> <span class="n">into</span> <span class="n">an</span> <span class="nb">Int</span>
    <span class="k">if</span> <span class="n">it</span> <span class="n">fails</span><span class="p">,</span> <span class="k">return</span> <span class="kc">nil</span>

<span class="n">create</span> <span class="n">a</span> <span class="n">new</span> <span class="n">root</span> <span class="n">node</span>
<span class="n">node</span><span class="p">.</span><span class="kr">left</span> <span class="k">is</span> <span class="bp">equal</span> <span class="n">to</span> <span class="n">the</span> <span class="n">recursive</span> <span class="kr">left</span> <span class="n">subtree</span>
<span class="n">node</span><span class="p">.</span><span class="kr">right</span> <span class="k">is</span> <span class="bp">equal</span> <span class="n">to</span> <span class="n">the</span> <span class="n">recursive</span> <span class="kr">right</span> <span class="n">subtree</span>
<span class="k">return</span> <span class="n">new</span> <span class="n">root</span> <span class="n">node</span>
</div></code></pre><p>Same as always, space is the call stack size O(n). Time complexity is O(n) which is roughly the number of nodes in the tree. This is how we would go about DFS deserialization:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">val</span> <span class="p">=</span> <span class="n">nodes</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span>
<span class="k">guard</span> <span class="kd">let</span> <span class="nv">valInt</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>

<span class="kd">let</span> <span class="nv">node</span> <span class="p">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">valInt</span><span class="p">)</span>
<span class="n">node</span><span class="p">.</span><span class="kr">left</span> <span class="p">=</span> <span class="n">deseralize_DFS</span><span class="p">(&amp;</span><span class="n">nodes</span><span class="p">)</span>
<span class="n">node</span><span class="p">.</span><span class="kr">right</span> <span class="p">=</span> <span class="n">deseralize_DFS</span><span class="p">(&amp;</span><span class="n">nodes</span><span class="p">)</span>
<span class="k">return</span> <span class="n">node</span>
</div></code></pre><h3>[ BFS queue ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>This one is a bit more complicated, by using BFS deserialization. Like DFS, we will want to convert our string into a comma separated array. We should attempt to keep a pointer in our array, so we know where in our values we are iteration on. Per usual we will create a queue and add our root to it. While the queue is not empty, we will pop nodes from the queue. BUT after we pop, we need to look at our values array. If the value is not nil only then will we add the left child node to our queue. Same with the right side. Every time we check the values array we want to move our pointer by 1 spot.</p><pre><code><div class="highlight"><span></span><span class="n">separate</span> <span class="n">string</span> <span class="n">into</span> <span class="n">comma</span> <span class="n">separated</span> <span class="n">array</span>
<span class="n">create</span> <span class="n">queue</span> <span class="n">with</span> <span class="n">a</span> <span class="n">new</span> <span class="n">root</span> <span class="n">node</span> <span class="n">we</span> <span class="n">create</span>

<span class="k">while</span> <span class="n">the</span> <span class="n">queue</span> <span class="k">is</span> <span class="n">not</span> <span class="n">empty</span>
    <span class="n">remove</span> <span class="n">queue</span> <span class="n">from</span> <span class="n">node</span>
    <span class="k">if</span> <span class="n">values</span> <span class="n">pointer</span> <span class="k">is</span> <span class="n">not</span> <span class="n">a</span> <span class="kc">nil</span> <span class="n">value</span>
        <span class="n">node</span><span class="p">.</span><span class="kr">left</span> <span class="k">is</span> <span class="n">a</span> <span class="n">newly</span> <span class="n">created</span> <span class="n">node</span> <span class="n">from</span> <span class="n">values</span> <span class="n">array</span>
        <span class="n">add</span> <span class="n">this</span> <span class="n">new</span> <span class="n">node</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span>
    <span class="n">move</span> <span class="n">values</span> <span class="n">pointer</span> <span class="n">by</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">values</span> <span class="n">pointer</span> <span class="k">is</span> <span class="n">not</span> <span class="n">a</span> <span class="kc">nil</span> <span class="n">value</span>
        <span class="n">node</span><span class="p">.</span><span class="kr">right</span> <span class="k">is</span> <span class="n">a</span> <span class="n">newly</span> <span class="n">created</span> <span class="n">node</span> <span class="n">from</span> <span class="n">values</span> <span class="n">array</span>
        <span class="n">add</span> <span class="n">this</span> <span class="n">new</span> <span class="n">node</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span>
    <span class="n">move</span> <span class="n">values</span> <span class="n">pointer</span> <span class="n">by</span> <span class="mi">1</span>

<span class="k">return</span> <span class="n">new</span> <span class="n">root</span>
</div></code></pre><p>Space complexity here is O(n) due to the queue we need to keep track of our nodes. We will always add nodes to our queue for every node (and child node) we have. This evens out to O(n) time complexity. Value comparison and assignment is always constant time.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">data</span> <span class="o">!=</span> <span class="s">&quot;nil&quot;</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
<span class="kd">let</span> <span class="nv">vals</span> <span class="p">=</span> <span class="n">data</span>
    <span class="p">.</span><span class="bp">split</span><span class="p">(</span><span class="n">separator</span><span class="p">:</span> <span class="s">&quot;,&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nb">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">let</span> <span class="nv">root</span> <span class="p">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">Int</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">!</span><span class="p">)</span>
<span class="kd">var</span> <span class="nv">queue</span> <span class="p">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>

<span class="kd">var</span> <span class="nv">idx</span> <span class="p">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">node</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">vals</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;nil&quot;</span> <span class="p">{</span>
        <span class="n">node</span><span class="p">.</span><span class="kr">left</span> <span class="p">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">Int</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">!</span><span class="p">)</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="kr">left</span><span class="p">!)</span>
    <span class="p">}</span>
    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">vals</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;nil&quot;</span> <span class="p">{</span>
        <span class="n">node</span><span class="p">.</span><span class="kr">right</span> <span class="p">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">Int</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">!</span><span class="p">)</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="kr">right</span><span class="p">!)</span>
    <span class="p">}</span>
    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">root</span>
</div></code></pre><p>Well done!!!! Trees problems should be a breeze now!!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/ios-fundamentals/dependency-management</guid><title>iOS Dependency Management</title><description>Manage your libraries like a pro!</description><link>https://swiftrefresher.com/ios-fundamentals/dependency-management</link><pubDate>Tue, 18 Oct 2022 20:53:00 -0400</pubDate><content:encoded><![CDATA[<h1>iOS Dependency Management</h1><h2>Overview</h2><p>In 2022, the majority of large-scale production apps use 3rd party libraries. Companies want to ship new features, and do not want to re-invent the wheel when it comes to common things like animations, networking, or even some common views apple may not give us. 3rd party libraries are everywhere! But as your app grows, it can get pretty nasty dealing with all the different libraries, and keeping the versions in line with your dependency tree. Another big advantage of dependency managers is backwards compatibility. If a framework updates its code, you can still support older versions of the framework without having to change anything in your project.</p><p>With some open source frameworks you could statically import all the code/dependency versions you need by hand, but that is unneeded work! The iOS ecosystem has evolved enough to give us several ways of managing our 3rd party dependencies in our app. Let's take a look at how to set up each one, and the pros/cons of each.</p><h3>Semantic Versioning</h3><p>I would be remiss to not mention <a href="https://semver.org/">semantic versioning</a> here. All of the dependency managers here will likely use some type of semantic versioning when it comes to listing the dependencies of our project. The versions of dependencies are defined by MAJOR, MINOR, and PATCH versioning numbers in the form of 1.2.3 . As you can guess, big code changes are MAJOR, medium code changes are MINOR, and small fixes are patches. Using semantic versioning, we can define greater than, less than, equal to, compatible with, etc versions for 3rd party libraries!</p><h3>CocoaPods</h3><p>Feel free to visit the <a href="https://cocoapods.org/">cocoapods website</a> if you want to learn about all the different pods that are available for iOS.</p><p>If you do not have cocoapods installed on your machine, feel free to run the following command in terminal:</p><pre><code><div class="highlight"><span></span><span class="n">sudo</span> <span class="n">gem</span> <span class="n">install</span> <span class="n">cocoapods</span> <span class="o">&amp;&amp;</span> <span class="n">pod</span> <span class="n">setup</span> <span class="o">--</span><span class="n">verbose</span>
</div></code></pre><p>This will install cocoapods on your machine. Next you will want to <strong>cd</strong> into the directory where your xcode project lives, and run:</p><pre><code><div class="highlight"><span></span><span class="n">touch</span> <span class="n">Podfile</span>
</div></code></pre><p>Which will create a Podfile for your project. A Podfile just describes the dependencies of the targets of one or more Xcode projects. Next you will want to open up the Podfile with your favorite text editor and tell the Podfile you want to use frameworks for your project. It should look like this:</p><pre><code><div class="highlight"><span></span><span class="n">platform</span> <span class="p">:</span><span class="n">ios</span><span class="p">,</span> <span class="err">&#39;</span><span class="mf">16.0</span><span class="err">&#39;</span>

<span class="n">target</span> <span class="err">&#39;</span><span class="p">&lt;</span><span class="n">Your</span> <span class="n">Target</span><span class="p">&gt;</span><span class="err">&#39;</span> <span class="k">do</span>
  <span class="n">use_frameworks</span><span class="p">!</span>
<span class="n">end</span>
</div></code></pre><p>This tells your project to use frameworks instead of static libraries. Reminder that <strong>frameworks</strong> allow you to bundle images &amp; assets, while static libraries do not. Now time to add a Pod (framework)! Change your Podfile to this:</p><pre><code><div class="highlight"><span></span><span class="n">platform</span> <span class="p">:</span><span class="n">ios</span><span class="p">,</span> <span class="err">&#39;</span><span class="mf">16.0</span><span class="err">&#39;</span>

<span class="n">target</span> <span class="err">&#39;</span><span class="n">CocoaPods</span><span class="err">&#39;</span> <span class="k">do</span>
  <span class="n">use_frameworks</span><span class="p">!</span>
  <span class="n">pod</span> <span class="err">&#39;</span><span class="n">Alamofire</span><span class="err">&#39;</span><span class="p">,</span> <span class="err">&#39;</span><span class="mf">4.9</span><span class="p">.</span><span class="mi">1</span><span class="err">&#39;</span>
<span class="n">end</span>
</div></code></pre><p>This will add the Alamofire Pod at version 4.9.1 to our project. In the terminal run <strong>pod install</strong> to finalize. Now make sure you open the newly created <strong>.xcworkspace</strong> in your project directory, and pick a file. You should be able to build &amp; then <strong>import Alamofire</strong>!</p><h3>Carthage</h3><p>Similar to Cocoapods, Carthage is a 3rd party dependency manager...with a little different of a setup.</p><p>Lets start with installation. Go ahead and run <strong>brew install carthage</strong> in the terminal.</p><p>Similar to Cocoapods we will create a Cartfile, allowing us to list all of our dependencies in our project.</p><pre><code><div class="highlight"><span></span><span class="n">touch</span> <span class="n">Cartfile</span>
</div></code></pre><p>and then open your newly created Cartfile with whatever text editor you prefer. Now add the following line to the Cartfile:</p><pre><code><div class="highlight"><span></span><span class="n">github</span> <span class="s">&quot;Alamofire/Alamofire&quot;</span> <span class="p">==</span> <span class="mf">4.9</span><span class="p">.</span><span class="mi">0</span>
</div></code></pre><p>This specifies the exact version of Alamofire we want for our project. We can also use "&gt;=" to specify a version greater than or equal to a semantic version number. OR we can use "~&gt;" specifying Carthage to use 'Use any version that’s compatible with X'. We can also specify branches of the library or git Hash commits to use. Very powerful!</p><p>Now in our terminal enter the following:</p><pre><code><div class="highlight"><span></span><span class="n">carthage</span> <span class="n">update</span> <span class="o">--</span><span class="n">platform</span> <span class="n">iOS</span>
</div></code></pre><p>Next we can see what Carthage has built &amp; checked out for us by entering <strong>open Carthage</strong> in terminal. This is where Carthage differs from cocoapods a little bit. With Carthage we need to manually integrate the Binary Frameworks into our project. We can do this by going to our Target in Xcode, and scroll to the Linked Frameworks and Libraries section. Drag the Alamofire.framework from the Carthage directory into this section in Xcode. This links those frameworks to your project.</p><p>Easy Peasy!!</p><h3>Swift Package Manager</h3><p>And now it is time to introduce you to my personal favorite dependency manager, SPM or Swift Package Manager. Swift can divide code into "Packages".</p><p>Lets say we have a project in which we have to decipher some Yaml files. We could build this ourselves from scratch, or we could use an existing Library!</p><p>In Xcode go to File &gt; Add Packages and enter the URL of the package. In our case we will be using one hosted on Git, with the URL of https://github.com/jpsim/Yams.git . We can define any versioning we want for this package. Also, SPM automatically links the package to our project target! Neat!</p><p>Packages are very powerful because they keep our code extensible and modularized. If we have a grand scale application, we can break it down by feature, and each feature can have its own Package manifest file if we so desired. The scalability benefits here are very evident.</p><p>As you can see, the ease of use &amp; Xcode integration make SPM a fan favorite!</p><h3>Tradeoffs</h3><p>So now we have touched on SPM, Cocoapods, and Carthage. What are some of the pros and cons of each?</p><h4>Cocoapods:</h4><h5>Pros:</h5><ul><li>Supports both Dynamic Frameworks and Static Libraries</li><li>Automatic dependency tree resolution</li><li>Wide range of availability and documentation</li><li>Has an official mac app to manage your dependencies</li></ul><h5>Cons:</h5><ul><li>Slower build times, because every time you compile, your dependencies get built as well</li><li>When you install your first dependency, the main specs repo gets downloaded, and it takes a very long time</li><li>Your main project will be altered to be able to use all of your 3rd party dependencies</li></ul><h4>Carthage:</h4><h5>Pros:</h5><ul><li>Supports both Dynamic Frameworks and Static Libraries</li><li>Automatic dependency tree resolution</li><li>Faster than Cocoapods because your frameworks only get built once, on the first time you call "carthage update"</li><li>Your project remains untouched, unlike Cocoapods</li></ul><h5>Cons:</h5><ul><li>Little steeper learning curve, and more steps to actually add a dependency</li><li>Limited framework capacity. Not everyone supports Carthage</li></ul><h4>SPM:</h4><h5>Pros:</h5><ul><li>The Apple standard, on how to build and distribute code</li><li>Works on Linux</li><li>Less steps to bootstrap and get started</li></ul><h5>Cons:</h5><ul><li>You have to follow a specific directory structure structure</li><li>Swift Only!</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/leetcode/blind-75-linked-lists</guid><title>Blind 75: Linked Lists</title><description>Like an array...but not really</description><link>https://swiftrefresher.com/leetcode/blind-75-linked-lists</link><pubDate>Mon, 12 Sep 2022 14:44:00 -0400</pubDate><content:encoded><![CDATA[<h1>Linked Lists</h1><h2>Introduction</h2><p>The description says it all. Linked Lists are kind of like arrays, but they have their own special nuances.</p><p>A linked list, is a data structure, represented as a sequence of Nodes. Typically a node contains 2 things. A value or object of some kind, and a pointer to the next node in the sequence. Linked Lists come in 2 flavors: singly-linked and doubly linked list. We will go over each of these in more depth later.</p><p>Unlike an array, lookup of values in a linked list is not a constant time operation. You must traverse the array to find what value you are looking for.</p><p>Typical examples of when you might need to use a Linked List is a queue for example. With an array, when you remove an element from the front, you must shift all the other elements. In a linked list, it is just a matter of changing the head pointer.</p><h3>Singly-Linked List</h3><p>With singly linked lists, we have a value, and a pointer to the next node. The first node is commonly known as the "Head", and the last node is known as the "Tail". It is worth noting the pointer to the next node is Optional, as the Tail node's pointer will be nil, representing the end of the linked list.<br><br>Let's discuss some time complexities of common singly linked list operations:</p><ul><li>Accessing the head of the list = <strong>O(1)</strong></li><li>Accessing the tail of the list = <strong>O(n)</strong></li><li>Accessing the middle of the list = <strong>O(n)</strong></li><li>Insert/Remove the head of the list = <strong>O(1)</strong></li><li>Insert/Remove the tail of the list = <strong>O(n)</strong> to access and then an <strong>O(1)</strong> operation</li><li>Insert/Remove the middle of the list = <strong>O(n)</strong> to access and then an <strong>O(1)</strong> operation</li><li>Searching for a value = <strong>O(n)</strong></li></ul><h3>Doubly-Linked List</h3><p>A doubly linked list is just like a singly linked list except it has 2 pointers in its node instead of 1. The 2nd pointer is a reference to the previous node. This gives doubly linked lists a major advantage, considering if you need to go backwards in your list it is very simple. With a singly linked list, if you need to go backwards, you need to start your search over.</p><p>Worth noting that doubly linked lists take up slightly more memory due to the 2nd pointer.</p><p>Let's discuss some time complexities of common doubly linked list operations:</p><ul><li>Accessing the head of the list = <strong>O(1)</strong></li><li>Accessing the tail of the list = <strong>O(1)</strong></li><li>Accessing the middle of the list = <strong>O(n)</strong></li><li>Insert/Remove the head of the list = <strong>O(1)</strong></li><li>Insert/Remove the tail of the list = <strong>O(1)</strong></li><li>Insert/Remove the middle of the list = <strong>O(n)</strong> to access and then an <strong>O(1)</strong> operation</li><li>Searching for a value = <strong>O(n)</strong></li></ul><p>Slightly faster on some operations!</p><p>Also I would like to briefly touch on circular linked lists. This is where there is no clear head or tail, because the tail points to its head. Can be singly or doubly linked in these situations.</p><h2>Code Representation</h2><p>Although implementing a Linked List in an interview is a very rare occurrence, it still helps to know how it works under the hood from a code perspective.</p><h4>Singly Linked List Node</h4><pre><code><div class="highlight"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nv">value</span><span class="p">:</span> <span class="nb">String</span>
  <span class="kd">var</span> <span class="nv">next</span><span class="p">:</span> <span class="n">Node</span><span class="p">?</span> <span class="c1">// Note the optionality here</span>

  <span class="kd">public</span> <span class="kd">init</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">value</span> <span class="p">=</span> <span class="n">value</span>
  <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><h4>Doubly Linked List Node</h4><pre><code><div class="highlight"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nv">value</span><span class="p">:</span> <span class="nb">String</span>
  <span class="kd">var</span> <span class="nv">next</span><span class="p">:</span> <span class="n">Node</span><span class="p">?</span>
  <span class="kr">weak</span> <span class="kd">var</span> <span class="nv">previous</span><span class="p">:</span> <span class="n">Node</span><span class="p">?</span> <span class="c1">// Note the weak ownership here to avoid a retain cycle</span>

  <span class="kd">public</span> <span class="kd">init</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">value</span> <span class="p">=</span> <span class="n">value</span>
  <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><h4>Linked List Class</h4><pre><code><div class="highlight"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LinkedList</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kd">var</span> <span class="nv">head</span><span class="p">:</span> <span class="n">Node</span><span class="p">?</span>
    
    <span class="c1">// Helpers</span>
    <span class="kd">public</span> <span class="kd">var</span> <span class="nv">isEmpty</span><span class="p">:</span> <span class="nb">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">head</span> <span class="p">==</span> <span class="kc">nil</span>
    <span class="p">}</span>
    
    <span class="kd">public</span> <span class="kd">var</span> <span class="nv">first</span><span class="p">:</span> <span class="n">Node</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">head</span>
    <span class="p">}</span>
    
    <span class="kd">public</span> <span class="kd">var</span> <span class="nv">last</span><span class="p">:</span> <span class="n">Node</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="kd">var</span> <span class="nv">node</span> <span class="p">=</span> <span class="n">head</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
        <span class="k">while</span> <span class="kd">let</span> <span class="nv">next</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">next</span> <span class="p">{</span> <span class="n">node</span> <span class="p">=</span> <span class="n">next</span> <span class="p">}</span>
        <span class="k">return</span> <span class="n">node</span>
    <span class="p">}</span>
    
    <span class="c1">// Operations</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">append</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">newNode</span> <span class="p">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="kd">let</span> <span class="nv">lastNode</span> <span class="p">=</span> <span class="bp">last</span> <span class="p">{</span>
            <span class="n">newNode</span><span class="p">.</span><span class="n">previous</span> <span class="p">=</span> <span class="n">lastNode</span>
            <span class="n">lastNode</span><span class="p">.</span><span class="n">next</span> <span class="p">=</span> <span class="n">newNode</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">head</span> <span class="p">=</span> <span class="n">newNode</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// Get node at a certain index</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">node</span><span class="p">(</span><span class="n">atIndex</span> <span class="n">index</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Node</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">index</span> <span class="p">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">head</span><span class="p">!</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nv">node</span> <span class="p">=</span> <span class="n">head</span><span class="p">!.</span><span class="n">next</span>
            <span class="k">for</span> <span class="kc">_</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">.&lt;</span><span class="n">index</span> <span class="p">{</span>
                <span class="n">node</span> <span class="p">=</span> <span class="n">node</span><span class="p">?.</span><span class="n">next</span>
                <span class="k">if</span> <span class="n">node</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">//(*1)</span>
                    <span class="k">break</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">node</span><span class="p">!</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// Insert at a certain index</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">insert</span><span class="p">(</span><span class="kc">_</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">atIndex</span> <span class="n">index</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">newNode</span> <span class="p">=</span> <span class="n">node</span>
        <span class="k">if</span> <span class="n">index</span> <span class="p">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">newNode</span><span class="p">.</span><span class="n">next</span> <span class="p">=</span> <span class="n">head</span>
            <span class="n">head</span><span class="p">?.</span><span class="n">previous</span> <span class="p">=</span> <span class="n">newNode</span>
            <span class="n">head</span> <span class="p">=</span> <span class="n">newNode</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nv">prev</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">node</span><span class="p">(</span><span class="n">atIndex</span><span class="p">:</span> <span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="kd">let</span> <span class="nv">next</span> <span class="p">=</span> <span class="n">prev</span><span class="p">.</span><span class="n">next</span>
            
            <span class="n">newNode</span><span class="p">.</span><span class="n">previous</span> <span class="p">=</span> <span class="n">prev</span>
            <span class="n">newNode</span><span class="p">.</span><span class="n">next</span> <span class="p">=</span> <span class="n">prev</span><span class="p">.</span><span class="n">next</span>
            <span class="n">prev</span><span class="p">.</span><span class="n">next</span> <span class="p">=</span> <span class="n">newNode</span>
            <span class="n">next</span><span class="p">?.</span><span class="n">previous</span> <span class="p">=</span> <span class="n">newNode</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// Remove a node</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">remove</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">prev</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">previous</span>
        <span class="kd">let</span> <span class="nv">next</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">next</span>
        
        <span class="k">if</span> <span class="kd">let</span> <span class="nv">prev</span> <span class="p">=</span> <span class="n">prev</span> <span class="p">{</span>
            <span class="n">prev</span><span class="p">.</span><span class="n">next</span> <span class="p">=</span> <span class="n">next</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">head</span> <span class="p">=</span> <span class="n">next</span>
        <span class="p">}</span>
        <span class="n">next</span><span class="p">?.</span><span class="n">previous</span> <span class="p">=</span> <span class="n">prev</span>
        
        <span class="n">node</span><span class="p">.</span><span class="n">previous</span> <span class="p">=</span> <span class="kc">nil</span>
        <span class="n">node</span><span class="p">.</span><span class="n">next</span> <span class="p">=</span> <span class="kc">nil</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">value</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Not too bad! We cover some simple linked list operations here that will play into some more in depth Leetcode problems down the line.</p><h2>Common Linked List Operations</h2><p>It will help us in the future if we remember how some common linked list operations work, even if we remember them in english.</p><h4>Delete a Node</h4><p>To delete a node from a linked list, we have different tactics for singly vs doubly linked list:</p><ul><li>Singly Linked List: For node N, find the previous node, and set <strong>previous.next = n.next</strong></li><li>Doubly Linked List: For node N, set <strong>n.next.previous = n.previous</strong></li></ul><h4>Runner Technique</h4><p>Commonly in Linked Lists you will find the need to use the runner technique. This technique is implemented by having 2 pointers at the same time in your list. One pointer will move ahead of the either. You can either do: - Fast node moves by fixed amount - For every 1 move of the slow pointer, the fast pointer jumps multiple nodes.</p><p>This is commonly used for finding cycles within your linked list.</p><p>Last overview point to make about Linked List is that a lot of leetcode linked list problems rely on recursion. When solving problems, remember recursive solutions automatically add O(N) space due to the ever expanding call stack of the function.</p><hr><h1>Reverse Linked List</h1><p>Time to start the foundation of our linked list knowledge!</p><img src="https://swiftrefresher.com/reverselinkedlist.png"/><p>This is a classic LinkedList problem, and is honestly really fun to reverse engineer. Learning how to reverse a linked list will set us up for success later down the road with other leetcode problems.</p><h3>[ Recursive ]</h3><h3>[ O(n) worst time + O(n) space ]</h3><p>Remember what we said earlier! A lot of Linked List problems can be solved recursively (with a hit on our space complexity due to the call stack.)</p><p>When I think about recursive problems, I like to start with the base case. In our case, the base case is if the linked list is empty, or only has 1 node. If that is the case there is nothing to reverse!</p><p>Now if we look at the recursive case, when we have 2 nodes, we know we will need to reverse the order of them. That means doing 3 things:</p><ol><li>Setting our heads next pointer to nil, signifying the end of the list</li><li>Setting our current node's next pointer, to the previous node</li><li>Setting our current node to the next node</li></ol><p>Let's run thru an example for this. Say we have a list of [1-&gt;2]. Keep in mind we will be recursing, so we are working from the back to the front. In this example our current node is 2, and our head is 1. We want to set our heads next pointer to nil, signifying the end of the list. This makes our linked list now [1 2] with no next pointer on 1. We also want to set our current nodes next pointer, to the previous pointer. This makes our linked list now [1&lt;-2]. And we want to set our current node to the next node, which would end our loop. Boom! It is reversed. Let's think about the pseudocode here.</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">our</span> <span class="n">list</span> <span class="k">is</span> <span class="n">empty</span> <span class="n">or</span> <span class="n">there</span> <span class="k">is</span> <span class="n">only</span> <span class="mi">1</span> <span class="n">node</span>
    <span class="k">return</span> <span class="n">the</span> <span class="n">head</span>
<span class="n">recurse</span> <span class="n">on</span> <span class="n">the</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">the</span> <span class="n">linked</span> <span class="n">list</span> <span class="p">(</span><span class="n">the</span> <span class="n">next</span> <span class="n">node</span> <span class="n">from</span> <span class="n">head</span><span class="p">)</span>

<span class="n">our</span> <span class="n">current</span> <span class="n">node</span> <span class="k">is</span> <span class="n">heads</span> <span class="n">next</span>
<span class="n">current</span> <span class="n">nodes</span> <span class="n">next</span> <span class="k">is</span> <span class="n">the</span> <span class="n">head</span>
<span class="n">heads</span> <span class="n">next</span> <span class="k">is</span> <span class="kc">nil</span>

<span class="k">return</span> <span class="n">the</span> <span class="n">recursed</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">the</span> <span class="n">linked</span> <span class="n">list</span>
</div></code></pre><p>Very wordy! Our space complexity here is O(n) due to the recursive call stack. Keeping references to nodes is O(1) space. The time complexity here is O(n) where n is the number of nodes in our linked list. This is because we need to visit every node to reverse them.</p><p>Here is the fully flushed out code solution:</p><pre><code><div class="highlight"><span></span><span class="c1">// Base Case</span>
<span class="k">if</span> <span class="n">head</span> <span class="p">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="n">head</span><span class="p">?.</span><span class="n">next</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="n">head</span> <span class="p">}</span>
<span class="c1">// Recursive Case</span>
<span class="kd">let</span> <span class="nv">newHead</span> <span class="p">=</span> <span class="n">reverseList</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">)</span>

<span class="kd">let</span> <span class="nv">nextNode</span> <span class="p">=</span> <span class="n">head</span><span class="p">.</span><span class="n">next</span>
<span class="n">nextNode</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">head</span>
<span class="n">head</span><span class="p">.</span><span class="n">next</span> <span class="p">=</span> <span class="kc">nil</span>

<span class="k">return</span> <span class="n">newHead</span>
</div></code></pre><h3>[ Iterative ]</h3><h3>[ O(n) time + O(1) space ]</h3><p>I personally feel it is easier to derive the iterative solution for this problem.</p><p>The idea behind the iterative solution, is we have a buffer for the previous node (since this is a singly linked list, we don't know what the previous node will be at every round of iteration.), and we follow similar patterns for the recursive solution, to reverse the list. It would look something like this:</p><pre><code><div class="highlight"><span></span><span class="n">previous</span> <span class="n">node</span> <span class="k">is</span> <span class="kc">nil</span>
<span class="n">current</span> <span class="n">node</span> <span class="k">is</span> <span class="n">the</span> <span class="n">head</span>

<span class="k">while</span> <span class="n">there</span> <span class="k">is</span> <span class="n">a</span> <span class="n">node</span> <span class="n">next</span> <span class="n">to</span> <span class="n">our</span> <span class="n">current</span>
    <span class="kr">set</span> <span class="n">current</span> <span class="n">nodes</span> <span class="n">next</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">previous</span> <span class="n">node</span> 
    <span class="kr">set</span> <span class="n">previous</span> <span class="n">to</span> <span class="n">current</span> <span class="n">node</span>
    <span class="kr">set</span> <span class="n">current</span> <span class="n">node</span> <span class="n">to</span> <span class="n">next</span> <span class="n">node</span>
    
<span class="n">at</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">our</span> <span class="n">loop</span><span class="p">,</span> <span class="kr">set</span> <span class="n">the</span> <span class="kr">final</span> <span class="n">nodes</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">previous</span> <span class="n">node</span>
<span class="k">return</span> <span class="n">the</span> <span class="n">current</span> <span class="n">node</span>
</div></code></pre><p>The trick here is using a <strong>while let</strong> loop to capture the next node at every iteration. The space complexity is much reduced here, as we only have 2 variables to hold references to nodes. This equals O(1) space. The time complexity is O(n) because we just need to traverse the linked list once.</p><p>Here is the final implementation:</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">head</span><span class="p">?.</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="n">head</span> <span class="p">}</span> <span class="c1">// edge cases</span>
<span class="kd">var</span> <span class="nv">previous</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">?</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="kd">var</span> <span class="nv">current</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">?</span> <span class="p">=</span> <span class="n">head</span>

<span class="k">while</span> <span class="kd">let</span> <span class="nv">nextNode</span> <span class="p">=</span> <span class="n">current</span><span class="p">?.</span><span class="n">next</span> <span class="p">{</span> <span class="c1">// capture the next node</span>
    <span class="n">current</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">previous</span>
    <span class="n">previous</span> <span class="p">=</span> <span class="n">current</span>
    <span class="n">current</span> <span class="p">=</span> <span class="n">nextNode</span>
<span class="p">}</span>

<span class="n">current</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">previous</span> <span class="c1">// complete the sequence</span>
<span class="k">return</span> <span class="n">current</span>
</div></code></pre><p>Not so bad right? On to the next!</p><hr><h1>Merge Two Sorted Lists</h1><p>Here is another essential &amp; common problem when it comes to linked lists!</p><img src="https://swiftrefresher.com/mergetwosortedlists.png"/><p>After looking at this problem it seems pretty straight forward. There is not really a brute force solution to be discussed here, so let's dive into the approach.</p><h3>[ Dummy Node + 2 pointers ]</h3><h3>[ O(n) worst time + O(n) space ]</h3><p>So the idea here is straight forward enough, we just need to be careful when it comes to implementation.</p><p>First off, we need a dummy node that we will be building our return result around. Ultimately we do not care about the dummy node, but everything after it. Hence we will be returning dummy nodes next node. We will also need 2 pointers to keep track of our progress of adding nodes from linked list 1 &amp; 2. As we add values to our return result, we will move our pointers to not add duplicate values.</p><p>At each iteration, we want to compare the values from lists 1 &amp; 2. If they are equal, add both to the result. Otherwise we will be adding the smaller of the 2 nodes.</p><p>After we run out of nodes to add in one list, we want to make sure we get all the nodes from the remaining list, and vice versa.</p><p>Here is the pseudocode!</p><pre><code><div class="highlight"><span></span><span class="k">while</span> <span class="k">in</span> <span class="n">range</span> <span class="n">of</span> <span class="n">list</span> <span class="n">one</span> <span class="n">AND</span> <span class="n">list</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="n">the</span> <span class="n">node</span> <span class="k">in</span> <span class="n">list</span> <span class="mi">1</span> <span class="k">is</span> <span class="bp">equal</span> <span class="n">to</span> <span class="n">the</span> <span class="n">node</span> <span class="n">value</span> <span class="k">in</span> <span class="n">list</span> <span class="mi">2</span>
        <span class="n">add</span> <span class="n">both</span> <span class="n">to</span> <span class="n">the</span> <span class="n">result</span>
        <span class="n">move</span> <span class="n">pointers</span> <span class="k">in</span> <span class="n">both</span> <span class="n">lists</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">node</span> <span class="mi">1</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">node</span> <span class="mi">2</span> <span class="n">value</span>
        <span class="n">add</span> <span class="n">node</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">result</span>
        <span class="n">move</span> <span class="n">node</span> <span class="mi">1</span> <span class="n">pointer</span>
    <span class="k">else</span>
        <span class="n">add</span> <span class="n">node</span> <span class="mi">2</span> <span class="n">to</span> <span class="n">result</span>
        <span class="n">move</span> <span class="n">node</span> <span class="mi">2</span> <span class="n">pointer</span>
        
<span class="k">while</span> <span class="n">list</span> <span class="mi">1</span> <span class="n">pointer</span> <span class="k">is</span> <span class="n">not</span> <span class="n">at</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">list</span> <span class="mi">1</span>
    <span class="n">add</span> <span class="n">node</span> <span class="n">to</span> <span class="n">result</span>

<span class="k">while</span> <span class="n">list</span> <span class="mi">2</span> <span class="n">pointer</span> <span class="k">is</span> <span class="n">not</span> <span class="n">at</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">list</span> <span class="mi">2</span>
    <span class="n">add</span> <span class="n">node</span> <span class="n">to</span> <span class="n">result</span>
    
<span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="n">next</span>
</div></code></pre><p>As we can see here there are many loops! But luckily they are sequential and not nested, so it doesn't hurt our time complexity. The time complexity here is O(n) where n is the length of the combination of the 2 lists. If our input lists are of length 3 and 4 respectively, we know we will be looping 7 times. Our space complexity is O(n) at the worst. n is representative of the return result, as our result will continue to grow and take up space as we iterate. Our pointers do not take up memory because under the hood, the list node we are storing as a pointer is just an address in memory. Not a representation of all nodes at a given time.</p><p>Here is the final implementation.</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="n">list1</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="n">list2</span> <span class="p">}</span> <span class="c1">// edge case</span>
<span class="k">if</span> <span class="n">list2</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="n">list1</span> <span class="p">}</span> <span class="c1">// edge case</span>

<span class="kd">var</span> <span class="nv">listOnePointer</span> <span class="p">=</span> <span class="n">list1</span>
<span class="kd">var</span> <span class="nv">listTwoPointer</span> <span class="p">=</span> <span class="n">list2</span>
<span class="kd">var</span> <span class="nv">newList</span> <span class="p">=</span> <span class="n">ListNode</span><span class="p">()</span> <span class="c1">// our dummy node</span>
<span class="kd">var</span> <span class="nv">newListPointer</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">?</span> <span class="p">=</span> <span class="n">newList</span> <span class="c1">// our pointer in our new list</span>

<span class="k">while</span> <span class="n">listOnePointer</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">listTwoPointer</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// while both are in range</span>
    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">listOnePointerValue</span> <span class="p">=</span> <span class="n">listOnePointer</span><span class="p">?.</span><span class="n">val</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">listTwoPointerValue</span> <span class="p">=</span> <span class="n">listTwoPointer</span><span class="p">?.</span><span class="n">val</span> <span class="k">else</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
    
    <span class="k">if</span> <span class="n">listOnePointerValue</span> <span class="p">==</span> <span class="n">listTwoPointerValue</span> <span class="p">{</span> <span class="c1">// equal value</span>
        <span class="c1">// add both to the result</span>
        <span class="n">newListPointer</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">listOnePointerValue</span><span class="p">)</span>
        <span class="n">newListPointer</span> <span class="p">=</span> <span class="n">newListPointer</span><span class="p">?.</span><span class="n">next</span>
        <span class="n">newListPointer</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">listOnePointerValue</span><span class="p">)</span>
        <span class="n">newListPointer</span> <span class="p">=</span> <span class="n">newListPointer</span><span class="p">?.</span><span class="n">next</span>
        <span class="c1">// move our pointers</span>
        <span class="n">listOnePointer</span> <span class="p">=</span> <span class="n">listOnePointer</span><span class="p">?.</span><span class="n">next</span>
        <span class="n">listTwoPointer</span> <span class="p">=</span> <span class="n">listTwoPointer</span><span class="p">?.</span><span class="n">next</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">listOnePointerValue</span> <span class="o">&lt;</span> <span class="n">listTwoPointerValue</span> <span class="p">{</span>
        <span class="c1">// add to result</span>
        <span class="kd">let</span> <span class="nv">newNode</span> <span class="p">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">listOnePointerValue</span><span class="p">)</span>
        <span class="n">newListPointer</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">newNode</span>
        <span class="n">newListPointer</span> <span class="p">=</span> <span class="n">newListPointer</span><span class="p">?.</span><span class="n">next</span>
        <span class="c1">// move pointer</span>
        <span class="n">listOnePointer</span> <span class="p">=</span> <span class="n">listOnePointer</span><span class="p">?.</span><span class="n">next</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// add to result</span>
        <span class="kd">let</span> <span class="nv">newNode</span> <span class="p">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">listTwoPointerValue</span><span class="p">)</span>
        <span class="n">newListPointer</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">newNode</span>
        <span class="n">newListPointer</span> <span class="p">=</span> <span class="n">newListPointer</span><span class="p">?.</span><span class="n">next</span>
        <span class="c1">// move pointer</span>
        <span class="n">listTwoPointer</span> <span class="p">=</span> <span class="n">listTwoPointer</span><span class="p">?.</span><span class="n">next</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Finish off the stragglers</span>
<span class="k">while</span> <span class="n">listOnePointer</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">listOnePointerValue</span> <span class="p">=</span> <span class="n">listOnePointer</span><span class="p">?.</span><span class="n">val</span> <span class="k">else</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
    <span class="kd">let</span> <span class="nv">newNode</span> <span class="p">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">listOnePointerValue</span><span class="p">)</span>
    <span class="n">newListPointer</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">newNode</span>
    <span class="n">newListPointer</span> <span class="p">=</span> <span class="n">newListPointer</span><span class="p">?.</span><span class="n">next</span>
    <span class="n">listOnePointer</span> <span class="p">=</span> <span class="n">listOnePointer</span><span class="p">?.</span><span class="n">next</span>
<span class="p">}</span>

<span class="k">while</span> <span class="n">listTwoPointer</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">listTwoPointerValue</span> <span class="p">=</span> <span class="n">listTwoPointer</span><span class="p">?.</span><span class="n">val</span> <span class="k">else</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
    <span class="kd">let</span> <span class="nv">newNode</span> <span class="p">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">listTwoPointerValue</span><span class="p">)</span>
    <span class="n">newListPointer</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">newNode</span>
    <span class="n">newListPointer</span> <span class="p">=</span> <span class="n">newListPointer</span><span class="p">?.</span><span class="n">next</span>
    <span class="n">listTwoPointer</span> <span class="p">=</span> <span class="n">listTwoPointer</span><span class="p">?.</span><span class="n">next</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">newList</span><span class="p">.</span><span class="n">next</span>
</div></code></pre><p>Well done! With linked list problems we need to be aware of any out of bounds exceptions, or nil values on a nodes next pointer.</p><hr><h1>Reorder List</h1><p>This problem does a good job combining our previous 2 problems into one</p><img src="https://swiftrefresher.com/reorderlist.png"/><p>Getting a little tricky! There are 2 main components to this problem we will work through together.</p><h3>[ Reverse + Merge ]</h3><h3>[ O(n) worst time + O(n) space ]</h3><p>So there are 3 parts to this problem.</p><p>The first problem is, we need to somehow get to the middle of the list so that we fill in our new list as specified, with the first node, then last node, then 2nd node, etc. Since this is a singly linked list we do not have any access to the previous node values. In order to get to the middle of the list, we can use the runner technique where we have a fast and slow pointer. We move the slow pointer 1 at a time, and the fast pointer 2 nodes at a time. When the fast node gets to the end, we know our slow pointer is in the middle of our list. This will work for both even and odd numbered linked lists. Pseudocode:</p><pre><code><div class="highlight"><span></span><span class="n">start</span> <span class="n">slow</span> <span class="n">at</span> <span class="n">the</span> <span class="n">beginning</span>
<span class="n">start</span> <span class="n">fast</span> <span class="n">at</span> <span class="n">the</span> <span class="mi">2</span><span class="n">nd</span> <span class="n">node</span>
<span class="k">while</span> <span class="n">fast</span> <span class="n">pointer</span> <span class="k">is</span> <span class="n">not</span> <span class="kc">nil</span> <span class="n">AND</span> <span class="n">fast</span> <span class="n">pointers</span> <span class="n">next</span> <span class="k">is</span> <span class="n">not</span> <span class="kc">nil</span>
    <span class="n">move</span> <span class="n">slow</span> <span class="n">by</span> <span class="mi">1</span>
    <span class="n">move</span> <span class="n">fast</span> <span class="n">by</span> <span class="mi">2</span>
</div></code></pre><p>Easy Enough!</p><p>The second part of this problem, is now that we are in the middle of our list, we know what the second half of our list is. It is everything to the right of the slow pointer. We need to reverse this portion of our list in place. This is so we split our original list up into 2 parts. A normal front half, and a reversed second half, so we can merge the 2 accordingly. ALSO, it is important we break the pointer between the first &amp; reversed second half, so we don't have any circular lists in the future. Like this:</p><pre><code><div class="highlight"><span></span><span class="kr">get</span> <span class="n">second</span> <span class="n">half</span> <span class="n">of</span> <span class="n">list</span> <span class="n">from</span> <span class="n">slow</span> <span class="n">pointer</span>
<span class="n">keep</span> <span class="n">track</span> <span class="n">of</span> <span class="n">a</span> <span class="n">previous</span> <span class="n">node</span>

<span class="k">while</span> <span class="n">our</span> <span class="n">secondHalfs</span> <span class="n">next</span> <span class="k">is</span> <span class="n">not</span> <span class="kc">nil</span>
    <span class="n">secondHalfs</span> <span class="n">next</span> <span class="n">to</span> <span class="n">previous</span>
    <span class="kr">set</span> <span class="n">previous</span> <span class="n">to</span> <span class="n">current</span>
    <span class="kr">set</span> <span class="n">current</span> <span class="n">to</span> <span class="n">next</span>

<span class="kr">set</span> <span class="n">secondHalfs</span> <span class="n">next</span> <span class="n">to</span> <span class="n">previous</span>
<span class="kr">set</span> <span class="n">slowPointers</span> <span class="n">next</span> <span class="n">to</span> <span class="kc">nil</span>
</div></code></pre><p>Ok. Cool.</p><p>The final part of the solution is merging the 2 lists together. We can say our firstHalf is the head of our linked list. This is because we broke off the slow pointers next node, thus breaking the list in half. The secondHalf is the reversed list we just created. Now, we will fill in the lists alternating from the firstHalf and secondHalf</p><pre><code><div class="highlight"><span></span><span class="kr">get</span> <span class="n">firstHalf</span>
<span class="kr">get</span> <span class="n">secondHalf</span>

<span class="n">create</span> <span class="n">new</span> <span class="n">list</span> <span class="n">with</span> <span class="n">dummy</span> <span class="n">node</span>
<span class="kr">set</span> <span class="n">head</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">new</span> <span class="n">list</span> <span class="n">head</span>

<span class="k">while</span> <span class="n">we</span> <span class="n">havent</span> <span class="n">gotten</span> <span class="n">to</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">firstHalf</span> <span class="n">AND</span> <span class="n">we</span> <span class="n">havent</span> <span class="n">gotten</span> <span class="n">to</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">secondHalf</span>
    <span class="kr">set</span> <span class="n">new</span> <span class="n">lists</span> <span class="n">next</span> <span class="n">to</span> <span class="bp">first</span> <span class="n">half</span>
    <span class="n">move</span> <span class="bp">first</span> <span class="n">half</span> <span class="n">to</span> <span class="n">next</span>
    <span class="n">move</span> <span class="n">new</span> <span class="n">list</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">next</span>
    
    <span class="kr">set</span> <span class="n">new</span> <span class="n">lists</span> <span class="n">next</span> <span class="n">to</span> <span class="n">second</span> <span class="n">half</span>
    <span class="n">move</span> <span class="n">second</span> <span class="n">half</span> <span class="n">to</span> <span class="n">next</span>
    <span class="n">move</span> <span class="n">new</span> <span class="n">list</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">next</span>
    

<span class="k">if</span> <span class="n">there</span> <span class="n">are</span> <span class="n">leftovers</span> <span class="k">in</span> <span class="n">firstHalf</span>
    <span class="n">add</span> <span class="n">them</span> <span class="n">to</span> <span class="n">new</span> <span class="n">list</span>
<span class="k">if</span> <span class="n">there</span> <span class="n">are</span> <span class="n">leftovers</span> <span class="k">in</span> <span class="n">secondHalf</span>
    <span class="n">add</span> <span class="n">them</span> <span class="n">to</span> <span class="n">new</span> <span class="n">list</span> 

<span class="k">return</span> <span class="n">the</span> <span class="n">head</span> <span class="n">pointers</span> <span class="n">next</span>
</div></code></pre><p>This part can get a little tricky! We need to keep edge cases in mind. Bringing it all together, we have this pseudocode solution:</p><pre><code><div class="highlight"><span></span><span class="c1">// 1.</span>
<span class="n">start</span> <span class="n">slow</span> <span class="n">at</span> <span class="n">the</span> <span class="n">beginning</span>
<span class="n">start</span> <span class="n">fast</span> <span class="n">at</span> <span class="n">the</span> <span class="mi">2</span><span class="n">nd</span> <span class="n">node</span>
<span class="k">while</span> <span class="n">fast</span> <span class="n">pointer</span> <span class="k">is</span> <span class="n">not</span> <span class="kc">nil</span> <span class="n">AND</span> <span class="n">fast</span> <span class="n">pointers</span> <span class="n">next</span> <span class="k">is</span> <span class="n">not</span> <span class="kc">nil</span>
    <span class="n">move</span> <span class="n">slow</span> <span class="n">by</span> <span class="mi">1</span>
    <span class="n">move</span> <span class="n">fast</span> <span class="n">by</span> <span class="mi">2</span>
    
<span class="c1">// 2.</span>
<span class="kr">get</span> <span class="n">second</span> <span class="n">half</span> <span class="n">of</span> <span class="n">list</span> <span class="n">from</span> <span class="n">slow</span> <span class="n">pointer</span>
<span class="n">keep</span> <span class="n">track</span> <span class="n">of</span> <span class="n">a</span> <span class="n">previous</span> <span class="n">node</span>

<span class="k">while</span> <span class="n">our</span> <span class="n">secondHalfs</span> <span class="n">next</span> <span class="k">is</span> <span class="n">not</span> <span class="kc">nil</span>
    <span class="n">secondHalfs</span> <span class="n">next</span> <span class="n">to</span> <span class="n">previous</span>
    <span class="kr">set</span> <span class="n">previous</span> <span class="n">to</span> <span class="n">current</span>
    <span class="kr">set</span> <span class="n">current</span> <span class="n">to</span> <span class="n">next</span>

<span class="kr">set</span> <span class="n">secondHalfs</span> <span class="n">next</span> <span class="n">to</span> <span class="n">previous</span>
<span class="kr">set</span> <span class="n">slowPointers</span> <span class="n">next</span> <span class="n">to</span> <span class="kc">nil</span>

<span class="c1">// 3.</span>
<span class="kr">get</span> <span class="n">firstHalf</span>
<span class="kr">get</span> <span class="n">secondHalf</span>

<span class="n">create</span> <span class="n">new</span> <span class="n">list</span> <span class="n">with</span> <span class="n">dummy</span> <span class="n">node</span>
<span class="kr">set</span> <span class="n">head</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">new</span> <span class="n">list</span> <span class="n">head</span>

<span class="k">while</span> <span class="n">we</span> <span class="n">havent</span> <span class="n">gotten</span> <span class="n">to</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">firstHalf</span> <span class="n">AND</span> <span class="n">we</span> <span class="n">havent</span> <span class="n">gotten</span> <span class="n">to</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">secondHalf</span>
    <span class="kr">set</span> <span class="n">new</span> <span class="n">lists</span> <span class="n">next</span> <span class="n">to</span> <span class="bp">first</span> <span class="n">half</span>
    <span class="n">move</span> <span class="bp">first</span> <span class="n">half</span> <span class="n">to</span> <span class="n">next</span>
    <span class="n">move</span> <span class="n">new</span> <span class="n">list</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">next</span>
    
    <span class="kr">set</span> <span class="n">new</span> <span class="n">lists</span> <span class="n">next</span> <span class="n">to</span> <span class="n">second</span> <span class="n">half</span>
    <span class="n">move</span> <span class="n">second</span> <span class="n">half</span> <span class="n">to</span> <span class="n">next</span>
    <span class="n">move</span> <span class="n">new</span> <span class="n">list</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">next</span>
    

<span class="k">if</span> <span class="n">there</span> <span class="n">are</span> <span class="n">leftovers</span> <span class="k">in</span> <span class="n">firstHalf</span>
    <span class="n">add</span> <span class="n">them</span> <span class="n">to</span> <span class="n">new</span> <span class="n">list</span>
<span class="k">if</span> <span class="n">there</span> <span class="n">are</span> <span class="n">leftovers</span> <span class="k">in</span> <span class="n">secondHalf</span>
    <span class="n">add</span> <span class="n">them</span> <span class="n">to</span> <span class="n">new</span> <span class="n">list</span> 

<span class="k">return</span> <span class="n">the</span> <span class="n">head</span> <span class="n">pointers</span> <span class="n">next</span>
</div></code></pre><p>This is very verbose! But gets the point across. We can see there a dummy list being built and returned, and that takes up O(N) space. The time complexity on average is O(n) because we traverse the list about 3 times but never in a nested fashion.</p><p>Let's take a look at the implementation! I am a fan of readable code, even if that means your Leetcode runtime is not 0 milliseconds.</p><h5>Implementation:</h5><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">slowPointer</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">?</span> <span class="p">=</span> <span class="n">head</span>
<span class="kd">var</span> <span class="nv">fastPointer</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">?</span> <span class="p">=</span> <span class="n">head</span><span class="p">?.</span><span class="n">next</span>

<span class="c1">// 1. Get our our fast pointer to the end and our slow pointer to the middle </span>
<span class="k">while</span> <span class="n">fastPointer</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="n">fastPointer</span><span class="p">?.</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="n">slowPointer</span> <span class="p">=</span> <span class="n">slowPointer</span><span class="p">?.</span><span class="n">next</span>
    <span class="n">fastPointer</span> <span class="p">=</span> <span class="n">fastPointer</span><span class="p">?.</span><span class="n">next</span><span class="p">?.</span><span class="n">next</span>
<span class="p">}</span>

<span class="c1">// 2. Reverse the second half</span>
<span class="kd">var</span> <span class="nv">secondHalf</span> <span class="p">=</span> <span class="n">slowPointer</span><span class="p">?.</span><span class="n">next</span>
<span class="kd">var</span> <span class="nv">previous</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">?</span> <span class="p">=</span> <span class="kc">nil</span>

<span class="k">while</span> <span class="kd">let</span> <span class="nv">next</span> <span class="p">=</span> <span class="n">secondHalf</span><span class="p">?.</span><span class="n">next</span> <span class="p">{</span>
    <span class="n">secondHalf</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">previous</span>
    <span class="n">previous</span> <span class="p">=</span> <span class="n">secondHalf</span>
    <span class="n">secondHalf</span> <span class="p">=</span> <span class="n">next</span>
<span class="p">}</span>
<span class="n">secondHalf</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">previous</span>
<span class="kd">let</span> <span class="nv">reversedList</span> <span class="p">=</span> <span class="n">secondHalf</span>
<span class="n">slowPointer</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="kc">nil</span>
        
<span class="c1">// 3. Merge the two</span>
<span class="kd">var</span> <span class="nv">firstHalf</span> <span class="p">=</span> <span class="n">head</span>
<span class="kd">var</span> <span class="nv">secondHalf</span> <span class="p">=</span> <span class="n">reversedList</span>

<span class="kd">var</span> <span class="nv">merged</span><span class="p">:</span><span class="n">ListNode</span><span class="p">?</span> <span class="p">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// new list</span>
<span class="kd">let</span> <span class="nv">head</span> <span class="p">=</span> <span class="n">merged</span> <span class="c1">// pointer to new list</span>

<span class="k">while</span> <span class="n">firstHalf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="n">secondHalf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="n">merged</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">firstHalf</span>
    <span class="n">firstHalf</span> <span class="p">=</span> <span class="n">firstHalf</span><span class="p">?.</span><span class="n">next</span>
    <span class="n">merged</span> <span class="p">=</span> <span class="n">merged</span><span class="p">?.</span><span class="n">next</span>
    
    <span class="n">merged</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">secondHalf</span>
    <span class="n">secondHalf</span> <span class="p">=</span> <span class="n">secondHalf</span><span class="p">?.</span><span class="n">next</span>
    <span class="n">merged</span> <span class="p">=</span> <span class="n">merged</span><span class="p">?.</span><span class="n">next</span>
<span class="p">}</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">leftOver</span> <span class="p">=</span> <span class="n">firstHalf</span> <span class="p">{</span>
    <span class="n">merged</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">leftOver</span>
<span class="p">}</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">leftOver</span> <span class="p">=</span> <span class="n">secondHalf</span> <span class="p">{</span>
    <span class="n">merged</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">leftOver</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">head</span><span class="p">?.</span><span class="n">next</span> <span class="c1">// return dummys next</span>
</div></code></pre><p>Whew! That was a doozy. But you can see it combines our first 2 leetcode problems in this section into its own problem.</p><hr><h1>Remove Nth Node From End of List</h1><p>Let's move on to something a little easier!</p><img src="https://swiftrefresher.com/removenthnodefromendoflist.png"/><p>This one is tricky! But once we figure out the trick, it is very straight forward &amp; easy to implement in code.</p><h3>[ Runner Technique ]</h3><h3>[ O(n) time + O(1) space ]</h3><p>So the trick here is figuring out how we know we are currently at the Nth node from the end of the list. We know how to remove a node, we just need to get to the right node to remove. For this we can use the linked list runner technique. We can use a fast pointer &amp; a slow pointer. If we set the fast pointer N spots ahead of the slow pointer, then move them both ahead by one node, when the fast pointer is at the end of the list the slow pointer will be N nodes from the end of the list! Once we get that implementation down, we know it is all about testing the edge cases after that.</p><p>Essentially it will look something like this:</p><pre><code><div class="highlight"><span></span><span class="n">move</span> <span class="n">fast</span> <span class="n">pointer</span> <span class="n">N</span> <span class="n">steps</span> <span class="n">ahead</span>
<span class="k">while</span> <span class="n">fast</span> <span class="n">pointer</span> <span class="k">is</span> <span class="n">not</span> <span class="kc">nil</span>
    <span class="n">move</span> <span class="n">both</span> <span class="n">slow</span> <span class="o">&amp;</span> <span class="n">fast</span> <span class="n">ahead</span> <span class="n">by</span> <span class="mi">1</span>

<span class="n">remove</span> <span class="n">the</span> <span class="n">slow</span> <span class="n">pointer</span> <span class="n">node</span>
</div></code></pre><p>So as we can see, we only traverse the list one time, and removing a node is an O(1) time operation. This equates to O(n) time where n is the length of the linked list. When it comes to space complexity, we are only keeping 3 or 4 variables tracking fast and slow pointers. These variables do not grow in space so it is safe to assume they are O(1) space complexity.</p><p>Time to implement! One thing to keep in mind here though. There are some edge cases at play. If the head node is nil, or only has 1 node we should just return nil because we are removing the only node we have in the entire list. If by the time we move our fast node to the end of the list, and our slow pointer is still at the head, we can just return head.next, since we need to remove the first node in the list. This situation will happen when we have an input variable of N that is greater than or equal to the length of the linked list.</p><p>Here is the implementation:</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">head</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">head</span><span class="p">?.</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span> <span class="c1">// Edge Case #1</span>
<span class="kd">var</span> <span class="nv">headPointer</span> <span class="p">=</span> <span class="n">head</span>
<span class="kd">var</span> <span class="nv">slow</span> <span class="p">=</span> <span class="n">head</span>
<span class="kd">var</span> <span class="nv">fast</span> <span class="p">=</span> <span class="n">head</span>
<span class="kd">var</span> <span class="nv">previous</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">?</span> <span class="p">=</span> <span class="kc">nil</span>

<span class="c1">// Move fast pointer n steps ahead</span>
<span class="k">for</span> <span class="kc">_</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.&lt;</span><span class="n">n</span> <span class="p">{</span> 
    <span class="n">fast</span> <span class="p">=</span> <span class="n">fast</span><span class="p">?.</span><span class="n">next</span>
<span class="p">}</span>

<span class="k">while</span> <span class="n">fast</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// Move fast to end, and keep track of previous along the way</span>
    <span class="n">previous</span> <span class="p">=</span> <span class="n">slow</span>
    <span class="n">slow</span> <span class="p">=</span> <span class="n">slow</span><span class="p">?.</span><span class="n">next</span>
    <span class="n">fast</span> <span class="p">=</span> <span class="n">fast</span><span class="p">?.</span><span class="n">next</span>
<span class="p">}</span>

<span class="k">if</span> <span class="n">slow</span> <span class="p">===</span> <span class="n">head</span> <span class="p">{</span> <span class="k">return</span> <span class="n">slow</span><span class="p">?.</span><span class="n">next</span> <span class="p">}</span> <span class="c1">// Edge Case #2</span>

<span class="c1">// Remove the slow node</span>
<span class="n">previous</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">slow</span><span class="p">?.</span><span class="n">next</span>        
<span class="n">slow</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="k">return</span> <span class="n">headPointer</span>
</div></code></pre><p>Not too bad, and I hope by now Linked Lists are getting a little easier to digest. Only 2 more to go!</p><hr><h1>Linked List Cycle</h1><p>This one is an all time classic!</p><img src="https://swiftrefresher.com/linkedlistcycle.png"/><h3>[ Runner Technique ]</h3><h3>[ O(n) time + O(1) space ]</h3><p>So I kind of gave away the answer to this one at the beginning of this article but we can go through the problem regardless.</p><p>The approach here is to use 2 runners &amp; use the runner technique to see if there is a cycle in the list. We would essentially have a fast runner, and a slow runner. We move the slow pointer by 1, and the fast pointer by 2. If those 2 values are ever the same we know there is a cycle, but if we traverse to the end of the list with our fast pointer we know there is not a cycle. Something like this:</p><pre><code><div class="highlight"><span></span><span class="n">fast</span> <span class="n">pointer</span> <span class="n">starting</span> <span class="n">at</span> <span class="n">head</span>
<span class="n">slow</span> <span class="n">pointer</span> <span class="n">starting</span> <span class="n">at</span> <span class="n">head</span>

<span class="k">while</span> <span class="n">fast</span> <span class="k">is</span> <span class="n">not</span> <span class="n">at</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">the</span> <span class="n">list</span>
    <span class="n">move</span> <span class="n">slow</span> <span class="n">by</span> <span class="mi">1</span>
    <span class="n">move</span> <span class="n">fast</span> <span class="n">by</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">slow</span> <span class="n">equals</span> <span class="n">fast</span><span class="p">,</span> <span class="k">return</span> <span class="kc">true</span>
    
<span class="k">return</span> <span class="kc">false</span> 
</div></code></pre><p>Very straight forward. I want to touch on how we would compare the 2 nodes though. We could compare the 2 node values, but that wouldn't help if our list has nodes with multiple of the same value. We could conform the node class to <strong>Equatable</strong> which gives us a way of determining the equality of 2 different class instances. But by far the easiest way in this situation, is to use the built in Swift <strong>===</strong> operator. The 3 equals sign operator compares if 2 objects share the same reference in memory. That is a sure fire way to determine if 2 nodes are the same.</p><p>The time complexity here is on average O(n) since we need to traverse the list 1 time when there is not a cycle, and 1 time + some change when there is a cycle. This averages out to O(n) time. The space complexity is O(1) since we do not have any data structures to hold our data, we just have 2 pointers which are constant time.</p><p>Let's check out the implementation!</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">slow</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">?</span> <span class="p">=</span> <span class="n">head</span> 
<span class="kd">var</span> <span class="nv">fast</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">?</span> <span class="p">=</span> <span class="n">head</span>

<span class="k">while</span> <span class="n">fast</span><span class="p">?.</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// While fast is not at the end of the list</span>
    <span class="n">slow</span> <span class="p">=</span> <span class="n">slow</span><span class="p">?.</span><span class="n">next</span>
    <span class="n">fast</span> <span class="p">=</span> <span class="n">fast</span><span class="p">?.</span><span class="n">next</span><span class="p">?.</span><span class="n">next</span>
    <span class="k">if</span> <span class="n">slow</span> <span class="p">===</span> <span class="n">fast</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span> <span class="c1">// Compare fast &amp; slow memory references</span>
<span class="p">}</span>

<span class="k">return</span> <span class="kc">false</span>
</div></code></pre><p>I hope that was an easy one for you!</p><hr><h1>Merge K Sorted Lists</h1><p>Lets finish off this linked list section strong! Here is a bit of a toughie:</p><img src="https://swiftrefresher.com/mergeksortedlists.png"/><h3>[ Merge Sort ]</h3><h3>[ O(NLogK) time + O(N) space ]</h3><p>So if you haven't guessed already, this problem is an extension of our previous Merge Two Sorted Lists problem. This problem is exactly the same, except instead of 2 lists we have an unknown number of K lists.</p><p>A brute force solution to this problem would be to iterate through all lists, and find the proper location for the nodes, and merge. This is a lot of repeated and unnecessary work though.</p><p>We can be a little smarter and use a variation of Merge Sort. Say our K lists we want to merge are [1], [2], [5], [3]. The brute force way is to merge [2] into [1]. Then merge [5], into [1, 2]. To do this we iterate through the 1 node and 2 node. Then we repeat that work when we want to merge 3 into [1, 2, 5]. We iterate from 1 to 2 and insert 3. How can we be more efficient?</p><p>With our same example we can use Merge Sort. Lets say our input is once again [1], [2], [5], [3]. Instead of repeating work, we can merge 1 &amp; 2, then merge 5 &amp; 3. Now our K lists are [1, 2], [3, 5]. Then we can merge those 2 and get [1, 2, 3, 5]. That time we only merge 2 times, and we do not do repeated work.</p><p>Something like this:</p><pre><code><div class="highlight"><span></span><span class="k">while</span> <span class="n">the</span> <span class="bp">count</span> <span class="n">of</span> <span class="n">the</span> <span class="n">K</span> <span class="n">lists</span> <span class="k">is</span> <span class="n">greater</span> <span class="n">than</span> <span class="mi">1</span>
    <span class="n">keep</span> <span class="n">an</span> <span class="n">array</span> <span class="k">for</span> <span class="n">our</span> <span class="n">merged</span> <span class="n">lists</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">list</span> <span class="k">in</span> <span class="n">k</span>
        <span class="kr">get</span> <span class="n">list</span> <span class="mi">1</span>
        <span class="kr">get</span> <span class="n">list</span> <span class="mi">2</span>
        <span class="n">merge</span> <span class="n">them</span>
        <span class="n">add</span> <span class="n">to</span> <span class="n">our</span> <span class="n">merged</span> <span class="n">lists</span> <span class="n">array</span>
    <span class="kr">set</span> <span class="n">k</span> <span class="n">lists</span> <span class="bp">equal</span> <span class="n">to</span> <span class="n">merged</span> <span class="n">lists</span>
<span class="k">return</span> <span class="bp">first</span> <span class="k">in</span> <span class="n">k</span> <span class="n">lists</span>
</div></code></pre><p>The best part about this solution, is we already know how to merge 2 lists, so the only net-new code here from our previous problem, is keeping track of the current merged lists at each iteration. The time complexity here is O(NLogK), we are taking our lists, dividing them by 2 every time. We also need to iterate through every node, at every step of the way. This time comes out to O(KLogN) where N is the number of nodes in all lists, and k is the number of lists in the input. Space complexity is O(k), due to us keeping track of all the nodes in each merge iteration.</p><p>Lets check out the real iteration (this time, with a slightly different way of merging 2 lists 👀)</p><pre><code><div class="highlight"><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ListNode</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">var</span> <span class="nv">val</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">public</span> <span class="kd">var</span> <span class="nv">next</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">?</span>
    <span class="kd">public</span> <span class="kd">init</span><span class="p">()</span> <span class="p">{</span> <span class="kc">self</span><span class="p">.</span><span class="n">val</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="kc">self</span><span class="p">.</span><span class="n">next</span> <span class="p">=</span> <span class="kc">nil</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">public</span> <span class="kd">init</span><span class="p">(</span><span class="kc">_</span> <span class="n">val</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="kc">self</span><span class="p">.</span><span class="n">val</span> <span class="p">=</span> <span class="n">val</span><span class="p">;</span> <span class="kc">self</span><span class="p">.</span><span class="n">next</span> <span class="p">=</span> <span class="kc">nil</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">public</span> <span class="kd">init</span><span class="p">(</span><span class="kc">_</span> <span class="n">val</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">next</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">?)</span> <span class="p">{</span> <span class="kc">self</span><span class="p">.</span><span class="n">val</span> <span class="p">=</span> <span class="n">val</span><span class="p">;</span> <span class="kc">self</span><span class="p">.</span><span class="n">next</span> <span class="p">=</span> <span class="n">next</span><span class="p">;</span> <span class="p">}</span>
 <span class="p">}</span>

<span class="kd">func</span> <span class="nf">mergeKLists</span><span class="p">(</span><span class="kc">_</span> <span class="n">lists</span><span class="p">:</span> <span class="p">[</span><span class="n">ListNode</span><span class="p">?])</span> <span class="err">→</span> <span class="n">ListNode</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">lists</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">lists</span><span class="p">.</span><span class="bp">count</span> <span class="p">==</span> <span class="mi">1</span> <span class="p">{</span> <span class="k">return</span> <span class="n">lists</span><span class="p">.</span><span class="bp">first</span><span class="p">!</span> <span class="p">}</span>
    <span class="kd">var</span> <span class="nv">currLists</span> <span class="p">=</span> <span class="n">lists</span>
    <span class="k">while</span> <span class="n">currLists</span><span class="p">.</span><span class="bp">count</span> <span class="err">﹥</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nv">mergedLists</span> <span class="p">=</span> <span class="p">[</span><span class="n">ListNode</span><span class="p">?]()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="bp">stride</span><span class="p">(</span><span class="n">from</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">to</span><span class="p">:</span> <span class="n">currLists</span><span class="p">.</span><span class="bp">count</span><span class="p">,</span> <span class="n">by</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nv">listOne</span> <span class="p">=</span> <span class="n">currLists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="kd">var</span> <span class="nv">listTwo</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">?</span> <span class="p">=</span> <span class="kc">nil</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="err">﹤</span> <span class="n">currLists</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span> <span class="n">listTwo</span> <span class="p">=</span> <span class="n">currLists</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="p">}</span>
            <span class="n">mergedLists</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">mergeLists</span><span class="p">(</span><span class="n">listOne</span><span class="p">,</span> <span class="n">listTwo</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="n">currLists</span> <span class="p">=</span> <span class="n">mergedLists</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">currLists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">mergeLists</span><span class="p">(</span><span class="kc">_</span> <span class="n">listOne</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">?,</span> <span class="kc">_</span> <span class="n">listTwo</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">?)</span> <span class="err">→</span> <span class="n">ListNode</span><span class="p">?</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">dummy</span> <span class="p">=</span> <span class="n">ListNode</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">tail</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">?</span> <span class="p">=</span> <span class="n">dummy</span>
    <span class="kd">var</span> <span class="nv">listOne</span> <span class="p">=</span> <span class="n">listOne</span>
    <span class="kd">var</span> <span class="nv">listTwo</span> <span class="p">=</span> <span class="n">listTwo</span>
    
    <span class="k">while</span> <span class="n">listOne</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">listTwo</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">listOne</span><span class="p">!.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">listTwo</span><span class="p">!.</span><span class="n">val</span> <span class="p">{</span>
            <span class="n">tail</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">listOne</span>
            <span class="n">listOne</span> <span class="p">=</span> <span class="n">listOne</span><span class="p">!.</span><span class="n">next</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">tail</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">listTwo</span>
            <span class="n">listTwo</span> <span class="p">=</span> <span class="n">listTwo</span><span class="p">!.</span><span class="n">next</span>
        <span class="p">}</span>
        <span class="n">tail</span> <span class="p">=</span> <span class="n">tail</span><span class="p">?.</span><span class="n">next</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="n">listOne</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="n">tail</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">listOne</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">listTwo</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="n">tail</span><span class="p">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">listTwo</span> <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="n">next</span>
<span class="p">}</span>
</div></code></pre><p>Nicely done!</p><hr><h1>Conclusion</h1><p>Not too bad! Come back to these problems anytime you need a friendly linked list refresher 😎</p><hr>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/leetcode/blind-75-binary-search</guid><title>Blind 75: Binary Search</title><description>The programmers favorite searching mechanism!</description><link>https://swiftrefresher.com/leetcode/blind-75-binary-search</link><pubDate>Mon, 29 Aug 2022 16:31:00 -0400</pubDate><content:encoded><![CDATA[<h1>Binary Search</h1><p>So you have mastered the basic string and array problems. Awesome. Now we will be moving on to Binary Search. Binary Search is the most common searching mechanism, and really the only one seen in Leetcode problems. Let's give an overview of how Binary Search works, and why it is better than a common linear search.</p><p>So Swift has a built in method of searching for an element in an array, we could simply do:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">array</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">indexOfElement</span> <span class="p">=</span> <span class="n">array</span><span class="p">.</span><span class="n">firstIndex</span><span class="p">(</span><span class="n">of</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">indexOfElement</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 2</span>
</div></code></pre><p>Using the built-in Swift search, we can search our entire array to find the index of the element we are searching for. This is great if our element is in the beginning of the array, but if our element is at the very end of the array it becomes very time consuming. The built in Swift search, is a linear search, which gives us on average O(n) time. If our array has 1 million elements, it will on average take us 1 million steps to find the element. Ouch.</p><p>This is where Binary Search comes in. Binary Search takes O(Log(n)) time on average. So our 1 million element array, will only take us about 20 steps on average to find the element. Awesome. BUT, there is a downside to the Binary Search, and that is the array must be sorted in order. We will see why that is the case.</p><p>The way Binary Search works is:</p><ol><li>Find which half of the array our element is in (Left half vs Right half)</li><li>If the element is in the right half, we repeat this process with the right half of the array (and vice-versa for left half)</li><li>Repeat until the element is found</li><li>If we cannot split the array anymore, our element doesn't exist in our array</li></ol><p>As you can now see, we must have a sorted array when doing Binary Search. We can easily find which half of the array our element resides in, with a simple comparison operator like <code>&lt;</code> or <code>&gt;</code>. You will often hear Binary Search referred to as "Divide and Conquer" for this reason.</p><h3>Implementation</h3><p>Binary Search can be implemented both recursively and iteratively.</p><h4>Recursive</h4><p>The recursive implementation is very straight forward.</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="kc">_</span> <span class="n">array</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">range</span><span class="p">:</span> <span class="nb">Range</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">&gt;)</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">range</span><span class="p">.</span><span class="n">lowerBound</span> <span class="o">&gt;=</span> <span class="n">range</span><span class="p">.</span><span class="n">upperBound</span> <span class="p">{</span>
        <span class="c1">// If we get here, then the search key is not present in the array.</span>
        <span class="k">return</span> <span class="kc">nil</span>

    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Calculate where to split the array.</span>
        <span class="kd">let</span> <span class="nv">midIndex</span> <span class="p">=</span> <span class="n">range</span><span class="p">.</span><span class="n">lowerBound</span> <span class="o">+</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">upperBound</span> <span class="o">-</span> <span class="n">range</span><span class="p">.</span><span class="n">lowerBound</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        
        <span class="c1">// Is the search key in the left half?</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">midIndex</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">key</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span> <span class="n">range</span><span class="p">:</span> <span class="n">range</span><span class="p">.</span><span class="n">lowerBound</span> <span class="p">..</span><span class="o">&lt;</span> <span class="n">midIndex</span><span class="p">)</span>

        <span class="c1">// Is the search key in the right half?</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">midIndex</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">key</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span> <span class="n">range</span><span class="p">:</span> <span class="n">midIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">..</span><span class="o">&lt;</span> <span class="n">range</span><span class="p">.</span><span class="n">upperBound</span><span class="p">)</span>

        <span class="c1">// If we get here, then we&#39;ve found the search key!</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">midIndex</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">numbers</span> <span class="p">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">67</span><span class="p">]</span>

<span class="k">if</span> <span class="kd">let</span> <span class="nv">result</span> <span class="p">=</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="mi">43</span><span class="p">,</span> <span class="n">range</span><span class="p">:</span> <span class="mi">0</span> <span class="p">..</span><span class="o">&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="bp">count</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1">// gives 13</span>
<span class="p">}</span>
</div></code></pre><p>Pay a close bit of attention on how we anchor our left vs right halves of our array. The equation <strong>range.lowerBound + (range.upperBound - range.lowerBound) / 2</strong> is something you should remember as we can split both even and odd numbered arrays with this equation. Every time we find our element is in the left or right half of the array, we recursively pass the range of the new array back into our function. This saves us space by not having to keep variables for the left and right halves of the array.</p><p>It is also worth noting, that recursive implementations inherently come with O(n) space, due to our machine holding the function call stack in memory. Because of this, the iterative approach is favored here, for efficiency sake.</p><h4>Iterative</h4><p>The following is the iterative approach to the Binary Search:</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="kc">_</span> <span class="n">array</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">lowerBound</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">var</span> <span class="nv">upperBound</span> <span class="p">=</span> <span class="n">array</span><span class="p">.</span><span class="bp">count</span>
    <span class="k">while</span> <span class="n">lowerBound</span> <span class="o">&lt;</span> <span class="n">upperBound</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">midIndex</span> <span class="p">=</span> <span class="n">lowerBound</span> <span class="o">+</span> <span class="p">(</span><span class="n">upperBound</span> <span class="o">-</span> <span class="n">lowerBound</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">midIndex</span><span class="p">]</span> <span class="p">==</span> <span class="n">key</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">midIndex</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">midIndex</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">key</span> <span class="p">{</span>
            <span class="n">lowerBound</span> <span class="p">=</span> <span class="n">midIndex</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">upperBound</span> <span class="p">=</span> <span class="n">midIndex</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">numbers</span> <span class="p">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">67</span><span class="p">]</span>

<span class="k">if</span> <span class="kd">let</span> <span class="nv">result</span> <span class="p">=</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="mi">43</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1">// gives 13</span>
<span class="p">}</span>
</div></code></pre><p>Many recursive functions can be converted to iterative functions by using loops. Note the <strong>while</strong> loop here.</p><p>So that is Binary Search and how it works under the hood. Let's apply this to some Leetcode problems!</p><hr><h1>Search in Rotated Sorted Array</h1><p>Time to apply that Binary Search knowledge!</p><img src="https://swiftrefresher.com/searchrotatedsortedarray.png"/><p>This one can be a little tricky. We know from the intro in this article, that Binary Search takes a sorted array. But the input array in this problem is sorted around a pivot. So we cannot use Binary Search out of the box, we need to alter it a little. Considering the problem statement says our solution must be in O(logN) time, there really is no point figuring out a brute force, O(n) solution. Let's get into the Binary Search solution.</p><h3>[ Altered Binary Search ]</h3><h3>[ O(logN) time + O(1) space ]</h3><p>We need to think about how our input array is structured. We can still use Binary search in a way but we must be methodical. We know we will have a left pointer, right pointer &amp; middle pointer of our array. The question is though, is our middle element, in the left sorted half, or right sorted half? If our input array is [4, 5, 6, 7, 0, 1, 2] our midpoint will be 7. We know that 7 (our midpoint) is in the left sorted half of the array. How do we know this?</p><p>Well we can compare our midpoint to our leftPointer. If our midpoint is greater than or equal to our left pointer, our midpoint belongs in the left half of the array. Let's see another example. Say our input array is [7, 0, 1, 2, 3]. In this case our midpoint is not greater than or equal to our left pointer, thus our midpoint belongs to the right half of our array. Ok cool. Now what do we do when we figure out what side our midpoint belongs to?</p><p>Once we figure out which side of the array our midpoint belongs to, we can see if our target falls within the range of that side of the array. For example, say our input array is [4, 5, 6, 7, 0, 1, 2], we know the midpoint belongs to the left side of the array. So within the left side of the array, we need to check if our target falls in that range. If it does we need to search that half, if it doesn't we need to search the other side of the array. Our target in the example problem is 0. Considering we know the midpoint belongs to the left side of the array, we should compare our target to the array [4, 5, 6, 7]. Does our target fall within that range? No it doesn't, so we should check the other half of the array [0, 1, 2]. Then we repeat this process continuously until we find our element.</p><p>In pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">while</span> <span class="n">leftPointer</span> <span class="n">less</span> <span class="n">than</span> <span class="n">or</span> <span class="bp">equal</span> <span class="n">to</span> <span class="n">rightPointer</span> 
    <span class="k">if</span> <span class="n">our</span> <span class="n">midpoint</span> <span class="k">is</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">or</span> <span class="bp">equal</span> <span class="n">to</span> <span class="n">our</span> <span class="kr">left</span> <span class="n">pointer</span><span class="p">,</span> <span class="n">midpoint</span> <span class="k">is</span> <span class="k">in</span> <span class="n">the</span> <span class="kr">left</span> <span class="n">half</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">our</span> <span class="n">target</span> <span class="k">is</span> <span class="k">in</span> <span class="n">range</span> <span class="n">of</span> <span class="n">the</span> <span class="kr">left</span> <span class="n">side</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
            <span class="k">repeat</span> <span class="n">search</span> <span class="n">on</span> <span class="n">the</span> <span class="kr">left</span> <span class="n">side</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
        <span class="k">else</span> <span class="n">our</span> <span class="n">target</span> <span class="k">is</span> <span class="n">out</span> <span class="n">of</span> <span class="n">range</span> <span class="n">of</span> <span class="n">the</span> <span class="kr">left</span> <span class="n">side</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
            <span class="k">repeat</span> <span class="n">search</span> <span class="n">on</span> <span class="n">the</span> <span class="kr">right</span> <span class="n">side</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
    <span class="k">else</span> <span class="n">our</span> <span class="n">midpoint</span> <span class="k">is</span> <span class="k">in</span> <span class="n">the</span> <span class="kr">right</span> <span class="n">side</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">our</span> <span class="n">target</span> <span class="k">is</span> <span class="k">in</span> <span class="n">range</span> <span class="n">of</span> <span class="n">the</span> <span class="kr">right</span> <span class="n">side</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
            <span class="k">repeat</span> <span class="n">search</span> <span class="n">on</span> <span class="n">the</span> <span class="kr">right</span> <span class="n">half</span> <span class="n">of</span> <span class="n">array</span>
        <span class="k">else</span> <span class="n">our</span> <span class="n">target</span> <span class="k">is</span> <span class="n">out</span> <span class="n">of</span> <span class="n">range</span> <span class="n">of</span> <span class="n">the</span> <span class="kr">right</span> <span class="n">side</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
            <span class="k">repeat</span> <span class="n">search</span> <span class="n">on</span> <span class="n">the</span> <span class="kr">left</span> <span class="n">half</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
            
</div></code></pre><p>That gets a little wordy! But it outlines our intent very well. As discussed here earlier, the time complexity is O(logN) due to Binary Search, and O(1) space because we are not storing anything here. The real implementation is as follows:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">var</span> <span class="nv">rightPointer</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span>
        
<span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;=</span> <span class="n">rightPointer</span> <span class="p">{</span> <span class="c1">// While our pointers are still valid</span>
    <span class="kd">let</span> <span class="nv">mid</span> <span class="p">=</span> <span class="n">leftPointer</span> <span class="o">+</span> <span class="p">(</span><span class="n">rightPointer</span> <span class="o">-</span> <span class="n">leftPointer</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="c1">// Find the midpoint of our array</span>
    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="p">==</span> <span class="n">target</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mid</span> <span class="p">}</span> <span class="c1">// We have found our element!</span>
    
    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// Our midpoint is in the left half of the array</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">||</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// Target is not in range of the left half</span>
            <span class="n">leftPointer</span> <span class="p">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// Move left pointer</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// Target is in range of the left half</span>
            <span class="n">rightPointer</span> <span class="p">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// Move right pointer   </span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// Our midpoint is in the right half of the array</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">||</span> <span class="n">target</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// Target is not in range of the right half</span>
            <span class="n">rightPointer</span> <span class="p">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// Move right pointer</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">leftPointer</span> <span class="p">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// Move left pointer</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</div></code></pre><p>Well Done!</p><p>---</p><h1>Find Minimum in Rotated Sorted Array</h1><p>This problem is actually more straight forward than our last one.</p><img src="https://swiftrefresher.com/minimuminsortedarray.png"/><p>There should be a couple flags here that let us know this is a Binary Search array type problem. First, the problem states the input array is in sorted (but rotated) order, and second, we need an O(LogN) time solution. When we see a combination of these two things, we know it is most likely a Binary Search problem.</p><h3>[ Altered Binary Search ]</h3><h3>[ O(logN) time + O(1) space ]</h3><p>This approach is like a slightly altered version of Binary Search. Since our input array is sorted but rotated an unknown amount of times, we don't exactly know where our pivot point is. If we take a look at the previous problem, we can check the midpoint and compare it to the rightmost array element to see if our midpoint belongs to the left or right side of the array. Using that information we can search the right and left arrays continuously until we run out of elements to search.</p><p>We will also want to keep a variable for the minimum element in the array. We can use our midpoint anchor to track which element is our smallest.</p><p>BUT, there is one situation we should also be aware of. If our array is sorted, based on our left and right pointers, we can break out of our loop, because we know the smallest element will be the leftmost element. Here is the pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">while</span> <span class="n">leftPointer</span> <span class="n">less</span> <span class="n">than</span> <span class="n">or</span> <span class="bp">equal</span> <span class="n">to</span> <span class="n">rightPointer</span> 
    <span class="k">if</span> <span class="n">our</span> <span class="n">array</span> <span class="k">is</span> <span class="bp">sorted</span>
        <span class="bp">min</span> <span class="k">is</span> <span class="n">leftmost</span> <span class="n">element</span>
        <span class="k">break</span> <span class="n">from</span> <span class="n">loop</span>
    <span class="n">update</span> <span class="n">minimum</span> <span class="n">element</span> <span class="n">with</span> <span class="n">midPointer</span> <span class="k">as</span> <span class="n">needed</span>
    <span class="k">if</span> <span class="n">midPointer</span> <span class="o">&gt;</span> <span class="n">rightPointer</span>
        <span class="n">search</span> <span class="kr">right</span> <span class="n">half</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
    <span class="k">else</span> <span class="n">search</span> <span class="kr">left</span> <span class="n">half</span> <span class="n">of</span> <span class="n">array</span>
        
</div></code></pre><p>As discussed here earlier, the time complexity is O(logN) due to Binary Search, and O(1) space because we are not storing anything here, aside from a minimum element variable. The real implementation is below:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">mini</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">.</span><span class="bp">max</span> <span class="c1">// Some default value</span>
<span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">var</span> <span class="nv">rightPointer</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span>

<span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;=</span> <span class="n">rightPointer</span> <span class="p">{</span> <span class="c1">// While our pointers are still valid</span>
    <span class="k">guard</span> <span class="n">nums</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// If our array is sorted </span>
        <span class="n">mini</span> <span class="p">=</span> <span class="bp">min</span><span class="p">(</span><span class="n">mini</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">])</span> <span class="c1">// Update global minimum</span>
        <span class="k">break</span> <span class="c1">// Break from loop</span>
    <span class="p">}</span>
    
    <span class="kd">let</span> <span class="nv">mid</span> <span class="p">=</span> <span class="n">leftPointer</span> <span class="o">+</span> <span class="p">(</span><span class="n">rightPointer</span> <span class="o">-</span> <span class="n">leftPointer</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">mini</span> <span class="p">=</span> <span class="bp">min</span><span class="p">(</span><span class="n">mini</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span> <span class="c1">// Update global minimum</span>
    
    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// Midpoint belongs to the right half of the array</span>
        <span class="n">leftPointer</span> <span class="p">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// Midpoint belongs to the left half of the array</span>
        <span class="n">rightPointer</span> <span class="p">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">mini</span>
</div></code></pre><hr><h1>Conclusion</h1><p>Keep an eye out when you see sorted input arrays, and problems that require O(logN) time complexity, this usually points to a classic Binary Search problem!</p><hr>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/combine/combine-201</guid><title>Combine 201: Diving a little deeper</title><description>Taking our combine knowledge a little further</description><link>https://swiftrefresher.com/combine/combine-201</link><pubDate>Mon, 22 Aug 2022 18:38:00 -0400</pubDate><content:encoded><![CDATA[<h1>Combine 201: Diving a little deeper</h1><p>We got familiar with combine in our <a href="https://swiftrefresher.com/combine/intro-to-combine">Combine 101 Article</a>, so now it is time to further our knowledge a bit with some deeper Combine principles.</p><p>As a refresher, Publishers publish values to objects that subscribe to the data. These objects are called Subscribers. One thing we didn't touch on a lot though, is how simple swift allows our Publisher/Subscriber relationship to be.</p><p>Let's say for example we have a Publisher, and we want to extrapolate, or mutate some data from our publishing stream. We could do something like this:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="n">Just</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="n">publisher</span><span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span> <span class="p">},</span> <span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">values</span> <span class="k">in</span>
    <span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">values</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// check if the number is even, if it is, print it!</span>
            <span class="bp">print</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})</span>
</div></code></pre><p>In the above code, we are printing all even numbers from the array of numbers published by our Publisher. But with the Combine Library, swift makes this much more simple! We can combine (get it 😎) multiple publishers together as long as they have matching same input &amp; output values. So our above code turns into this:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="n">Just</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="kd">let</span> <span class="nv">output</span> <span class="p">=</span> <span class="n">publisher</span>
    <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="bp">filter</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">==</span> <span class="mi">0</span>  <span class="p">}</span> <span class="p">}</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">})</span>
</div></code></pre><p>When this code is ran we have our same logic. We receive an array of values from the Publisher, filter on them to find the even numbers, and then print the result. In this case we use the map operator on our defined Publisher. This function is called an operator on a Publisher, and these operators can be chained together to make some really cool &amp; clean code. Let's go over a few common operators.</p><h2>Combine Operators</h2><p>So we already went over <strong>.map()</strong> and it works exactly like map does in the Swift foundational library. We use it to map over the list of elements and transform the element as needed. Let's go over some of the most common operators available to us.</p><h3>dropFirst</h3><p>The first common operator we will be covering is <code>dropFirst</code>. Just as its name suggests, it will drop the first value the publisher receives, and will continue publishing all values after that. We can also specify how many preceding values we ignore by passing an integer as a parameter into <code>dropFirst(_)</code></p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">]].</span><span class="n">publisher</span>

<span class="kd">let</span> <span class="nv">output</span> <span class="p">=</span> <span class="n">publisher</span>
    <span class="p">.</span><span class="n">compactMap</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
    <span class="p">.</span><span class="n">flatMap</span><span class="p">({</span> <span class="nv">$0</span><span class="p">.</span><span class="n">publisher</span> <span class="p">})</span>
    <span class="p">.</span><span class="bp">dropFirst</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">})</span>
    
<span class="c1">// 5, 6, 7</span>
</div></code></pre><p>In this example we dropped both 1 &amp; 4 from the stream.</p><h3>compactMap</h3><p>As you can imagine based on it's predecessor, compact map will return a list of non-nil values if we give the publisher a list of Optional values, like an array of [Int?] for example.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="kc">nil</span><span class="p">].</span><span class="n">publisher</span>

<span class="kd">let</span> <span class="nv">output</span> <span class="p">=</span> <span class="n">publisher</span>
    <span class="p">.</span><span class="n">compactMap</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">})</span>

<span class="c1">// 1, 4, 5, 6, 7</span>
</div></code></pre><h3>flatMap</h3><p>flatMap will concatenate all of the nested elements of a sequence into one 'flat' sequence. This works well when dealing with an array of array's.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">]].</span><span class="n">publisher</span>

<span class="kd">let</span> <span class="nv">output</span> <span class="p">=</span> <span class="n">publisher</span>
    <span class="p">.</span><span class="n">compactMap</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
    <span class="p">.</span><span class="n">flatMap</span><span class="p">({</span> <span class="nv">$0</span><span class="p">.</span><span class="n">publisher</span> <span class="p">})</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">})</span>
    
<span class="c1">// 1, 4, 5, 6, 7</span>
</div></code></pre><h3>contains</h3><p>Just like the Swift <strong>contains</strong> function commonly found on sequences, the Combine library sequence will return a published boolean if the value it receives contains a specific value.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">]].</span><span class="n">publisher</span>

<span class="kd">let</span> <span class="nv">output</span> <span class="p">=</span> <span class="n">publisher</span>
    <span class="p">.</span><span class="n">compactMap</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
    <span class="p">.</span><span class="n">flatMap</span><span class="p">({</span> <span class="nv">$0</span><span class="p">.</span><span class="n">publisher</span> <span class="p">})</span>
    <span class="p">.</span><span class="bp">contains</span><span class="p">(</span><span class="k">where</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">==</span> <span class="mi">5</span> <span class="p">})</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">})</span>

<span class="c1">// true</span>
</div></code></pre><p>From our earlier example, our publisher is emitting the 5 value, so our publisher would return true.</p><h3>first</h3><p>Here we pass the closure some predicate to look for in our sequence, and return the first value to satisfy our defined predicate.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">]].</span><span class="n">publisher</span>

<span class="kd">let</span> <span class="nv">output</span> <span class="p">=</span> <span class="n">publisher</span>
    <span class="p">.</span><span class="n">compactMap</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
    <span class="p">.</span><span class="n">flatMap</span><span class="p">({</span> <span class="nv">$0</span><span class="p">.</span><span class="n">publisher</span> <span class="p">})</span>
    <span class="p">.</span><span class="bp">first</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">==</span> <span class="mi">5</span> <span class="p">}</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">})</span>
</div></code></pre><p>In this example we look for the first even value, which is 4 in our case.</p><p>There are tons of Publisher operators out there, so our list just touches the tip of the iceberg! I would suggest checking out the Apple documentation for a comprehensive list of available operators. This brings us to our next Combine topic...</p><h2>AnyCancellable's</h2><p>Swift's <strong>Cancellable</strong> type is foundational to how we use combine, and for reactive principles as a whole. Ideally if we have a stream of information being published, there is a chance we will want to cancel this stream of info after a given time.</p><p>Let's start at the bottom. Swift gives us a <code>Cancellable</code> protocol we can conform to, if we want an activity that supports cancellation. The protocol has support for a function called <strong>cancel()</strong> which from Apple: "frees up any allocated resources. It also stops side effects such as timers, network access, or disk I/O.". Ok Cool. We can support a cancellation function, that frees up resources, but what does that mean for us?</p><p>Apple also gives us an <strong>AnyCancellable</strong> type, which is a type-erased, Cancellable conforming, object. This object executes a closure on cancellation. So essentially when we go to create an AnyCancellable, we can initialize it with some work to do, when it finally cancels. From the Apple documentation, "An AnyCancellable instance automatically calls cancel() when deinitialized". So this is interesting, when the object is deallocated from memory, the object will call <strong>cancel()</strong> on itself, and thus the closure we initialized it with. Ok, that makes sense.</p><p>So if we piece this together, we can safely assume the purpose of <strong>AnyCancellable</strong> is to hold a reference to the subscription somewhere other than the subscription itself. If our object we retain the subscription on gets deallocated, our <strong>AnyCancellable</strong> will also get deallocated and thus will call <strong>cancel()</strong> on itself. This will then free up all resources held by the subscription.</p><p>So in summary, when we subscribe to a publisher using a built-in function like <strong>sink</strong> or <strong>assign</strong>, the function returns us an <strong>AnyCancellable</strong>. This <strong>AnyCancellable</strong> type will free up all resources whenever it is deallocated. And we must retain this <strong>AnyCancellable</strong> in our parent object because we do not want our subscriptions to get automatically deallocated whenever we leave the scope of their creation!!</p><p>It might be easier to see in code:</p><pre><code><div class="highlight"><span></span><span class="kd">class</span> <span class="nc">ViewModel</span> <span class="p">{</span>
    <span class="kd">init</span><span class="p">(){}</span>
    
    <span class="kd">func</span> <span class="nf">doSomeWork</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Timer</span>
            <span class="p">.</span><span class="n">publish</span><span class="p">(</span><span class="n">every</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">on</span><span class="p">:</span> <span class="n">RunLoop</span><span class="p">.</span><span class="n">main</span><span class="p">,</span> <span class="k">in</span><span class="p">:</span> <span class="p">.</span><span class="k">default</span><span class="p">)</span>
            <span class="p">.</span><span class="n">autoconnect</span><span class="p">()</span>
            <span class="p">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">date</span> <span class="k">in</span>
                <span class="bp">print</span><span class="p">(</span><span class="n">date</span><span class="p">.</span><span class="n">ISO8601Format</span><span class="p">())</span>
            <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Here we have some view model, in which we want to print the date every 1 second. But when we run this, nothing happens!! This is because of what we talked about earlier. As soon as our <strong>doSomeWork()</strong> scope function ends, our <strong>AnyCancellable</strong> that is returned from sink is deallocated because we did not store it anywhere. One simple change can fix this:</p><pre><code><div class="highlight"><span></span><span class="kd">class</span> <span class="nc">ViewModel</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kd">var</span> <span class="nv">cancellable</span><span class="p">:</span> <span class="n">AnyCancellable</span><span class="p">?</span>
    <span class="kd">init</span><span class="p">(){}</span>
    
    <span class="kd">func</span> <span class="nf">doSomeWork</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">cancellable</span> <span class="p">=</span> <span class="n">Timer</span>
            <span class="p">.</span><span class="n">publish</span><span class="p">(</span><span class="n">every</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">on</span><span class="p">:</span> <span class="n">RunLoop</span><span class="p">.</span><span class="n">main</span><span class="p">,</span> <span class="k">in</span><span class="p">:</span> <span class="p">.</span><span class="k">default</span><span class="p">)</span>
            <span class="p">.</span><span class="n">autoconnect</span><span class="p">()</span>
            <span class="p">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">date</span> <span class="k">in</span>
                <span class="bp">print</span><span class="p">(</span><span class="n">date</span><span class="p">.</span><span class="n">ISO8601Format</span><span class="p">())</span>
            <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>By assigning our cancellable to a property in our view model, as long as our view model stays alive, our subscription does as well! Neat! One last topic in our Combine 201 article...</p><h2>How to debug with Combine</h2><p>Debugging Combine can be very difficult with long stack traces &amp; confusing/ambiguous messages in our console.</p><h3>Print</h3><p>I gave a preview of one way we can debug in the <a href="https://swiftrefresher.com/combine/intro-to-combine">Combine 101 Article</a>, but didn't expand upon it. In the previous article we used <strong>print()</strong> to output in our console. We can just add the print operator to our data stream. and Ta-Da! The console will print out the lifecycle of our publisher like so:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;Cow&quot;</span><span class="p">,</span> <span class="s">&quot;Pig&quot;</span><span class="p">,</span> <span class="s">&quot;Human&quot;</span><span class="p">].</span><span class="n">publisher</span>

<span class="kd">let</span> <span class="nv">_</span> <span class="p">=</span> <span class="n">publisher</span>
    <span class="p">.</span><span class="bp">print</span><span class="p">()</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span> <span class="p">})</span>
 
 
<span class="c1">// console:</span>

<span class="c1">// receive subscription: ([&quot;Cow&quot;, &quot;Pig&quot;, &quot;Human&quot;])</span>
<span class="c1">// request unlimited</span>
<span class="c1">// receive value: (Cow)</span>
<span class="c1">// receive value: (Pig)</span>
<span class="c1">// receive value: (Human)</span>
<span class="c1">// receive finished</span>
</div></code></pre><p>Here we can see we receive a subscription, and our request is unlimited (our stream can theoretically stream an infinite # of values). Then our receiveValue closure is called 3 times, once for each of our array values, and we receive a message for when the stream is finished. This is very helpful in case you want to track down the lifecycle of your subscription and if some values are not being received as expected!</p><h3>HandleEvents</h3><p><strong>handleEvents()</strong> is pretty nice because we can handle every possible event our subscription can give us. It has the same events that were printed for the <strong>print()</strong> operator, except this time we can pass custom closures for each event to handle it our own way if desired. Each of these closures are optional so we can only use specific ones for our use case!</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;Cow&quot;</span><span class="p">,</span> <span class="s">&quot;Pig&quot;</span><span class="p">,</span> <span class="s">&quot;Human&quot;</span><span class="p">].</span><span class="n">publisher</span>

<span class="kd">let</span> <span class="nv">_</span> <span class="p">=</span> <span class="n">publisher</span>
    <span class="p">.</span><span class="n">handleEvents</span><span class="p">(</span><span class="n">receiveSubscription</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="n">subscription</span><span class="p">)</span> <span class="k">in</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Receive subscription </span><span class="si">\(</span><span class="n">subscription</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">},</span> <span class="n">receiveOutput</span><span class="p">:</span> <span class="p">{</span> <span class="n">output</span> <span class="k">in</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Received output: </span><span class="si">\(</span><span class="n">output</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">},</span> <span class="n">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Receive completion </span><span class="si">\(</span><span class="n">completion</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">},</span> <span class="n">receiveCancel</span><span class="p">:</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Receive cancel&quot;</span><span class="p">)</span>
    <span class="p">},</span> <span class="n">receiveRequest</span><span class="p">:</span> <span class="p">{</span> <span class="n">demand</span> <span class="k">in</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Receive request: </span><span class="si">\(</span><span class="n">demand</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">}).</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span> <span class="p">})</span>
    
<span class="c1">// console:</span>

<span class="c1">// Receive subscription [&quot;Cow&quot;, &quot;Pig&quot;, &quot;Human&quot;]</span>
<span class="c1">// Receive request: unlimited</span>
<span class="c1">// Received output: Cow</span>
<span class="c1">// Received output: Pig</span>
<span class="c1">// Received output: Human</span>
<span class="c1">// Receive completion finished</span>
</div></code></pre><h3>Breakpoint</h3><p>Swift went above and beyond with this one! We can trigger a breakpoint as an operator within a combine subscription stream. The closure requires to have a Boolean condition, when if the condition is met, we will trigger a breakpoint.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;Cow&quot;</span><span class="p">,</span> <span class="s">&quot;Pig&quot;</span><span class="p">,</span> <span class="s">&quot;Human&quot;</span><span class="p">].</span><span class="n">publisher</span>

<span class="kd">let</span> <span class="nv">_</span> <span class="p">=</span> <span class="n">publisher</span>
    <span class="p">.</span><span class="n">breakpoint</span><span class="p">(</span><span class="n">receiveOutput</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">==</span> <span class="s">&quot;Pig&quot;</span> <span class="p">})</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span> <span class="p">})</span>
</div></code></pre><p>With this code, when our data stream receives our 2nd value of Pig, Xcode will stop execution for us in the form of a breakpoint. This is because of the closure we passed into the breakpoint operator. This could come in handy!</p><h2>Conclusion</h2><p>We continue to further our skills within Combine. Whether it be how to debug combine errors when we come across them, different operators we can use to manipulate our data stream, and how <strong>AnyCancellable</strong> works under the hood. There is more to learn but we have come a long way!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/leetcode/blind-75-stack</guid><title>Blind 75: Stacks</title><description>A short introduction into Stacks</description><link>https://swiftrefresher.com/leetcode/blind-75-stack</link><pubDate>Tue, 16 Aug 2022 11:02:00 -0400</pubDate><content:encoded><![CDATA[<h1>Intro</h1><p>This will be a very short article, as the Blind 75 list only contains 1 problem revolving around the stack data structure. It is still a good pattern to learn, as there are several stack problems you may encounter, but they all follow the same pattern.</p><p>Stacks are like limited arrays. Stacks are also LIFO (Last-In-First-Out Ordering), such that the last element you push on to it, is the first one that will be removed. You can think of them like Stacks of plates. Stacks feature several functions for the user to interact with, such as: <strong>Pop</strong> <strong>Peek</strong> and <strong>Push</strong>.</p><ul><li><strong>Push</strong> as you would expect pushes a new value on to the stack. Adding at the end on an array is O(1); it always takes the same amount of time, regardless of the size of the array.</li><li><strong>Peek</strong> allows you to view the top most object in the stack, without removing it from the stack entirely.</li><li><strong>Pop</strong> removes the top-most value from the stack, and it is gone forever from the stack.</li></ul><p>The term "Stack Overflow" is based on the Stack data structure. When your CPU continually pushes return addresses onto a stack, but those addresses are never removed, your CPU Stack memory 'overflows' and crashes your application. This can happen in infinite loops when the return address of your function is never removed from memory.</p><h1>Valid Parentheses</h1><p>Here is a very well-known Stack problem. It is a leetcode easy so let's briefly run through it together.</p><img src="https://swiftrefresher.com/validparentheses.png"/><h3>Brute Force</h3><p>Since we know this is a stack problem, let's derive a brute force solution. First off, we need to know whether to push or pop characters on the stack. If know if the character is a closing bracket, we will not be pushing on to the stack. The quickest way to check this in constant time is a HashTable given the consistent lookup they give us.</p><p>So to start, we need a dictionary to search the beginning and ending brackets. Something resembling [")":"(" , "]": "[" , "}": "{"].</p><p>Now we go character by character. If the character is a key in our dictionary, and the value equals that key, we can pop off the stack. If by the end of our traversal we have a non-empty stack we know the string is not valid.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">string</span>
    <span class="k">if</span> <span class="n">top</span> <span class="n">of</span> <span class="n">stack</span> <span class="n">equals</span> <span class="n">the</span> <span class="n">inverse</span> <span class="n">bracket</span> <span class="n">of</span> <span class="n">our</span> <span class="n">letter</span><span class="p">,</span> <span class="n">pop</span> <span class="n">from</span> <span class="n">the</span> <span class="n">stack</span> 
    <span class="k">else</span> <span class="n">push</span> <span class="n">on</span> <span class="n">the</span> <span class="n">stack</span>
    
<span class="k">return</span> <span class="k">if</span> <span class="n">stack</span> <span class="k">is</span> <span class="n">empty</span>
</div></code></pre><p>Time complexity here at worst is O(n), because we need to traverse every letter in the string. Peeking pushing and popping from a stack is O(1) time. Space complexity here is O(1) due to the fixed nature of our hashTable. It does not grow.</p><p>This solution is great and all but there are certain scenarios in which we are doing extra work. Think of the example "()]()", if in the middle of our iteration we encounter a non-balanced character, we know we can return false early. Let's dive deeper into this.</p><h3>[ Enhanced Stack ]</h3><h3>[ O(n) average time + O(1) space ]</h3><p>We need to think when we would find a time to return from the function early.</p><p>First off, we know we should push onto the stack, if we encounter an opening brace. We can explicitly check for that.</p><p>Second off, if we encounter a closing bracket (another explicit check), we should check if the stack is empty. If the stack is empty, we can bail early because there is not an associated opening bracket for our close bracket.</p><p>Pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">string</span>
    <span class="k">if</span> <span class="n">opening</span> <span class="n">bracket</span>
        <span class="n">push</span> <span class="n">on</span> <span class="n">stack</span>
    <span class="k">if</span> <span class="n">closing</span> <span class="n">bracket</span>
        <span class="k">if</span> <span class="n">stack</span> <span class="n">empty</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="k">else</span> 
            <span class="k">if</span> <span class="n">the</span> <span class="n">top</span> <span class="n">of</span> <span class="n">the</span> <span class="n">stack</span> <span class="k">is</span> <span class="n">the</span> <span class="n">inverse</span> <span class="n">of</span> <span class="n">our</span> <span class="n">closing</span> <span class="n">bracket</span>
                <span class="n">pop</span> <span class="n">from</span> <span class="n">stack</span>
            <span class="k">else</span> 
                <span class="k">return</span> <span class="kc">false</span>

<span class="k">return</span> <span class="n">stack</span> <span class="k">is</span> <span class="n">empty</span> <span class="n">or</span> <span class="n">not</span>
</div></code></pre><p>This keeps the same time complexity &amp; space complexity from earlier, but it just saves us some work in specific input cases. Here is the final solution:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">stack</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Character</span><span class="p">]()</span>
<span class="kd">var</span> <span class="nv">hash</span><span class="p">:</span> <span class="p">[</span><span class="nb">Character</span><span class="p">:</span><span class="nb">Character</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;)&quot;</span><span class="p">:</span><span class="s">&quot;(&quot;</span><span class="p">,</span> <span class="s">&quot;}&quot;</span><span class="p">:</span><span class="s">&quot;{&quot;</span><span class="p">,</span><span class="s">&quot;]&quot;</span><span class="p">:</span><span class="s">&quot;[&quot;</span><span class="p">]</span>

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">letter</span> <span class="p">==</span> <span class="s">&quot;(&quot;</span> <span class="o">||</span> <span class="n">letter</span> <span class="p">==</span> <span class="s">&quot;{&quot;</span> <span class="o">||</span> <span class="n">letter</span> <span class="p">==</span> <span class="s">&quot;[&quot;</span> <span class="p">{</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">letter</span> <span class="p">==</span> <span class="s">&quot;)&quot;</span> <span class="o">||</span> <span class="n">letter</span> <span class="p">==</span> <span class="s">&quot;}&quot;</span> <span class="o">||</span> <span class="n">letter</span> <span class="p">==</span> <span class="s">&quot;]&quot;</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="n">stack</span><span class="p">.</span><span class="bp">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stack</span><span class="p">.</span><span class="bp">last</span><span class="p">!</span> <span class="p">==</span> <span class="n">hash</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">popLast</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">stack</span><span class="p">.</span><span class="bp">count</span> <span class="p">==</span> <span class="mi">0</span>
</div></code></pre><p>Cheers! On to the next section.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/leetcode/blind-75-sliding-window</guid><title>Blind 75: Sliding Window Problems</title><description>Getting crazy with arrays!</description><link>https://swiftrefresher.com/leetcode/blind-75-sliding-window</link><pubDate>Tue, 19 Jul 2022 18:02:00 -0400</pubDate><content:encoded><![CDATA[<h1>Best Time to Buy and Sell Stock</h1><p>This is a good strategy for iterating on array problems. Let's build the foundation!</p><img src="https://swiftrefresher.com/besttimebuysellstock.png"/><p>This is a very straightforward problem with real world application. Lets take it step by step.</p><h3>Brute Force</h3><p>A brute force solution here is obvious, let's go through each element in the array, and iterate every combination of elements to find the maximum profit.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">currentMaxProfit</span> <span class="o">&gt;</span> <span class="bp">max</span> <span class="n">profit</span> <span class="n">AND</span> <span class="n">currentMaxProfit</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="bp">max</span> <span class="n">profit</span> <span class="p">=</span> <span class="n">currentMaxProfit</span>
            
<span class="k">return</span> <span class="bp">max</span> <span class="n">profit</span> 
</div></code></pre><p>This is a very inefficient solution, with the time constraint being O(n²). We at least have consistent space because we only hold a variable for the max profit. There is a better way of going about this problem though.<br><br>For this problem, we should approach using the sliding window methodology.</p><h3>[ Sliding Window ]</h3><h3>[ O(n) worst time + O(1) space ]</h3><p>The sliding window is when we have 2 pointers representing a window range, and we either move the start of the window, or expand the window based on the criteria we are looking for. In this specific problem, we have 2 criteria:</p><ol><li>Move the first index (start of the window) when the end of the window is greater than the beginning of the window. In this scenario our profit would be negative so we need to reset our search.</li><li>Expand our window when we have the criteria for a possible max profit.</li></ol><p>Pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">while</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">the</span> <span class="n">window</span> <span class="k">is</span> <span class="n">within</span> <span class="n">the</span> <span class="n">bounds</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
    <span class="k">if</span> <span class="n">we</span> <span class="n">can</span> <span class="n">have</span> <span class="n">a</span> <span class="bp">max</span> <span class="n">profit</span>
        <span class="n">maxProfit</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="bp">max</span> <span class="n">profit</span><span class="p">,</span> <span class="n">current</span> <span class="n">profit</span><span class="p">)</span>
    <span class="k">else</span> 
        <span class="n">reset</span> <span class="n">beginning</span> <span class="n">of</span> <span class="n">window</span>
    <span class="n">end</span> <span class="n">of</span> <span class="n">window</span> <span class="n">append</span> <span class="n">by</span> <span class="mi">1</span>
</div></code></pre><p>At worst here we get, O(n) time performance. This is if we cannot have a viable maximum profit in the entire array. Space is still consistent, due to the various array pointers.</p><p>Let's go into implementation now.</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for cases we cannot create a window.</span>
<span class="k">guard</span> <span class="n">prices</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nv">maxProf</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// start max profit at zero</span>
<span class="kd">var</span> <span class="nv">start</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// beginning of window pointer</span>
<span class="kd">var</span> <span class="nv">end</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// end of window pointer</span>

<span class="k">while</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span> <span class="c1">// while the end of the window is within the bounds of the array</span>
    <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// if the first number is less than second and we have a possible profit</span>
        <span class="n">maxProf</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">maxProf</span><span class="p">,</span> <span class="n">prices</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">start</span><span class="p">])</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">start</span> <span class="p">=</span> <span class="n">end</span> <span class="c1">// reset window</span>
    <span class="p">}</span>
    <span class="n">end</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// move end of window always</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">maxProf</span>
</div></code></pre><p>Beautiful. This will be instrumental in future problems.</p><hr><h1>Longest Substring Without Repeating Characters</h1><p>Time to turn the heat on a little bit! This sliding window is a little different than before.</p><img src="https://swiftrefresher.com/longestsubstringwithoutrepeatchars.png"/><h3>Brute Force</h3><p>As with most array problems, if we use some nested loops to find our condition, we will arrive at the answer (albeit with extreme inefficiency).</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">we</span> <span class="n">have</span> <span class="n">not</span> <span class="n">seen</span> <span class="n">inner</span> <span class="n">letter</span> <span class="n">yet</span> <span class="k">in</span> <span class="n">this</span> <span class="n">iteration</span>
            <span class="n">add</span> <span class="n">to</span> <span class="n">our</span> <span class="n">iterative</span> <span class="bp">count</span>
            <span class="n">update</span> <span class="n">longest</span> <span class="k">if</span> <span class="n">possible</span>
        <span class="k">else</span>
            <span class="k">break</span>
            
<span class="k">return</span> <span class="n">longest</span> <span class="n">substring</span> <span class="n">char</span> <span class="bp">count</span> 
</div></code></pre><p>This solution is built on us keeping track of our current longest substring at any given iteration in the array. If we add to our current iterative substring count, we need to update our global variable as well. The condition for us to reset our search is if we find a character we have seen before.</p><p>Time complexity is O(n³) due to our nested loops and substring checking. Depending on our preferred method of searching for past letters, if we use a hash table, this search is consistent O(1). Space complexity is O(n) because we need a data structure that expands for the letters we have previously seen. HashTable space complexity is O(n) where n is the number of unique characters (at worst).</p><h3>[ Sliding Window ]</h3><h3>[ O(n²) worst time + O(n) space ]</h3><p>You guessed it! We have another sliding window problem. This time we need to be really careful with our 2 window conditions. Our 2 conditions are: expanding our window or reset the front of our window. The question is, what causes these conditions AND how specifically do we reset &amp; expand our window.</p><p>In our case, we know we need to expand our window when we have not seen a letter before (this includes the front of our window). To expand we can just move the end of our window by 1.</p><p>Otherwise we reset our window. BUT resetting our window only means we move the front by one. We need to ensure we do not skip any letter combinations.</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">a</span> <span class="n">hashtable</span> <span class="n">with</span> <span class="n">seen</span> <span class="n">letters</span>

<span class="k">while</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">our</span> <span class="n">window</span> <span class="k">is</span> <span class="k">in</span> <span class="n">bounds</span>
    <span class="k">if</span> <span class="n">we</span> <span class="n">have</span> <span class="n">not</span> <span class="n">seen</span> <span class="n">the</span> <span class="n">end</span> <span class="n">letter</span> <span class="n">before</span>
        <span class="c1">// expand</span>
        <span class="n">move</span> <span class="n">end</span> <span class="n">variable</span>
        <span class="n">update</span> <span class="n">global</span> <span class="n">variable</span>
        <span class="n">update</span> <span class="n">hashtable</span>
    <span class="k">else</span>
        <span class="c1">// reset window</span>
        <span class="n">move</span> <span class="n">start</span> <span class="n">of</span> <span class="n">window</span> <span class="mi">1</span> <span class="n">place</span>
        <span class="n">move</span> <span class="n">end</span> <span class="n">to</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">reset</span> <span class="n">hashtable</span>
        
<span class="k">return</span> <span class="n">global</span> <span class="n">variable</span>
        
</div></code></pre><p>Time complexity here is O(n²) at worst. This occurs when we have all unique characters in our string. Our loop will essentially check every combination of substrings in this case. Space complexity is O(n) due to the expansion of the hashtable. N is representative of unique characters in our string.</p><p>Time to implement!</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span> <span class="c1">// edge case check</span>
<span class="kd">var</span> <span class="nv">longest</span> <span class="p">=</span> <span class="mi">1</span>
<span class="kd">var</span> <span class="nv">start</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// window start</span>
<span class="kd">var</span> <span class="nv">end</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// window end</span>

<span class="kd">let</span> <span class="nv">letters</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1">// swift optimization</span>

<span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="n">letters</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="p">:</span> <span class="kc">true</span><span class="p">]</span> <span class="c1">// HashTable with 1st letter </span>

<span class="k">while</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span> <span class="p">{</span> <span class="c1">// While in bounds</span>
    <span class="kd">let</span> <span class="nv">startLetter</span> <span class="p">=</span> <span class="n">letters</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="kd">let</span> <span class="nv">endLetter</span> <span class="p">=</span> <span class="n">letters</span><span class="p">[</span><span class="n">end</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// expand window</span>
        <span class="n">end</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">longest</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">longest</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="c1">// update longest if possible</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span> <span class="c1">// add to hashTable</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// reset window start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// move start</span>
        <span class="n">end</span> <span class="p">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// reset end</span>
        <span class="n">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="n">letters</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="p">:</span> <span class="kc">true</span><span class="p">]</span> <span class="c1">// reset hash</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">longest</span>
</div></code></pre><p>Well done!</p><hr><h1>Longest Repeating Character Replacement</h1><p>This is a particularly unique sliding window problem. I personally struggled with this one. Let's dive in.</p><img src="https://swiftrefresher.com/longestrepeatingcharacterreplacement.png"/><h3>Brute Force</h3><p>There are a couple factors at play here. First off, we can check every substring available in the input string by using nested for loops. But as we check each substring what exactly are we looking for? In a given substring, we need to see if the number of letters we need to replace is less than our input K. And we know we need to replace all characters that are not equal to the most frequent character in a given substring.</p><p>Let's say for example we have a substring "ABAA" and K=2. We know that A is the most frequent letter, so every instance of a letter that isn't A needs replaced. So we can search the substring for all non-A letters and as long as that number is less than or equal to K, its a valid substring. It would look something like this</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">every</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">S</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">remaining</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">S</span>
        <span class="bp">find</span> <span class="bp">count</span> <span class="n">of</span> <span class="n">most</span> <span class="n">frequent</span> <span class="n">character</span>
        <span class="bp">count</span> <span class="n">of</span> <span class="n">everything</span> <span class="k">else</span> <span class="p">=</span> <span class="n">substring</span> <span class="n">length</span> <span class="o">-</span> <span class="n">most</span> <span class="n">frequent</span> 
        <span class="k">if</span> <span class="bp">count</span> <span class="n">of</span> <span class="n">everything</span> <span class="k">else</span> <span class="o">&lt;=</span> <span class="n">K</span>
            <span class="k">continue</span> <span class="n">inner</span> <span class="n">loop</span>
        <span class="k">else</span> 
            <span class="k">break</span> <span class="n">inner</span> <span class="n">loop</span>
</div></code></pre><p>Pretty darn inefficient right? Let's dive into time and space complexity here. The nested loops alone give us O(n²) time. Within our loops, finding the count of the most frequent letter is another search through our substring is another O(n) time. Total this gives us O(n³). Yikes. The space complexity is at worst O(n) where n is the length of the S input string. This is because we can never have to search a substring longer than the input string.</p><h3>[ Sliding Window + HashTable ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>So for efficiency sake here, we can speed a few things up. First off the searching a substring can be expedited with a HashTable. We can keep track of the counts for any given substring at all times, and have consistent time searching for each character count. We can also keep a global variable representing the most frequent character count.</p><p>For the nested loops, we can use a sliding window instead to massively decrease our algorithm time. If we have a valid substring, we can keep expanding our window to the right. If we do not have a valid substring, we need to shrink our window from the left (Move the start pointer forward). Here is the pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">string</span>
    <span class="n">add</span> <span class="n">to</span> <span class="n">hashTable</span>
    <span class="n">update</span> <span class="n">global</span> <span class="bp">max</span> <span class="n">character</span> <span class="n">frequency</span> <span class="n">value</span>
    
    <span class="k">while</span> <span class="n">our</span> <span class="n">substring</span> <span class="k">is</span> <span class="n">invalid</span>
        <span class="n">shrink</span> <span class="n">window</span> <span class="n">from</span> <span class="n">the</span> <span class="n">start</span>
        <span class="n">update</span> <span class="n">HashTable</span> <span class="n">accordingly</span>
        
    <span class="n">update</span> <span class="n">global</span> <span class="n">variable</span> <span class="k">for</span> <span class="n">our</span> <span class="n">result</span>
    
<span class="k">return</span> <span class="n">global</span>
</div></code></pre><p>With this solution, we have at worst O(n) time where n is the length of the input string. This is because the worst that can happen, is we expand our window all the way to the right, have the last letter make the substring invalid, and then shrink our window to the end. This averages out to be O(n) time. Space complexity is O(26N) because we know we are only using capital english letters, there are only 26 of those, so our HashTable storage will never be bigger than 26 Keys. This averages out to O(n) space.</p><p>Let's implement the real solution.</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">charCount</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Character</span><span class="p">:</span> <span class="nb">Int</span><span class="p">]()</span> <span class="c1">// HashTable to keep track of character counts in our substring</span>
<span class="kd">var</span> <span class="nv">maxCharCount</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// Max Character Count, largest in our HashTable at any given moment</span>
<span class="kd">var</span> <span class="nv">result</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// Our return result</span>
<span class="kd">var</span> <span class="nv">start</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// Start of window pointer</span>

<span class="kd">let</span> <span class="nv">sArr</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1">// Easy Char access in Swift</span>

<span class="k">for</span> <span class="n">end</span> <span class="k">in</span> <span class="mi">0</span> <span class="p">..</span><span class="o">&lt;</span> <span class="n">sArr</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span> <span class="c1">// while our end pointer is in bounds</span>
    <span class="kd">var</span> <span class="nv">currentWindowSize</span> <span class="p">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// get our current window size</span>
    <span class="kd">let</span> <span class="nv">endLetter</span> <span class="p">=</span> <span class="n">sArr</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="c1">// end letter</span>
    <span class="kd">var</span> <span class="nv">startLetter</span> <span class="p">=</span> <span class="n">sArr</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="c1">// start letter</span>
    
    <span class="n">charCount</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="p">=</span> <span class="n">charCount</span><span class="p">[</span><span class="n">endLetter</span><span class="p">,</span> <span class="k">default</span><span class="p">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// We have a new end letter, increment its count in the HashTable</span>
    <span class="n">maxCharCount</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">maxCharCount</span><span class="p">,</span> <span class="n">charCount</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span><span class="o">!</span><span class="p">)</span> <span class="c1">// See if the newly added letter, ups the maximum char count in the substring</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">currentWindowSize</span> <span class="o">-</span> <span class="n">maxCharCount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">k</span> <span class="p">{</span> <span class="c1">// If our substring is invalid (Our # of chars we need to change is bigger than we are allowed (K)  )</span>
        <span class="n">charCount</span><span class="p">[</span><span class="n">startLetter</span><span class="p">]</span> <span class="p">=</span> <span class="n">charCount</span><span class="p">[</span><span class="n">startLetter</span><span class="p">]</span><span class="o">!</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// Decrement the start of our window count, as we are shrinking our window</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// Shrink our window forward because string is invalid</span>
        
        <span class="n">currentWindowSize</span> <span class="p">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// Update window size</span>
        <span class="n">startLetter</span> <span class="p">=</span> <span class="n">sArr</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="c1">// Update Start Letter</span>
    <span class="p">}</span>
    <span class="n">result</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">currentWindowSize</span><span class="p">)</span> <span class="c1">// update our global result for the longest substring</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">result</span>
</div></code></pre><p>Sheesh!</p><hr><h1>Minimum Window Substring</h1><p>Ahhh our first Leetcode Hard. No need to fear!</p><img src="https://swiftrefresher.com/minimumwindowsubstring.png"/><h3>Brute Force</h3><p>So this is definitely a tricky one. It takes some in-depth thinking to even arrive at a brute force solution.</p><p>The idea behind the brute force solution is to keep 2 hash tables. One hash table containing character counts we need for our substring to be considered 'valid', and one hash table containing the character counts of our current sliding window substring. In our example problem where s = "ADOBECODEBANC", and t = "ABC", we know we will have a hash table representing the characters we need, and that hash table will be ['A': 1, 'B': 1, 'C': 1]. When we start our hash table for the character count in our substring will be ['A': 0, 'B': 0, 'C': 0], as we have not seen any of these letters yet.</p><p>Now we slide our window. What makes a substring valid? Well that is if: for every key in our haveHashTable, the character count is ≥ the corresponding letter count in the needHashTable. For example, in our starting substring of 'A'...our haveHashTable will be ['A': 1, 'B': 0, 'C': 0], but we know that its not a valid substring because the character counts for both 'B' and 'C' are ≤ the 'B' and 'C' counts in our needHashTable (the count for each of these is 1). We will continue to slide our window until our substring is valid. What happens when our substring is valid?</p><p>If we have a valid substring, we need to globally record the length, and update our result. Then we will pop from the start of our window, until our substring is no longer valid. The repeated work here, is every time we want to check if a substring is valid, we need to loop through every key in our haveHashTable. Gross!</p><p>It would look something like this:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">S</span>
    <span class="k">if</span> <span class="n">its</span> <span class="n">a</span> <span class="n">character</span> <span class="n">we</span> <span class="n">need</span><span class="p">,</span> <span class="n">update</span> <span class="n">haveHashTable</span>
    
    <span class="k">while</span> <span class="n">substring</span> <span class="k">is</span> <span class="n">valid</span>
        <span class="n">update</span> <span class="n">global</span> <span class="n">minimum</span> <span class="n">variable</span> <span class="k">as</span> <span class="n">applicable</span>
        <span class="n">pop</span> <span class="n">from</span> <span class="n">front</span> <span class="n">of</span> <span class="n">window</span> <span class="p">(</span><span class="n">update</span> <span class="n">haveHashTable</span><span class="p">,</span> <span class="n">and</span> <span class="n">move</span> <span class="n">the</span> <span class="n">start</span> <span class="n">of</span> <span class="n">the</span> <span class="n">window</span> <span class="mi">1</span> <span class="n">place</span> <span class="n">to</span> <span class="n">the</span> <span class="kr">right</span><span class="p">)</span>
        
<span class="k">return</span> <span class="n">minimum</span>
</div></code></pre><p>We know that we have O(n) time by searching through the entire string S, and if we need to go all the way forward, and then pop the front all the way to the back, that still averages out to O(n). We have O(26n) time for seeing if our substring is valid, which on average comes out to O(n) time. This comes out to be O(n²) at worst. Space complexity here is O(2n) because we need 2 hashTables that can be at most 26 Keys long, and on average O(2n) comes out to be O(n) space.</p><p>How can we make this better?</p><h3>[ Sliding Window + HashTables + Global Character Count Variables ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>The idea here is, we know we have repeated work by checking if a substring is valid. So we can tweak our logic a little bit to make this linear time. Let's keep two variables: One for the number of characters we have (the sum of all keys in haveHashTable) and one for the number of characters we need (the sum of all keys in needHashTable). If numberOfCharactersWeHave == numberOfCharactersWeNeed, then we know our substring is valid. For example in the substring 'ADOBEC', our needHashTable will be ['A': 1, 'B': 1, 'C': 1], and our haveHashTable will be ['A': 1, 'B': 1, 'C': 1]. The sum of all values for both of these hashTables = 3. Since 3 == 3, we know our substring is valid.</p><p>BUT, we need to be careful here. We should only update our numberOfCharactersWeHave if we slide the window into a character we actually need, and if the character count for what we have == its count for what we need. Also, when we pop from the start of our window, we should only decrement numberOfCharactersWeHave if the letter is something we need, and the substring is no longer valid (its count for what we have is less than its count for what we need). By doing these 2 things we satisfy our condition from the brute force solution.</p><p>In the brute force solution, we only have a valid substring if the character count in haveHashTable ≥ the corresponding letter count in the needHashTable. So with our new logic, we only decrement the character count if the count falls below our needHashTable threshold. Conversely, we only increment if our character counts are equal.</p><p>In pseudocode it looks like this:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">S</span>
    <span class="k">if</span> <span class="n">its</span> <span class="n">a</span> <span class="n">character</span> <span class="n">we</span> <span class="n">need</span><span class="p">,</span> <span class="n">update</span> <span class="n">haveHashTable</span>
    <span class="n">update</span> <span class="n">our</span> <span class="n">numberOfCharactersWeHave</span> <span class="n">only</span> <span class="k">if</span> <span class="n">the</span> <span class="n">end</span> <span class="n">letter</span> <span class="k">is</span> <span class="n">something</span> <span class="n">we</span> <span class="n">need</span> <span class="o">&amp;&amp;</span> <span class="n">its</span> <span class="bp">count</span> <span class="k">for</span> <span class="n">what</span> <span class="n">we</span> <span class="n">have</span> <span class="n">equals</span> <span class="n">its</span> <span class="bp">count</span> <span class="k">for</span> <span class="n">what</span> <span class="n">we</span> <span class="n">need</span>
    
    <span class="k">while</span> <span class="n">numberOfCharactersWeHave</span> <span class="n">equals</span> <span class="n">numberOfCharactersWeNeed</span>
        <span class="n">update</span> <span class="n">global</span> <span class="n">minimum</span> <span class="n">variable</span> <span class="k">as</span> <span class="n">applicable</span>
        <span class="n">pop</span> <span class="n">from</span> <span class="kr">left</span> <span class="n">of</span> <span class="n">window</span> <span class="p">(</span> <span class="k">if</span> <span class="n">the</span> <span class="n">character</span> <span class="k">is</span> <span class="k">in</span> <span class="n">our</span> <span class="n">haveHashTable</span> <span class="n">update</span> <span class="n">it</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">the</span> <span class="n">start</span> <span class="n">letter</span> <span class="k">is</span> <span class="n">something</span> <span class="n">we</span> <span class="n">need</span><span class="p">,</span> <span class="n">and</span> <span class="n">the</span> <span class="n">substring</span> <span class="k">is</span> <span class="n">no</span> <span class="n">longer</span> <span class="n">valid</span> <span class="p">(</span><span class="n">its</span> <span class="bp">count</span> <span class="k">for</span> <span class="n">what</span> <span class="n">we</span> <span class="n">have</span> <span class="o">&lt;</span> <span class="n">its</span> <span class="bp">count</span> <span class="k">for</span> <span class="n">what</span> <span class="n">we</span> <span class="n">need</span><span class="p">)</span> <span class="n">decrement</span> <span class="n">numberOfCharactersWeHave</span>
        <span class="n">move</span> <span class="n">start</span> <span class="n">pointer</span> <span class="n">by</span> <span class="mi">1</span>
        
<span class="k">return</span> <span class="n">minimum</span>
</div></code></pre><p>The time complexity here is now liner. We still traverse the string S, but checking if a substring is valid is a consistent operation. We are only checking 2 variables. This means we now have O(n) time. The space complexity still remains O(n) due to the 2 hash tables to store character counts. Let's implement the real thing (and apologies for the extra code and comments, I wanted to make it as clear as possible).</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">inputS</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1">// for easier swift access</span>
<span class="kd">let</span> <span class="nv">inputT</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1">// for easier swift access</span>

<span class="kd">var</span> <span class="nv">haveHash</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Character</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span>
<span class="kd">var</span> <span class="nv">needHash</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Character</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span>

<span class="kd">var</span> <span class="nv">slidingWindowStart</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">var</span> <span class="nv">globalMinSubstringLength</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">.</span><span class="bp">max</span>
<span class="kd">var</span> <span class="nv">globalMinSubstring</span> <span class="p">=</span> <span class="s">&quot;&quot;</span>

<span class="kd">var</span> <span class="nv">numberOfCharactersWeHave</span> <span class="p">=</span> <span class="mi">0</span>

<span class="c1">// set up our hashTable for letters we need</span>
<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">inputS</span> <span class="p">{</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span> <span class="p">}</span>
<span class="c1">// set up our hashTable for letters we need</span>
<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">inputT</span> <span class="p">{</span> <span class="n">needHash</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">=</span> <span class="n">needHash</span><span class="p">[</span><span class="n">letter</span><span class="p">,</span> <span class="k">default</span><span class="p">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nv">numberOfCharactersWeNeed</span> <span class="p">=</span> <span class="n">needHash</span><span class="p">.</span><span class="bp">count</span>

<span class="k">for</span> <span class="p">(</span><span class="n">endLetterIndex</span><span class="p">,</span> <span class="n">endLetter</span><span class="p">)</span> <span class="k">in</span> <span class="n">inputS</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// update haveHash if applicable</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">endLetterCountInHaveHash</span> <span class="p">=</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="p">{</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="p">=</span> <span class="n">endLetterCountInHaveHash</span> <span class="o">+</span> <span class="mi">1</span>  <span class="p">}</span>
    <span class="c1">// see if our have character count can be appended. </span>
    <span class="c1">// that is, the end letter is something we need &amp;&amp; its count for what we have == its count for what we need</span>
    <span class="k">if</span> <span class="n">needHash</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">needHashCount</span> <span class="p">=</span> <span class="n">needHash</span><span class="p">[</span><span class="n">endLetter</span><span class="p">],</span> <span class="kd">let</span> <span class="nv">haveHashCount</span> <span class="p">=</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">endLetter</span><span class="p">],</span> <span class="n">needHashCount</span> <span class="p">==</span> <span class="n">haveHashCount</span> <span class="p">{</span>
        <span class="n">numberOfCharactersWeHave</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="c1">// while we have all the characters we need (the substring is valid)</span>
    <span class="k">while</span> <span class="n">numberOfCharactersWeHave</span> <span class="p">==</span> <span class="n">numberOfCharactersWeNeed</span> <span class="p">{</span>
        <span class="c1">// get length of current substring</span>
        <span class="kd">let</span> <span class="nv">lengthOfCurrentSubstring</span> <span class="p">=</span> <span class="p">(</span><span class="n">endLetterIndex</span> <span class="o">-</span> <span class="n">slidingWindowStart</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1">// update global minimum substring if possible</span>
        <span class="k">if</span> <span class="n">lengthOfCurrentSubstring</span> <span class="o">&lt;</span> <span class="n">globalMinSubstringLength</span> <span class="p">{</span>
            <span class="n">globalMinSubstring</span> <span class="p">=</span> <span class="nb">String</span><span class="p">(</span><span class="n">inputS</span><span class="p">[</span><span class="n">slidingWindowStart</span><span class="p">...</span><span class="n">endLetterIndex</span><span class="p">])</span>
            <span class="n">globalMinSubstringLength</span> <span class="p">=</span> <span class="n">lengthOfCurrentSubstring</span>
        <span class="p">}</span>
        
        <span class="kd">let</span> <span class="nv">startLetter</span> <span class="p">=</span> <span class="n">inputS</span><span class="p">[</span><span class="n">slidingWindowStart</span><span class="p">]</span>
        <span class="c1">// pop from left of window if the character is in our have hash</span>
        <span class="k">if</span> <span class="kd">let</span> <span class="nv">haveHashStartLetterCount</span> <span class="p">=</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">startLetter</span><span class="p">]</span> <span class="p">{</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">startLetter</span><span class="p">]</span> <span class="p">=</span> <span class="n">haveHashStartLetterCount</span> <span class="o">-</span> <span class="mi">1</span>  <span class="p">}</span>
        <span class="c1">// if the start letter is something we need, and the substring is no longer valid (its count for what we have &lt; its count for what we need) update our numberOfCharactersWeHave</span>
        <span class="k">if</span> <span class="kd">let</span> <span class="nv">needHashStartLetterCount</span> <span class="p">=</span> <span class="n">needHash</span><span class="p">[</span><span class="n">startLetter</span><span class="p">],</span> <span class="kd">let</span> <span class="nv">haveHashStartLetterCount</span> <span class="p">=</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">startLetter</span><span class="p">],</span> <span class="n">haveHashStartLetterCount</span> <span class="o">&lt;</span> <span class="n">needHashStartLetterCount</span> <span class="p">{</span> <span class="n">numberOfCharactersWeHave</span> <span class="o">-=</span> <span class="mi">1</span> <span class="p">}</span>
        <span class="c1">// move left window pointer</span>
        <span class="n">slidingWindowStart</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">globalMinSubstring</span>
</div></code></pre><hr><h1>Conclusion</h1><p>Sliding window problems can come in all shapes and sizes. Keep an eye out when you see the word 'Substring' in a problem, as it may well mean its a sliding window problem! Once you get the pattern of them down, they are easy-peasy.</p><hr>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/combine/intro-to-combine</guid><title>Combine 101: Introduction</title><description>Getting into some reactive programming</description><link>https://swiftrefresher.com/combine/intro-to-combine</link><pubDate>Tue, 21 Jun 2022 21:27:00 -0400</pubDate><content:encoded><![CDATA[<h1>Combine 101: Introduction</h1><p>If you have been around in the Swift world for a long time, or you are new to iOS development, odds are you have heard of the Combine framework. The combine framework was introduced by Apple at WWDC19, and was Apple's native answer to RxSwift, ReactiveSwift or any other functional reactive programming frameworks you may have heard of/used before.</p><h3>So what is it?</h3><p>Combine is a first party, <em>declarative</em> framework for asynchronous processing values (streams of data) over time. Instead of having multiple callbacks, completion handlers, or delegations, you can create a singular processing chain for your stream of data.</p><p>The key part here is the framework is declarative, meaning you describe what the program does &amp; not the flow of control. This is compared to imperative styles of programming where our code is how the program works &amp; implementing tasks to mutate some state. <em>Combine</em> is has functional reactive principles as well. This means our program reacts to each stream of data, and is based in functions with a set input &amp; set output. As you will see in some code examples, Combine is both declarative, functional and reactive because our data flows from one function to another, with each function having a defined input and output.</p><p>We can think of Combine having 3 main players: Publishers, Subscribers, and Operators. Let's get familiar with each one!</p><h2>Publishers</h2><p>The Publisher type, is a protocol defined in Swift. Swift Publishers are used to transmit sequences of values over time. You can think of this as a man shouting information from a rooftop at intermittent periods of time. He is a publisher.<br><br>Publishers have 2 associatedtypes representing the Output of the Publisher, and how the Publisher will fail. We can define each of these. Also the Publisher protocol has a <code>receive(subscriber:)</code> function hook a subscriber up to itself. Per the contract for the this function, a publisher’s output must match subscriber’s input, and so should the failure types.</p><p>Most Swift foundation objects/functions support built in publishers as of 2022. For example, NotificationCenter &amp; NSTimer:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">notificationPublisher</span> <span class="p">=</span> <span class="n">NotificationCenter</span><span class="p">.</span><span class="n">Publisher</span><span class="p">(</span><span class="n">center</span><span class="p">:</span> <span class="p">.</span><span class="k">default</span><span class="p">,</span> 
                                                         <span class="n">name</span><span class="p">:</span> <span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="s">&quot;Test&quot;</span><span class="p">),</span> 
                                                         <span class="n">object</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">timerPublisher</span> <span class="p">=</span> <span class="n">Timer</span><span class="p">.</span><span class="n">TimerPublisher</span><span class="p">(</span><span class="n">interval</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> 
                                          <span class="n">runLoop</span><span class="p">:</span> <span class="n">RunLoop</span><span class="p">.</span><span class="n">main</span><span class="p">,</span> 
                                          <span class="n">mode</span><span class="p">:</span> <span class="p">.</span><span class="k">default</span><span class="p">)</span>
</div></code></pre><p>We have created these objects and now they can stream and emit values over time, we can also react to these values however we wish.</p><p>As opposed to creating our own objects that implement the Publisher protocol, Apple suggests we use one of their built-in types whenever we need a custom publisher. We can either:</p><ol><li>Use a concrete subclass of <code>Subject</code> like <code>PassThroughSubject</code> for example, to manually send values</li><li>Use a <code>CurrentValueSubject</code></li><li>Add the <code>@Published</code> annotation wrapper to a property we wish</li></ol><h3>What are Subjects?</h3><p>A subject is a type of Publisher that exposes functions, in order for outside callers to Publish events into the stream of data. Swift gives us 2 built-in Subjects for free. These are namely <em>CurrentValueSubject</em> and <em>PassThroughSubject</em>.</p><p>A <em>CurrentValueSubject</em> starts with an initial value, and publishes every time that value changes. We can also access the inner value with this type of Subject.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">subject</span> <span class="p">=</span> <span class="n">CurrentValueSubject</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">,</span> <span class="n">Never</span><span class="p">&gt;(</span><span class="s">&quot;Test&quot;</span><span class="p">)</span> <span class="c1">// initial value of Test</span>

<span class="bp">print</span><span class="p">(</span><span class="n">subject</span><span class="p">.</span><span class="n">value</span><span class="p">)</span> <span class="c1">// prints &#39;Test&#39;</span>

<span class="n">subject</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">&quot;Blog&quot;</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">subject</span><span class="p">.</span><span class="n">value</span><span class="p">)</span> <span class="c1">// prints &#39;Blog&#39;</span>
</div></code></pre><p>A <em>PassThroughSubject</em> does not have an initial value, but broadcasts data downstream. This type also drops values if there are no subscribers, or the current demand is zero. We are unable to access any values within this object.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">subject</span> <span class="p">=</span> <span class="n">PassthroughSubject</span><span class="p">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="n">Never</span><span class="p">&gt;()</span> <span class="c1">// no initial value</span>

<span class="c1">// subscribe to events</span>
<span class="n">subject</span><span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;finished&quot;</span><span class="p">)</span>
<span class="p">},</span> <span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="p">})</span>

<span class="n">subject</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">&quot;Alex&quot;</span><span class="p">)</span>
<span class="n">subject</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">&quot;is Blogging!&quot;</span><span class="p">)</span> 
<span class="n">subject</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">completion</span><span class="p">:</span> <span class="p">.</span><span class="n">finished</span><span class="p">)</span> <span class="c1">// done!</span>
<span class="c1">// Alex</span>
<span class="c1">// is Blogging!</span>
<span class="c1">// finished</span>
</div></code></pre><h3>@Published property wrapper</h3><p>Swift allows us to add a publisher to any property by using the <em>@Published</em> property wrapper. You can access the inner publisher by using the <code>$</code> symbol in front of your property. It is important to note the @Published property wrapper is class-constrained, we cannot use them in structs. Let's see a code example (Note, we will learn about AnyCancellable soon!)</p><pre><code><div class="highlight"><span></span><span class="kr">final</span> <span class="kd">class</span> <span class="nc">FooClass</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kd">var</span> <span class="nv">subscriber</span><span class="p">:</span> <span class="n">AnyCancellable</span><span class="p">?</span>
    <span class="p">@</span><span class="n">Published</span> <span class="kd">var</span> <span class="nv">isOn</span><span class="p">:</span> <span class="nb">Bool</span> <span class="p">=</span> <span class="kc">false</span> <span class="c1">// published</span>
    
    <span class="kd">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// this will print false, then true</span>
        <span class="n">subscriber</span> <span class="p">=</span> <span class="err">$</span><span class="n">isOn</span>
            <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
                <span class="bp">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="p">})</span>
       <span class="n">change</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">change</span><span class="p">()</span> <span class="p">{</span>
       <span class="n">isOn</span><span class="p">.</span><span class="n">toggle</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Also worth noting, the publishing will happen in the object's willSet block, so anyone downstream will get the new value before it is set.</p><h2>Subscribers</h2><p>Up until now we have been referring to those listening to publishers as "Downstream". But they have a formal name, and that name is <em>Subscriber</em>. A Subscriber listens to events sent from a Publisher. A subscriber can receive either an input value, or a completion value with some indicator of a success/failure.</p><p>Swift gives us 2 built in Subscribers: <em>Subscribers.Sink</em> &amp; <em>Subscribers.Assign</em>.</p><p><em>Subscribers.Sink</em> is a simple Subscriber class that requests an unlimited amount of values upon its subscription.</p><p><em>Subscribers.Assign</em> assigns received elements to a property indicated by a key path.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="n">Just</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>

<span class="n">publisher</span><span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;finished&quot;</span><span class="p">)</span>
<span class="p">},</span> <span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="p">})</span>

<span class="c1">// false</span>
<span class="c1">// finished</span>
</div></code></pre><h2>Publisher + Subscriber Lifecycle</h2><p>Let's explore what happens under the hood when we build a subscription between a publisher &amp; subscriber</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">subject</span> <span class="p">=</span> <span class="n">PassthroughSubject</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">,</span> <span class="n">Never</span><span class="p">&gt;()</span>

<span class="kd">let</span> <span class="nv">token</span> <span class="p">=</span> <span class="n">subject</span>
    <span class="p">.</span><span class="bp">print</span><span class="p">()</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="s">&quot;received by subscriber: </span><span class="si">\(</span><span class="nv">$0</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span> <span class="p">})</span>

<span class="n">subject</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">// receive subscription: (PassthroughSubject) [Subscriber connects to a publisher] [Publisher creates a subscription] [Publisher acknowledges subscription request]</span>
<span class="c1">// request unlimited [Subscriber requests number of elements it want to receive] [Our Demand is currently unlimited]</span>
<span class="c1">// receive value: (1) [The Publisher sends values by calling receive(_:) on the subscriber]</span>
<span class="c1">// received by subscriber: 1 [Returns how many items are expected to be received] [Subscriber can only increase or leave demand the same]</span>
<span class="c1">// receive cancel [Subscription either ends in a cancel, successful finish, or fail with an error]</span>
</div></code></pre><h1>Conclusion</h1><p>This concludes our intro into combine! Hope you learned a good foundation for our next few articles!</p><h4>Helpful links:</h4><p><a href="https://developer.apple.com/videos/play/wwdc2019/722/">WWDC19 Intro video</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/leetcode/blind-75-arrays</guid><title>Blind 75: Arrays + Hashing + 2 pointers</title><description>Arrays + Leetcode = Match made in heaven</description><link>https://swiftrefresher.com/leetcode/blind-75-arrays</link><pubDate>Wed, 16 Mar 2022 21:02:00 -0400</pubDate><content:encoded><![CDATA[<h1>TwoSum</h1><p>This is a classic introductory problem &amp; it is a good place for us to start our leetcode journey. Read over the problem statement below.</p><img src="https://swiftrefresher.com/twosum.png"/><p>Pretty straightforward right? Let's take this step by step and make sure we understand the solution. We need the indices of 2 numbers that add up to a target. We can assume there is one answer, and we may not use the same element twice. Easy enough.</p><h3>Brute Force</h3><p>A brute force solution here is pretty obvious, let's go through each element in the array, and iterate over every other element, to see if we add up to a target. This is a common brute force method for most array problems. This will give us a O(n²) time &amp; O(1) spacial solution. Let's write some pseudocode for this solution and test it. While testing, make sure to capture edge cases!</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">+</span> <span class="n">other</span> <span class="n">number</span> <span class="p">=</span> <span class="n">target</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">number</span> <span class="n">index</span><span class="p">,</span> <span class="n">other</span> <span class="n">number</span> <span class="n">index</span><span class="p">]</span>
</div></code></pre><p>It is time to consider some bottlenecks, and think how we can optimize our solution. Firstly, if you notice some nested for loops in your code, that is a code smell. Think how those can be optimized. In our case if we try to pass thru the array only once, while also sequentially finding the solution, we heavily optimize our solution.</p><h3>Approach 1</h3><h3>[ Sort + 2 pointer ]</h3><h3>[ O(nLog(n)) time + O(n) space ]</h3><p>For this specific problem we know we want 2 numbers that add up to a target. That is, X + Y = Z. If we have X, we know that we are searching for Z - Y. If we sort our array, we can make this search much faster.</p><p>Back to our above example, we have an array of [4, 2, 1, 3] and we need a target of 3. If we first sort the array, we can use 2 pointers to incrementally get closer to our target number. By sorting our array is [1, 2, 3, 4]. We have a left pointer at the beginning of the array and a right pointer at the end of the array. Let's add these numbers up. 1 + 4 = 5, which is greater than our target of 3. The sum is greater than our target, so let's move the right pointer inward. Now our pointers are targeted at 1, and 3. 1 + 3 = 4, a summation that is still greater than our target. So we move the right pointer inward once more. This makes our pointers at 1 and 2, and if we add those up we find our target.</p><p>Pseudocode:</p><pre><code><div class="highlight"><span></span><span class="bp">sort</span> <span class="n">array</span>
<span class="k">while</span> <span class="kr">left</span> <span class="n">pointer</span> <span class="o">&lt;</span> <span class="kr">right</span> <span class="n">pointer</span>
    <span class="n">add</span> <span class="n">up</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">pointers</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="p">=</span> <span class="n">target</span>
        <span class="k">return</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">pointer</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span>
        <span class="n">move</span> <span class="kr">right</span> <span class="n">pointer</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span>
        <span class="n">move</span> <span class="kr">left</span> <span class="n">pointer</span>
</div></code></pre><p>There are some considerations here. By sorting we can get, on average, O(nLog(n)) time performance. So by sorting and then searching our array we are looking at O(nLog(n)) + O(n) time complexity. Which comes out to be O(nLog(n)). This is a pretty significant time vs space tradeoff and this should be discussed with your interviewer.<br><br>Let's go into implementation now.</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for empty array + single element in array.</span>
<span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]()</span> <span class="p">}</span>

<span class="kd">let</span> <span class="nv">sorted</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">sorted</span><span class="p">()</span>
<span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">var</span> <span class="nv">rightPointer</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span>

<span class="c1">// Search our array</span>
<span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;</span> <span class="n">rightPointer</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">sum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="o">+</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="p">{</span>
        <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="p">{</span>
        <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">break</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Because the swift index(of:) function returns us an &#39;Array&lt;Int&gt;.Index?&#39; </span>
<span class="c1">// we need to manually get the integer Index value by doing one more loop.</span>
<span class="kd">let</span> <span class="nv">leftNum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">rightNum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span>

<span class="kd">var</span> <span class="nv">returnValue</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]()</span>

<span class="c1">// Beautiful swift! Reads just like english :) </span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="k">where</span> <span class="p">(</span><span class="n">num</span> <span class="p">==</span> <span class="n">leftNum</span> <span class="o">||</span> <span class="n">num</span> <span class="p">==</span> <span class="n">rightNum</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">returnValue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">returnValue</span>
</div></code></pre><p>Ta-Da! This is one passing solution to solve the 2 sum problem. This methodology will be the preferred method of solving in 3sum, 4sum and etc problems.</p><h3>Approach 2</h3><h3>[ Hash Table ]</h3><h3>[ O(n) time + space ]</h3><p>By using some auxiliary data structure for storage you can easily look up past calculations for your use case. In our case, we should try to optimize our O(n²) time solution into a O(n) time solution. For array problems this is the mecca. This brings us to our introduction of hash tables/dictionary's. We can have constant lookup in swift dictionaries.</p><p>In our case let's consider we loop through the array 1 time, and in a hash table, we store the key as the element of our array and the value as the index of each value. So our original array of [4, 2, 1, 3] turns into a dictionary of [4: 0, 2: 1, 1: 2, 3: 3]. Now in our problem, we can go through our array 1 time, and at each element we can see if the inverse of the target exists. Namely it comes down to this pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">add</span> <span class="n">to</span> <span class="n">dictionary</span><span class="p">.</span> <span class="p">[</span><span class="n">number</span><span class="p">:</span> <span class="n">index</span> <span class="n">of</span> <span class="n">number</span><span class="p">]</span>
    
<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">inverse</span> <span class="p">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">number</span>
    <span class="k">if</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">inverse</span><span class="p">]</span> <span class="n">exists</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">number</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">inverse</span><span class="p">]]</span>
</div></code></pre><p>After testing, we see this is a lot more efficient, and it works! We gave up some constant space in order for time efficiency, but these tradeoffs are things you can discuss with your interviewer. Now let's code our final solution. Don't forget to cover those edge cases, and to practice safe optional unwrapping!</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for empty array + single element in array.</span>
<span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[]</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span>
<span class="c1">// Create our hashtable mapping</span>
<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">hashTable</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="n">index</span>
<span class="p">}</span>
<span class="c1">// Now search our array for the inverse!</span>
<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">inverse</span> <span class="p">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">element</span>
    <span class="c1">// we should not be using the same element within itself. Make sure to read the problem carefully!</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">existingInverse</span> <span class="p">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">inverse</span><span class="p">],</span> <span class="n">unwrappedInverse</span> <span class="o">!=</span> <span class="n">index</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">existingInverse</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="p">[]</span> <span class="c1">// we have no solution. </span>
</div></code></pre><p>Nice work!</p><hr><h1>ThreeSum</h1><p>This problem builds off of our previous problem, with a little more complexity. Check out the problem statement below.</p><img src="https://swiftrefresher.com/threesum.png"/><p>If we remember one of the solutions for the TwoSum problem, when we sort the array then use 2 pointers to find our target it leads to decently efficient code.</p><h3>Brute Force</h3><p>With most array problems, the brute force solution is straightforward. By using nested loops, we can iterate on all possible answer combinations until we find the solution(s) we want. In this case, this is an O(n³) solution. With all of our "sum" problems we can represent the brute force as a O(nˣ) where x = the number 'sum' the problem is asking for.</p><p>Pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">secondNumber</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">for</span> <span class="n">thirdNumber</span> <span class="k">in</span> <span class="n">array</span>
            <span class="k">if</span> <span class="n">number</span> <span class="o">+</span> <span class="n">secondNumber</span> <span class="o">+</span> <span class="n">thirdNumber</span> <span class="p">=</span> <span class="mi">0</span> <span class="n">AND</span> <span class="n">we</span> <span class="n">have</span> <span class="n">not</span> <span class="n">added</span> <span class="n">this</span> <span class="n">answer</span> <span class="n">combination</span> <span class="n">before</span>
                <span class="n">add</span> <span class="n">these</span> <span class="n">numbers</span> <span class="n">to</span> <span class="n">our</span> <span class="k">return</span> <span class="n">value</span>
</div></code></pre><p>Obviously the nested nature of these arrays should be avoided. So let's take a step back and iterate on our approach from the TwoSum problem.</p><h3>Approach</h3><h3>[ Sort + 2 pointer ]</h3><h3>[ O(n²) time + O(n) space ]</h3><p>We know we need to add up to a target of 0, with 3 different numbers. In formulaic terms, we have X + Y + Z = 0. For each element in our array, we have one of the elements in our equation. So we are left with -Z = X + Y, where Z is our element in the array.</p><p>By sorting our array at the beginning of our function, we can reuse our TwoSum logic. Add up X + Y. If that sum is less than our target (-Z) we need to increase our sum &amp; vice versa. Since our array is sorted, and we can represent X and Y as leftPointer's and rightPointer's in our array, it is easy to increase and decrease our sum as needed. Namely we can do something similar to this.</p><pre><code><div class="highlight"><span></span><span class="bp">sort</span> <span class="n">array</span>
<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="bp">sorted</span> <span class="n">array</span>
    <span class="bp">find</span> <span class="n">the</span> <span class="n">targetNumber</span>
    <span class="bp">find</span> <span class="n">the</span> <span class="n">leftPointer</span>
    <span class="bp">find</span> <span class="n">the</span> <span class="n">rightPointer</span>
    
    <span class="k">while</span> <span class="n">leftPointer</span> <span class="n">less</span> <span class="n">than</span> <span class="n">rightPointer</span>
        <span class="n">sum</span> <span class="p">=</span> <span class="n">leftPointer</span> <span class="o">+</span> <span class="n">rightPointer</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="k">is</span> <span class="n">less</span> <span class="n">than</span> <span class="n">target</span>
            <span class="n">move</span> <span class="n">leftPointer</span> <span class="n">inward</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="k">is</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">target</span>
            <span class="n">move</span> <span class="n">rightPointer</span> <span class="n">inward</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="n">equals</span> <span class="n">target</span> <span class="n">AND</span> <span class="n">not</span> <span class="n">duplicated</span>
            <span class="n">we</span> <span class="n">have</span> <span class="n">our</span> <span class="n">combination</span><span class="p">!</span>
            <span class="n">add</span> <span class="n">to</span> <span class="n">answer</span>
            <span class="n">move</span> <span class="n">both</span> <span class="n">leftPointer</span> <span class="n">and</span> <span class="n">rightPointer</span> <span class="n">inward</span>
</div></code></pre><p>Some time + space considerations here. By sorting we have O(nLog(n)) and then searching every element in the array gives us O(nLog(n)) + O(n²). Since O(n²) is much greater than O(nLog(n)), the O(nLog(n)) cancels out and does not need to be considered in the final time complexity calculations, so the final time complexity is O(n²) time where n is the length of our input array. For space, we need to keep track of the answer in an array, so the space complexity is O(n) where n is the length of the answer.</p><p>Let's implement the real answer.</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for empty array + single element + only 2 elements in array.</span>
<span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[[</span><span class="nb">Int</span><span class="p">]]()</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nv">returnVal</span> <span class="p">=</span> <span class="p">[[</span><span class="nb">Int</span><span class="p">]]()</span>
<span class="kd">let</span> <span class="nv">sorted</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">sorted</span><span class="p">()</span>

<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="bp">sorted</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">target</span> <span class="p">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">element</span>
    <span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="kd">var</span> <span class="nv">rightPointer</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="c1">// search for our target, within bounds</span>
    <span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;</span> <span class="n">rightPointer</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">sum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="o">+</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="p">{</span>
            <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// Sum is too small, increase our sum</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="p">{</span>
            <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1">// Sum is too big, decrease our sum</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">sum</span> <span class="p">==</span> <span class="n">target</span> <span class="p">{</span>
            <span class="c1">// We found an answer!</span>
            <span class="kd">let</span> <span class="nv">correctAns</span> <span class="p">=</span> <span class="p">[</span><span class="n">element</span><span class="p">,</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">],</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]]</span>
            <span class="c1">// Preemptively move our pointers inward </span>
            <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="n">returnVal</span><span class="p">.</span><span class="bp">contains</span><span class="p">(</span><span class="n">correctAns</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// add to our answer</span>
                <span class="n">returnVal</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">correctAns</span><span class="p">)</span>
            <span class="p">}</span> 
        <span class="p">}</span>  
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">returnVal</span>
</div></code></pre><p>Boom! Nicely done.</p><hr><h1>Contains Duplicates</h1><p>This is a pretty straightforward problem, but builds our foundational knowledge when it comes to HashTables! Find the problem statement below.</p><img src="https://swiftrefresher.com/containsduplicates.png"/><p>Very easy problem to grasp. Now let's try to find ourselves a brute force solution, and optimize it.</p><h3>Brute Force</h3><p>A very easy brute force solution, leads us to an O(n²) time complexity solution with O(1) space. This would be to go by each element in the array, and have a nested loop to see if our outer element is found within our inner loop. Like so:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">number</span> <span class="n">equals</span> <span class="n">other</span> <span class="n">number</span> <span class="n">we</span> <span class="n">have</span> <span class="n">found</span> <span class="n">a</span> <span class="n">duplicate</span><span class="p">.</span>
</div></code></pre><p>By introducing a HashTable into the problem, we know that HashTable's have constant lookup, but at worst, they take up O(n) space where N = length of the input array. Also since HashTable's have unique keys, we will be able to store all of the elements in our array just once.</p><h3>Approach</h3><h3>[ HashTable + Consistent Lookup ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>We can initialize a HashTable at the beginning of our problem, where the key of the HashTable is the same type of element in our input array, in this case Integer. As we loop through our array, we can check if the HashTable already contains a key-element pair that matches Integer at each iteration of the loop. If the key-element pair exists, we can break out of the loop, and return true for our function. If the key-element pair does not exist, we can add it to the HashTable.</p><pre><code><div class="highlight"><span></span><span class="n">Create</span> <span class="n">HashTable</span> <span class="n">with</span> <span class="n">key</span> <span class="n">of</span> <span class="n">Integer</span> <span class="n">and</span> <span class="n">element</span> <span class="n">of</span> <span class="n">whatever</span> <span class="n">you</span> <span class="n">would</span> <span class="n">like</span> 

<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">if</span> <span class="n">element</span> <span class="n">exists</span> <span class="n">with</span> <span class="n">number</span> <span class="k">as</span> <span class="n">the</span> <span class="n">key</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="k">else</span>
        <span class="n">add</span> <span class="n">to</span> <span class="n">the</span> <span class="n">HashTable</span>
</div></code></pre><p>Pretty simple right! Like I mentioned above, the time and space are both O(n). This is why HashTables are so powerful, is because they give us consistent lookup time when we need some auxiliary storage in our problems. Now it is time to implement the real solution.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span> <span class="c1">// edge-case check against small or empty inputs</span>

<span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span> <span class="c1">// i opted for an Int:Int pair, but you could have easily done Int:Bool, etc. </span>
        
<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// loop our input array</span>
    <span class="k">if</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span> <span class="c1">// We have found a duplicate!</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="n">index</span> <span class="c1">// Add element to HashTable</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="kc">false</span> <span class="c1">// No duplicates here...</span>
</div></code></pre><p>Easy-Peasy.</p><hr><h1>Product Of Array Except Self</h1><p>This problem is our first introduction on how to traverse an array both forwards and backwards! Let's dive in.</p><img src="https://swiftrefresher.com/productexceptself.png"/><p>We need to come up with a brute force solution to start, and like every other array problem, we can nest iterations in order to get every possible combination in the array.</p><h3>Brute Force</h3><p>We can start at each point in a given array and calculate every other arrays product, and add it to a return value. This leads us to a O(n²) time complexity and an O(n) spatial complexity because we need to store the length of the return array in our function. This is O(n²) time due to the nested nature of our iterations within the array.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">iterate</span> <span class="n">through</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">array</span>
        <span class="n">calculate</span> <span class="n">the</span> <span class="n">product</span>
    <span class="n">add</span> <span class="n">product</span> <span class="n">to</span> <span class="k">return</span> <span class="n">value</span> 
</div></code></pre><h3>Approach</h3><h3>[ Forward + Backward Iteration ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>We can optimize this problem by filling in our return array only twice. We can loop forward through our auxiliary return array once, keep a running product at each iteration, and use the running product to fill our return value array. Then we can reset our running product count, and iterate our array backwards to keep a running count of all the values minus itself.</p><p>The thinking here is, as we iterate our array we can fill in our return value in place. On the first loop, returnArray[i] will contain proceeding product of nums[i] (exclusive). After the second loop, each returnArray[i] is updated by multiplying to succeeding product of nums[i].</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">running</span> <span class="bp">count</span> <span class="n">starting</span> <span class="n">at</span> <span class="mi">1</span>
<span class="n">create</span> <span class="k">return</span> <span class="n">array</span> <span class="n">of</span> <span class="n">all</span> <span class="mi">1</span><span class="err">&#39;</span><span class="n">s</span>

<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span> <span class="n">forward</span> <span class="n">direction</span>
    <span class="n">update</span> <span class="k">return</span> <span class="n">array</span> <span class="n">with</span> <span class="n">running</span> <span class="bp">count</span>
    <span class="n">update</span> <span class="n">running</span> <span class="bp">count</span> <span class="n">by</span> <span class="n">multiplying</span> <span class="n">number</span> <span class="n">to</span> <span class="n">existing</span> <span class="bp">count</span> 
    
<span class="n">reset</span> <span class="n">running</span> <span class="bp">count</span>

<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span> <span class="n">backwards</span> <span class="n">direction</span>
    <span class="n">update</span> <span class="k">return</span> <span class="n">array</span> <span class="n">by</span> <span class="n">multiplying</span> <span class="n">running</span> <span class="bp">count</span> <span class="n">by</span> <span class="n">number</span> <span class="k">in</span> <span class="n">input</span> <span class="n">array</span>
    <span class="n">update</span> <span class="n">running</span> <span class="bp">count</span> <span class="n">by</span> <span class="n">multiplying</span> <span class="n">number</span> <span class="n">to</span> <span class="n">existing</span> <span class="bp">count</span>
    
<span class="k">return</span>
</div></code></pre><p>This gives us an O(n) time solution since we only have to iterate twice, namely forward and backwards. O(2n) = O(n) on average. Space is still consistently O(n). Now let's implement the real solution.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[]</span> <span class="p">}</span> <span class="c1">// guard against edge cases</span>
<span class="kd">var</span> <span class="nv">auxArray</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">repeating</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">count</span><span class="p">:</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span><span class="p">)</span> <span class="c1">// create a return array of all 1&#39;s</span>
<span class="kd">var</span> <span class="nv">runningCount</span> <span class="p">=</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.&lt;</span><span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span> <span class="c1">// forward iteration</span>
    <span class="n">auxArray</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">runningCount</span>
    <span class="n">runningCount</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="c1">// update running count of product</span>
<span class="p">}</span>

<span class="n">runningCount</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// reset the running count</span>

<span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="bp">stride</span><span class="p">(</span><span class="n">from</span><span class="p">:</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">through</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">by</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// backward iteration</span>
    <span class="n">auxArray</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">*=</span> <span class="n">runningCount</span>
    <span class="n">runningCount</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="c1">// update running count of product</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">auxArray</span>
</div></code></pre><p>Good Job!</p><hr><h1>Valid Anagram</h1><p>This problem expands our knowledge on array best practices! Let's tackle it.</p><img src="https://swiftrefresher.com/validanagram.png"/><h3>Brute Force</h3><p>Let's start by thinking of a brute force solution. My brute force solution I came up with involved a little different of an approach as opposed to other array problems. Nesting arrays in this problem isn't quite where my head first went. Initially I thought it would be easiest to sort both input strings, and then go letter by letter to compare the two strings. When we find a deviation between the two, we do not have a valid anagram.</p><pre><code><div class="highlight"><span></span><span class="bp">sort</span> <span class="n">string</span> <span class="n">s</span>
<span class="bp">sort</span> <span class="n">string</span> <span class="n">t</span>

<span class="n">make</span> <span class="n">sure</span> <span class="n">they</span> <span class="n">are</span> <span class="n">the</span> <span class="n">same</span> <span class="n">length</span> 

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">s</span> <span class="n">or</span> <span class="n">t</span> <span class="n">length</span>
    <span class="k">if</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">s</span> <span class="n">does</span> <span class="n">not</span> <span class="bp">equal</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">t</span>
        <span class="k">return</span> <span class="kc">false</span>
        
<span class="k">if</span> <span class="n">we</span> <span class="kr">get</span> <span class="n">here</span><span class="p">,</span> <span class="n">we</span> <span class="n">have</span> <span class="n">a</span> <span class="n">valid</span> <span class="n">anagram</span>
</div></code></pre><p>Looping the strings is not the issue here. Sorting 2 different strings, and then looping is not very optimal. By sorting we can get, on average, O(nLog(n)) time performance. Make that sorting twice plus looping the strings we are looking at O(2nLog(n)) + O(n) time complexity. We can simplify this to O(3nLog(n)) -&gt; O(nLog(n)) time, with O(1) consistent space complexity.</p><p>We know we can do better though. It may be worth giving up our consistent space complexity to get a better time complexity.</p><h3>Approach</h3><h3>[ HashTable with letter occurrences ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>We can introduce our arrays best friend! A hash table. We can store the occurrences of each letter in our hashTable. Utilizing a hash table here gives us consistent O(1) lookup when we need to know how many times we have seen a character. We have 2 strings, for one string we can increase the number of occurrences, for another string we can decrease the number of occurrences. In a perfect world, our hash table should have values of all 0's if it is a valid anagram.</p><pre><code><div class="highlight"><span></span><span class="n">check</span> <span class="n">string</span> <span class="n">lengths</span> <span class="n">are</span> <span class="bp">equal</span>
<span class="n">create</span> <span class="n">hash</span> <span class="n">table</span>

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">s</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span> <span class="bp">contains</span> <span class="n">this</span> <span class="n">letter</span> <span class="n">already</span>
        <span class="n">increment</span> <span class="n">its</span> <span class="n">occurrence</span> <span class="n">number</span> <span class="n">by</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span> <span class="n">does</span> <span class="n">not</span> <span class="n">contain</span> <span class="n">this</span> <span class="n">letter</span>
        <span class="n">add</span> <span class="n">it</span> <span class="n">to</span> <span class="n">the</span> <span class="n">hash</span> <span class="n">table</span> <span class="n">with</span> <span class="n">an</span> <span class="n">occurrence</span> <span class="n">of</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">t</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span> <span class="bp">contains</span> <span class="n">this</span> <span class="n">letter</span> <span class="n">already</span>
        <span class="n">decrement</span> <span class="n">its</span> <span class="n">occurrence</span> <span class="n">number</span> <span class="n">by</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span> <span class="n">does</span> <span class="n">not</span> <span class="n">contain</span> <span class="n">this</span> <span class="n">letter</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="n">we</span> <span class="n">have</span> <span class="n">found</span> <span class="n">a</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">t</span> <span class="n">that</span> <span class="n">s</span> <span class="n">does</span> <span class="n">not</span> <span class="n">have</span>
        
<span class="k">for</span> <span class="n">values</span> <span class="k">in</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">value</span> <span class="k">is</span> <span class="n">not</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">false</span>

<span class="k">return</span> <span class="kc">true</span>
</div></code></pre><p>This solution contains 3 loops. This equates to O(3n) → O(n) on average time complexity. Our space complexity is O(n) where n is the number of unique characters in s and t. This can also be represented as O(max(s.length, t.length)) at worst case. It's time to bring it all together:</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">s</span><span class="p">.</span><span class="bp">count</span> <span class="p">==</span> <span class="n">t</span><span class="p">.</span><span class="bp">count</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span> <span class="c1">// edge case where our string lengths may not be equal</span>
<span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Character</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span>

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">existing</span> <span class="p">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">=</span> <span class="n">existing</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// if we have already seen this character, append its count by 1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// we have not seen this character yet, add to hash table</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">t</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">existing</span> <span class="p">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">=</span> <span class="n">existing</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// decrement the character occurrence by 1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span> <span class="c1">// t contains a letter s does not have. not a valid anagram</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">hashTable</span><span class="p">.</span><span class="n">values</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span> <span class="c1">// we have found a letter where s contains more occurrences than t, and vice versa</span>
<span class="p">}</span>
<span class="k">return</span> <span class="kc">true</span> <span class="c1">// valid!</span>
</div></code></pre><p>Nice!</p><hr><h1>Valid Palindrome</h1><p>Similar to our problem with Anagrams, this problem is a play on a string, but can easily be thought of as an array problem. One thing to note about this problem is PAY ATTENTION! The little details on some of these leetcode problems can kill you. Notice we should ignore non alphanumeric characters + ignore spaces. Also notice how we should be treating all alphanumerics as lowercased.</p><img src="https://swiftrefresher.com/validpalindrome.png"/><h3>Brute Force</h3><p>As always we start with a Brute Force solution and optimize. Here we can think of the string as an array of characters. Initially we can consider the option of nested arrays with a pointer. We start at the first letter, traverse to the last letter, and make sure they match. Then go to the 2nd letter, traverse to the 2nd to last letter and see if they match. We can do this for all letters nums[x]...nums[length-x] until we meet in the middle.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">alphanumeric</span> <span class="n">character</span> <span class="k">in</span> <span class="n">string</span> 
    <span class="n">traverse</span> <span class="n">to</span> <span class="n">length</span> <span class="o">-</span> <span class="n">x</span> <span class="n">letter</span> <span class="n">of</span> <span class="n">the</span> <span class="n">string</span><span class="p">,</span> <span class="n">that</span> <span class="k">is</span> <span class="n">alphanumeric</span>
        <span class="k">if</span> <span class="n">letters</span> <span class="n">are</span> <span class="n">the</span> <span class="n">same</span>
            <span class="k">continue</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="kc">false</span>
</div></code></pre><p>The bottleneck within this problem is the inner traversal of the string to get to the length - x character in the string. Our brute force solution is on average O(n²) time complexity, with a consistent O(1) spatial complexity. We do not keep any extra storage so we do not take up any extra space. Depending how we check if numbers are alphanumeric, our time complexity may be even slower than O(n²).</p><h3>Approach</h3><h3>[ 2 pointers ]</h3><h3>[ O(n) time + O(1) space ]</h3><p>We can utilize the 2 pointer method, commonly found in arrays for this problem. If we take our string, and put a pointer at the beginning and end of the string, we can move our 2 pointers closer together until they meet in the middle, with O(1/2n) time complexity -&gt; which averages out to O(n).</p><p>We should also take considerations on how to check if a character is alphanumeric. We could create an array of letters and an array of numbers, and check if those array's contain our character. By doing this we introduce poor time complexity into our code. Say our string contains multiple Z's. We would need to traverse the entire alphabet array to see if the character is a letter. A more efficient solution would be to utilize properties on the Swift Standard Library. The Character object comes with built in "isLetter" and "isNumber" properties. Under the hood Swift compares the ASCII encoding value of your character to different ranges of letters and numbers, to ensure it is alphanumeric. This is a much more efficient solution than the array of letters approach.</p><pre><code><div class="highlight"><span></span><span class="n">create</span> <span class="kr">left</span> <span class="n">pointer</span>
<span class="n">create</span> <span class="kr">right</span> <span class="n">pointer</span>
<span class="n">create</span> <span class="n">array</span> <span class="n">of</span> <span class="n">lowercased</span> <span class="n">letters</span> <span class="c1">// O(n)</span>

<span class="k">while</span> <span class="kr">left</span> <span class="n">pointer</span> <span class="o">&lt;=</span> <span class="kr">right</span> <span class="n">pointer</span> <span class="c1">// O(1/2n) at worst</span>
    <span class="n">make</span> <span class="n">sure</span> <span class="kr">left</span> <span class="n">pointer</span> <span class="k">is</span> <span class="n">alphanumeric</span>
        <span class="k">if</span> <span class="n">not</span><span class="p">,</span> <span class="k">continue</span> <span class="n">thru</span> <span class="n">the</span> <span class="n">loop</span>
    <span class="n">make</span> <span class="n">sure</span> <span class="kr">right</span> <span class="n">pointer</span> <span class="k">is</span> <span class="n">alphanumeric</span>
        <span class="k">if</span> <span class="n">not</span><span class="p">,</span> <span class="k">continue</span> <span class="n">thru</span> <span class="n">the</span> <span class="n">loop</span>
    <span class="k">if</span> <span class="kr">left</span> <span class="n">pointer</span> <span class="n">does</span> <span class="n">not</span> <span class="bp">equal</span> <span class="kr">right</span> <span class="n">pointer</span>
        <span class="k">return</span> <span class="kc">false</span>
    
    <span class="n">move</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">pointers</span> <span class="n">inward</span> <span class="k">in</span> <span class="n">the</span> <span class="n">array</span>
</div></code></pre><p>We do not necessarily have to convert our string into an array of lowercased letters. I chose to do this because of the difficulty of indexing a string in swift. To index a certain letter in a string, you cannot just subscript like: str[9]. You must use the built in String.Index type. So for proper, clean code you may implement something like this:</p><pre><code><div class="highlight"><span></span><span class="kd">extension</span> <span class="nc">StringProtocol</span> <span class="p">{</span>
    <span class="kd">subscript</span><span class="p">(</span><span class="n">offset</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Character</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="n">offset</span><span class="p">)]</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Given the short amount of time in a leetcode interview, I tend to stay away, and just convert to an array when possible. Make sure to weigh trade-offs with your interviewer though! If keep the structure as the original string, we would just have to convert the letters to lowercase on each comparison.</p><p>Let's implement our O(n) time, and O(1) space solution.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">s</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span> <span class="c1">// guard against edge cases</span>
             
<span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rightPointer</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// create our pointers</span>
<span class="kd">var</span> <span class="nv">arr</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">lowercased</span><span class="p">())</span> <span class="c1">// convert to an array</span>

<span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;=</span> <span class="n">rightPointer</span> <span class="p">{</span> <span class="c1">// loop until our pointers meet in the middle</span>
    <span class="k">guard</span> <span class="n">arr</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">].</span><span class="n">isLetter</span> <span class="o">||</span> <span class="n">arr</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">].</span><span class="n">isNumber</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// make sure left is alphanumeric</span>
        <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// if not, move left pointer inward and continue the loop</span>
        <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">guard</span> <span class="n">arr</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">].</span><span class="n">isLetter</span> <span class="o">||</span> <span class="n">arr</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">].</span><span class="n">isNumber</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// make sure right is alphanumeric</span>
        <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1">// if not, move the right pointer inward and continue the loop</span>
        <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="o">!=</span> <span class="n">arr</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// if our letters are not equal, return false</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
                
    <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// move left inward</span>
    <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1">// move right inward</span>
<span class="p">}</span>
<span class="k">return</span> <span class="kc">true</span>
</div></code></pre><p>Great Job! and remember, keep an eye out for the little details in a problem description.</p><hr><h1>Group Anagrams</h1><p>This next problem expands our previous knowledge around what makes an anagram valid. Now let's use this base knowledge to group similar sets of anagrams!</p><img src="https://swiftrefresher.com/groupanagrams.png"/><h3>Brute Force</h3><p>The brute force solution for this problem is pretty straight forward. We can use nested For Loops to find all the anagram groups for a given element, group similar ones, and return the groups in a nested return array.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">word</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">start</span> <span class="n">an</span> <span class="n">anagram</span> <span class="n">group</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">word</span> <span class="k">in</span> <span class="n">the</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">outer</span> <span class="n">and</span> <span class="n">inner</span> <span class="n">word</span> <span class="n">are</span> <span class="n">valid</span> <span class="n">anagrams</span> <span class="n">of</span> <span class="n">each</span> <span class="n">other</span> <span class="o">&amp;</span> <span class="n">not</span> <span class="k">in</span> <span class="n">anagram</span> <span class="n">group</span> <span class="n">array</span>
            <span class="n">add</span> <span class="n">words</span> <span class="n">to</span> <span class="n">anagram</span> <span class="n">group</span> <span class="n">array</span>
    <span class="n">add</span> <span class="n">anagram</span> <span class="n">group</span> <span class="n">array</span> <span class="n">to</span> <span class="k">return</span> <span class="n">value</span>
    
<span class="k">return</span> <span class="n">the</span> <span class="k">return</span> <span class="n">value</span>
</div></code></pre><p>This is obviously an inefficient solution due to the 2 nested arrays. This solution would give us an O(n²) time solution + the time to check if the words are anagrams of one another + the time to check if the words are not in an anagram array. This total time equates to O(n²xw), where n is the length of the input array, x is the length of the longest word, and w is the length of the longest anagram array. Not great. Space complexity is O(n) where n is the length of the return value.</p><h3>Approach</h3><h3>[ Sort + HashTable ]</h3><h3>[ O(wnLog(n)) time + O(wn) space ]</h3><p>The bottle necks we can identify from our brute force solution, is obviously: validating 2 words are anagrams of one another, and the grouping mechanism of the nested loops. We need to be able to find the groups faster.</p><p>One easy way to think about this is: We can find if two strings are anagrams of one another by sorting the letters in the strings alphabetically. For example, we know "rat" &amp; "tar" are anagrams because if we sort those two strings, "art" &amp; "art" are equal to one another.</p><p>Another good thought to have is, if we know a strings sorted representation we can figure out its group easily with a HashTable. If we know "rat" &amp; "art" &amp; tar" are all anagrams of one another, we can sort all of them in a Hashtable with their common sorted representation of "art" as HashTable key. It would look something like this:</p><pre><code><div class="highlight"><span></span><span class="kr">get</span> <span class="bp">sorted</span> <span class="n">representations</span> <span class="n">of</span> <span class="n">the</span> <span class="n">input</span> <span class="n">array</span><span class="p">...</span><span class="bp">sort</span> <span class="n">each</span> <span class="n">element</span>

<span class="k">for</span> <span class="n">index</span> <span class="n">of</span> <span class="bp">sorted</span>
    <span class="k">if</span> <span class="n">our</span> <span class="bp">sorted</span> <span class="n">representation</span> <span class="k">is</span> <span class="n">already</span> <span class="k">in</span> <span class="n">the</span> <span class="n">HashTable</span>
        <span class="kr">get</span> <span class="n">the</span> <span class="n">value</span><span class="p">,</span> <span class="n">and</span> <span class="n">add</span> <span class="n">the</span> <span class="n">element</span> <span class="n">of</span> <span class="n">the</span> <span class="n">input</span> <span class="n">array</span> <span class="p">(</span><span class="n">at</span> <span class="n">this</span> <span class="n">index</span><span class="p">)</span> <span class="n">to</span> <span class="n">the</span> <span class="n">hashTable</span> <span class="n">value</span>
    <span class="k">if</span> <span class="n">our</span> <span class="bp">sorted</span> <span class="n">representation</span> <span class="k">is</span> <span class="n">NOT</span> <span class="k">in</span> <span class="n">the</span> <span class="n">HashTable</span>
        <span class="n">add</span> <span class="n">it</span><span class="p">,</span> <span class="n">with</span> <span class="n">a</span> <span class="n">value</span> <span class="n">of</span> <span class="n">the</span> <span class="n">element</span> <span class="n">of</span> <span class="n">the</span> <span class="n">input</span> <span class="n">array</span><span class="p">,</span> <span class="n">at</span> <span class="n">this</span> <span class="n">index</span><span class="p">.</span>


<span class="k">for</span> <span class="n">values</span> <span class="k">in</span> <span class="n">our</span> <span class="n">HashTable</span>
    <span class="n">append</span> <span class="n">them</span> <span class="n">to</span> <span class="n">the</span> <span class="k">return</span> <span class="n">value</span>

<span class="k">return</span> <span class="n">the</span> <span class="k">return</span> <span class="n">value</span>
</div></code></pre><p>This can be a little wordy on the plan english implementation but we will see it with code soon enough. The space complexity of this solution is O(wn) where w is the number of unique words, and n is the length of the longest word. The time complexity of this problem is the time it takes to sort the input array O(nLogn) times the number of words in the input array that are unique. This comes out to be O(wnLog(n)) time.</p><p>The final product:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">sorted</span> <span class="p">=</span> <span class="n">strs</span><span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nb">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">.</span><span class="bp">sorted</span><span class="p">())</span> <span class="p">}</span> <span class="c1">// Our array of sorted representations</span>
<span class="kd">var</span> <span class="nv">returnVal</span> <span class="p">=</span> <span class="p">[[</span><span class="nb">String</span><span class="p">]]()</span>
<span class="kd">var</span> <span class="nv">hashMap</span> <span class="p">=</span> <span class="p">[</span><span class="nb">String</span><span class="p">:</span> <span class="p">[</span><span class="nb">String</span><span class="p">]]()</span>
        
<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="bp">sorted</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">var</span> <span class="nv">existing</span> <span class="p">=</span> <span class="n">hashMap</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// if our element is already in the HashTable</span>
        <span class="n">existing</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">strs</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="c1">// Get the grouped words, and add our new word to the existing array</span>
        <span class="n">hashMap</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="n">existing</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">hashMap</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span><span class="n">strs</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span> <span class="c1">// It is not in HashTable yet, lets add the unique string to it as a key, with our original word as the value</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="n">hashMap</span><span class="p">.</span><span class="n">values</span> <span class="p">{</span> <span class="n">returnVal</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// For all grouped words, lets append it to our return value.</span>

<span class="k">return</span> <span class="n">returnVal</span>
</div></code></pre><p>Well Done!</p><hr><h1>Longest Consecutive Sequence</h1><p>This problem is our introduction into common leetcode problems, namely sequences and subsequences.</p><img src="https://swiftrefresher.com/longestconsecutivesequence.png"/><h3>Brute Force</h3><p>We should make sure we read the problem carefully here. There are a couple things to keep in mind:</p><ul><li>The numbers are unsorted</li><li>We do not care <em>what</em> the longest consecutive sequence is, we just care about the length of the longest sequence</li><li>We <em>must</em> have an O(n) solution</li></ul><p>Because we need an O(n) solution, it may be a waste of our time thinking of Brute force solutions. We know also that we cannot sort this list of unsorted numbers, because sorting alone will give us, at best, O(nLogn) time complexity.</p><p>It's important here to realize what makes a sequence. If we have a number X, we know we have a sequence if X - 1 or X + 1 exists. If we wanted to think of a brute force solution, we could start by iterating on every element and looking for something that would match a sequence on each number. If we find a number, we could loop once again expanding left and right of our sequence.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">inner</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">inner</span> <span class="n">makes</span> <span class="n">a</span> <span class="n">sequence</span>
            <span class="n">search</span> <span class="k">for</span> <span class="n">expansion</span> <span class="n">of</span> <span class="kr">left</span> <span class="n">of</span> <span class="n">sequence</span>
            <span class="n">search</span> <span class="k">for</span> <span class="n">expansion</span> <span class="n">of</span> <span class="kr">right</span> <span class="n">of</span> <span class="n">sequence</span>
        <span class="n">keep</span> <span class="n">track</span> <span class="k">if</span> <span class="n">this</span> <span class="k">is</span> <span class="n">the</span> <span class="n">longest</span> <span class="n">we</span> <span class="n">have</span> <span class="n">seen</span>
<span class="k">return</span> <span class="n">the</span> <span class="n">longest</span> <span class="n">we</span> <span class="n">have</span> <span class="n">seen</span>
</div></code></pre><p>Overall this works, but has terrible efficiency. We have two nested loops, which gives us O(n²) time complexity. Plus for our expansion of the left &amp; right of our sequence, we would continually search in our array for those. At best a searching algorithm could give us O(2Logn) because we have to do it twice. Overall this gives us O(n²Logn) time complexity. Just not great.</p><h3>Approach</h3><h3>[ HashTable ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>Yep! You guessed it, we are bringing back our friend the hash table. We can look for the existence of a sequence as we iterate on our array. And store each value in our array to see if we have seen a possible sequence already.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">keep</span> <span class="n">track</span> <span class="n">of</span> <span class="n">this</span> <span class="n">iterative</span> <span class="n">sequence</span> <span class="n">length</span>
    <span class="k">while</span> <span class="err">±</span> <span class="mi">1</span> <span class="n">of</span> <span class="n">our</span> <span class="n">number</span> <span class="n">exists</span> <span class="k">in</span> <span class="n">the</span> <span class="n">hashTable</span>
        <span class="n">append</span> <span class="n">to</span> <span class="n">our</span> <span class="n">sequence</span>
        <span class="n">keep</span> <span class="n">expanding</span> <span class="k">in</span> <span class="n">the</span> <span class="n">direction</span> <span class="n">we</span> <span class="n">are</span> <span class="n">checking</span>
    <span class="n">add</span> <span class="n">this</span> <span class="n">number</span> <span class="n">to</span> <span class="n">the</span> <span class="n">hashTable</span>
    <span class="n">what</span> <span class="k">is</span> <span class="n">bigger</span><span class="p">,</span> <span class="n">the</span> <span class="n">longest</span> <span class="n">sequence</span> <span class="n">we</span> <span class="n">have</span> <span class="n">seen</span><span class="p">?</span> <span class="n">or</span> <span class="n">this</span> <span class="n">iterative</span> <span class="n">sequence</span> <span class="n">length</span><span class="p">?</span>

<span class="k">return</span> <span class="n">longest</span>
</div></code></pre><p>This is an O(n) solution, where n is the length of the input array, because we only iterate through the array once, and our while loop is just checking for the existence of a number in a hash table. Hash Table's give us O(1) lookup which is awesome. Our space is O(n) because we are just filling a hashTable, and a hashTable can only be n length where n is the number of unique numbers in our input array. Let's create the final answer:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">longest</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// Initially our greatest sequence will be 0</span>
<span class="kd">var</span> <span class="nv">hashMap</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">:</span><span class="nb">Bool</span><span class="p">]()</span>

<span class="k">for</span> <span class="n">element</span> <span class="k">in</span> <span class="n">nums</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">minusOne</span> <span class="p">=</span> <span class="n">element</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// Create a variable for the left section of our possible sequence</span>
    <span class="kd">var</span> <span class="nv">plusOne</span> <span class="p">=</span> <span class="n">element</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// Create a variable for the right section of our possible sequence</span>
    <span class="kd">var</span> <span class="nv">thisSequenceLongest</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">hashMap</span><span class="p">[</span><span class="n">minusOne</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// While we have seen a left sequence (it exists in our hashTable)</span>
        <span class="n">thisSequenceLongest</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">minusOne</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1">// Keep expanding</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="n">hashMap</span><span class="p">[</span><span class="n">plusOne</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// While we have seen a right sequence (it exists in our hashTable)</span>
        <span class="n">thisSequenceLongest</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">plusOne</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// Keep expanding</span>
    <span class="p">}</span>
    <span class="n">hashMap</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span> <span class="c1">// Add this element to our hashTable</span>
    <span class="n">longest</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">longest</span><span class="p">,</span> <span class="n">thisSequenceLongest</span><span class="p">)</span> <span class="c1">// Update the longest sequence we have seen</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">longest</span>
</div></code></pre><p>Nice! This was definitely a tricky one.</p><hr><h1>Encode and Decode Strings</h1><p>This is a LeetCode premium question, but still worth going over as it gives good insight on Array/String manipulation! This is a classic Google question too. Here is the screenshot:</p><img src="https://swiftrefresher.com/encodedecodestrings.png"/><h3>Possible Ideas</h3><p>Pretty straight forward! And considering there is not really a point to optimize a brute force solution lets walk through some thoughts.<br><br>1. We have to create 2 functions, an encoding function &amp; a decoding function. The importance is how we need to encode our original array, so our decoding function will know how to handle the string. 2. We need to make this generic enough to use any ASCII characters. 3. This must be stateless. No class level variables allowed.</p><p>So when I looked at this problem, my first thought was 'I need a way to mark the separation of values in our original array'. For example if we have an input array of ["Alex", "Loves", "Google"] then I need a special character to mark the difference between "Alex" and "Google". With this thinking, I chose "#" as my separation character. ["Alex", "Loves", "Google"] would turn into → "Alex#Loves#Google". Nice!</p><p>This causes concern though. In our original problem statement, the question mentioned we need these functions to be generic enough to host any ASCII character. If we use any ASCII character as our separation element, there is the chance the separation element appears in our input array. Let's take the input array of ["Alex", "#", "R"] for example. If our separation element is "#" our input array would be encoded to "Alex###R". When we go to decode this, and decode based on separation elements, does the string "Alex###R" translate to ["Alex", "##R"]? Or ["Alex#", "#R"]? Or ["Alex#", "#", "R"]? There is no way to know. And no matter the separation character we choose to use, this will be a problem.</p><p>To solve this, we need a way to define 1. the separation of characters, and 2. the beginning and end of an element. A straight forward way to go about this is by using the word's length + separation character at the beginning of each element. For example ["Alex", "#", "R"] is encoded into "4#Alex1##1#R". The thinking here is, when we get to separation character, the previous number to it will tell us how far ahead to skip for our element. So on and so forth ad nauseam. Let's get some psuedocode together for the encoding and decoding.</p><pre><code><div class="highlight"><span></span><span class="n">Encoding</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">word</span> <span class="k">in</span> <span class="n">input</span>
        <span class="n">concatenate</span> <span class="k">return</span> <span class="n">string</span> <span class="n">with</span><span class="p">:</span> <span class="n">word</span> <span class="n">length</span> <span class="o">+</span> <span class="s">&quot;#&quot;</span> <span class="o">+</span> <span class="n">word</span>
    <span class="k">return</span> <span class="n">the</span> <span class="n">encoded</span> <span class="n">string</span>
    
    
<span class="n">Decoding</span><span class="p">:</span>
    <span class="n">start</span> <span class="n">at</span> <span class="n">the</span> <span class="n">beginning</span> <span class="n">of</span> <span class="n">the</span> <span class="n">encoded</span> <span class="n">string</span>
    <span class="k">while</span> <span class="n">this</span> <span class="n">index</span> <span class="k">is</span> <span class="k">in</span> <span class="n">bounds</span> <span class="n">of</span> <span class="n">the</span> <span class="n">string</span>
        <span class="n">start</span> <span class="n">a</span> <span class="n">new</span> <span class="n">index</span> <span class="k">for</span> <span class="n">the</span> <span class="n">current</span> <span class="n">element</span>
        <span class="k">while</span> <span class="n">this</span> <span class="n">new</span> <span class="n">index</span> <span class="k">is</span> <span class="n">not</span> <span class="n">a</span> <span class="n">separation</span> <span class="n">character</span>
            <span class="n">append</span> <span class="n">to</span> <span class="n">new</span> <span class="n">index</span> <span class="n">by</span> <span class="mi">1</span>
        <span class="k">else</span>
            <span class="kr">get</span> <span class="n">word</span> <span class="n">size</span> <span class="n">from</span> <span class="n">index</span> <span class="p">-&gt;</span> <span class="n">newIndex</span>
            <span class="kr">get</span> <span class="n">word</span> <span class="n">from</span> <span class="n">new</span> <span class="n">index</span> <span class="p">-&gt;</span> <span class="n">word</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">append</span> <span class="n">word</span> <span class="n">to</span> <span class="n">response</span>
            <span class="n">track</span> <span class="n">new</span> <span class="n">index</span> <span class="n">at</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">the</span> <span class="bp">last</span> <span class="n">added</span> <span class="n">word</span>
</div></code></pre><p>Lot of Math there! Let's talk some time complexities. Encoding function will obviously be O(n) time where n is the length of the inout array. The space complexity will be O(c + 1 + s) where c is the number of characters in our input array, s is the separation character or string we choose, and 1 for the length of the word in Int form.</p><p>Decoding is a little more complicated. The space complexity is O(n) where n is the length of our original input array. The time complexity is O(n - x) where n is the length of characters in our encoded string, and x is the number of elements in our original input array. Not too bad.</p><h3>Approach</h3><h3>[ Separation Characters + Length ]</h3><h3>[ Encoding: O(n) time, O(c + 1 + s) space ]</h3><h3>[ Decoding: O(n - x) time, O(n) space ]</h3><p>Let's put this implementation to the test!</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="kc">_</span> <span class="n">words</span><span class="p">:</span> <span class="p">[</span><span class="nb">String</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">returnVal</span> <span class="p">=</span> <span class="s">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">word</span> <span class="k">in</span> <span class="n">words</span> <span class="p">{</span>
        <span class="n">returnVal</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="si">\(</span><span class="n">word</span><span class="p">.</span><span class="bp">count</span><span class="si">)</span><span class="s">&quot;</span> <span class="o">+</span> <span class="s">&quot;#&quot;</span> <span class="o">+</span> <span class="n">word</span> <span class="c1">// Pre-traversal concatenation</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">returnVal</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="kc">_</span> <span class="n">str</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="nb">String</span><span class="p">]</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">returnVal</span> <span class="p">=</span> <span class="p">[</span><span class="nb">String</span><span class="p">]()</span>
    <span class="kd">var</span> <span class="nv">index</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span> <span class="c1">// Loop through characters in our encoded string</span>
        
        <span class="kd">var</span> <span class="nv">thisWordIndex</span> <span class="p">=</span> <span class="n">index</span> <span class="c1">// Index for this given word</span>
        <span class="k">while</span> <span class="n">thisWordIndex</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nv">currentElementIndex</span> <span class="p">=</span> <span class="n">str</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="n">thisWordIndex</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">str</span><span class="p">[</span><span class="n">currentElementIndex</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;#&quot;</span> <span class="p">{</span> <span class="c1">// While we have not found a new word, continue</span>
                <span class="n">thisWordIndex</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">break</span> <span class="c1">// We have found a word, time to evaluate</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="kd">let</span> <span class="nv">beginningIndex</span> <span class="p">=</span> <span class="n">str</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="n">index</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">endingIndex</span> <span class="p">=</span> <span class="n">str</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="n">thisWordIndex</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">wordSize</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">beginningIndex</span><span class="p">..&lt;</span><span class="n">endingIndex</span><span class="p">])</span> <span class="p">??</span> <span class="mi">0</span> <span class="c1">// The size of the word</span>
        
        <span class="kd">let</span> <span class="nv">wordBeginningIndex</span> <span class="p">=</span> <span class="n">str</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="n">thisWordIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">wordEndingIndex</span> <span class="p">=</span> <span class="n">str</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="n">thisWordIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">wordSize</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">word</span> <span class="p">=</span> <span class="n">str</span><span class="p">[</span><span class="n">wordBeginningIndex</span><span class="p">..&lt;</span><span class="n">wordEndingIndex</span><span class="p">]</span> <span class="c1">// The word itself</span>
        
        <span class="n">returnVal</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="n">word</span><span class="p">))</span> <span class="c1">// Append the word to our return array</span>
        <span class="n">index</span> <span class="p">=</span> <span class="n">thisWordIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">wordSize</span> <span class="c1">// Set index to the end of our last word found and continue.</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">returnVal</span>
<span class="p">}</span>
</div></code></pre><p>Substrings in Swift are NOT FUN 😎</p><hr><h1>Top K Frequent Elements</h1><p>This is a tricky problem, especially in the iOS world.</p><img src="https://swiftrefresher.com/topkfrequentelements.png"/><h3>Brute Force</h3><p>I think the brute force solution is pretty obvious. We can nest loops, and for every element we can count how often it appears in the input array. Outside of our loops we can keep track of the largest count. Based on our K input integer we can build out our top k frequent elements array.</p><pre><code><div class="highlight"><span></span><span class="n">create</span> <span class="n">array</span> <span class="n">of</span> <span class="n">k</span> <span class="n">length</span>

<span class="k">for</span> <span class="n">indexed</span> <span class="n">loop</span> <span class="n">from</span> <span class="mi">1</span> <span class="p">-&gt;</span> <span class="n">k</span>
    <span class="n">loop</span> <span class="n">input</span> <span class="n">array</span> <span class="n">and</span> <span class="bp">find</span> <span class="n">most</span> <span class="n">indexed</span> <span class="n">most</span> <span class="n">element</span> <span class="n">and</span> <span class="n">its</span> <span class="bp">count</span>
    <span class="n">compare</span> <span class="n">after</span> <span class="n">each</span> <span class="n">loop</span> <span class="n">to</span> <span class="n">see</span> <span class="k">if</span> <span class="n">the</span> <span class="k">return</span> <span class="n">array</span> <span class="n">needs</span> <span class="n">to</span> <span class="n">be</span> <span class="n">adjusted</span>
</div></code></pre><p>This has two nested loops so the time complexity here would be O(nk) where n is the length of the input array, and k is the input variable k. The space complexity would be O(k) where k is the input variable k we start the problem with, due to the length of the return variable.<br><br>Even a brute force solution here would be difficult, so lets simplify our lives a little bit, and introduce our favorite friends: Sorting and A HashTable.</p><h3>Approach</h3><h3>[ Sort + HashTable ]</h3><h3>[ O(uLogu) time + O(2u) space ]</h3><p>One easy way to simplify storing the count of each character frequency is to use a HashTable. We can use the HashTable as an [Int:Int] dictionary where each key is the unique element in the input array, and the value is its frequency in the input array. We can then sort our dictionary by values, descending order to get which elements have the highest frequency, and return the first k from the sorted dictionary.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">add</span> <span class="n">to</span> <span class="n">hashTable</span> <span class="k">if</span> <span class="n">it</span> <span class="n">doesnt</span> <span class="n">already</span> <span class="n">exist</span>
    <span class="k">if</span> <span class="n">it</span> <span class="n">does</span> <span class="n">exist</span><span class="p">,</span> <span class="n">append</span> <span class="n">its</span> <span class="n">frequency</span> <span class="n">by</span> <span class="mi">1</span>

<span class="bp">sort</span> <span class="n">hashTable</span> <span class="n">by</span> <span class="n">values</span><span class="p">,</span> <span class="n">descending</span> <span class="n">order</span>

<span class="k">for</span> <span class="n">indexed</span> <span class="n">loop</span> <span class="k">in</span> <span class="mi">1</span> <span class="p">-&gt;</span> <span class="n">k</span>
    <span class="kr">get</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="n">key</span><span class="p">,</span> <span class="n">and</span> <span class="n">add</span> <span class="n">to</span> <span class="k">return</span> <span class="n">array</span>
    
<span class="k">return</span> <span class="n">returnArray</span>
</div></code></pre><p>The tricky thing here is to make sure you are sorting properly. We want to sort the hashTable, but after sorting we only care about the keys in the hash-table, so it might be more intelligent to leverage the swift built in higher order functions on arrays to get the data structure we want.</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span>
<span class="kd">var</span> <span class="nv">returnVal</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]()</span>

<span class="k">for</span> <span class="n">num</span> <span class="k">in</span> <span class="n">nums</span> <span class="p">{</span>
    <span class="n">hashTable</span><span class="p">[</span><span class="n">num</span><span class="p">,</span> <span class="k">default</span><span class="p">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// add these values to a hashTable, and append the existing number if it exists</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">sorted</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">hashTable</span><span class="p">.</span><span class="bp">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="nv">$1</span><span class="p">.</span><span class="n">value</span> <span class="p">})</span> <span class="c1">// sort our hashTable by value.</span>
                <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">key</span> <span class="p">})</span> <span class="c1">//  But then put the (now sorted) keys into an array for easier access</span>

<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.&lt;</span><span class="n">k</span> <span class="p">{</span> <span class="c1">// loop through K times to get the top K elements from the sorted data structure</span>
    <span class="n">returnVal</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">sorted</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">returnVal</span>
</div></code></pre><p>The time complexity here is (n + uLogu + u + k) Where K is our input variable k, and n is the size of the input array, and u is the number of unique numbers. We go through the input array once (n), we sort the hashTable (guaranteed to only have u elements -&gt; uLogu), we add the unique elements into an array (u) and loop to find the top k elements (k). This mathematically simplifies to 2uLogu + n + k -&gt; which translates to uLogu on average.</p><p>The space complexity is O(2u) where u is the number of unique elements in the input array. Our HashTable will only ever be u size, because all keys must be unique in a hashTable. and our array of sorted keys will only ever be u size because of the same reason as before. That is 2 separate u space data structures that on average equal out to 2u.</p><p>Well done! Just be careful when it comes to Swift sorting 😃</p><hr><h1>Container With Most Water</h1><p>This is a tricky problem, especially in the iOS world.</p><img src="https://swiftrefresher.com/continerwithmostwater.png"/><p>On initial thinking we see this has a math component. The good news about programming problems with math components is, the math is never more than basic algebra. It's all about having strong problem solving skills</p><h3>Brute Force</h3><p>The brute force solution to this problem seems obvious at first. We need to find the largest area between two points. By having some nested loops, we can calculate all possible areas for all values.</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">track</span> <span class="n">of</span> <span class="n">maximum</span>
<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">inner</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="n">calculate</span> <span class="n">area</span>
        <span class="n">update</span> <span class="n">maximum</span> <span class="k">as</span> <span class="n">necessary</span>
</div></code></pre><p>The time complexity here is O(n²) due to the nested nature of the loops. Calculating area, and keeping track of a maximum are both O(1) operations. The space complexity is also constant because we are just storing the return value in a single variable, that does not expand.</p><h3>Approach</h3><h3>[ 2 pointers ]</h3><h3>[ O(n) time + O(1) space ]</h3><p>By using 2 pointers we can more effectively find the maximum area within a set of data points. We essentially need to find the 2 values that are the furthest apart, with one of the values being as maximum as possible. By keeping a left and right pointer and the beginning and end of our array, we can iteratively move the pointers inward based on which value is smaller. That way we can keep our maximum of the 2 values.</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">a</span> <span class="kr">left</span> <span class="o">&amp;</span> <span class="kr">right</span> <span class="n">pointer</span>
<span class="n">keep</span> <span class="n">a</span> <span class="n">maximum</span> <span class="n">array</span> <span class="n">variable</span>

<span class="k">while</span> <span class="kr">left</span> <span class="n">pointer</span> <span class="o">&lt;</span> <span class="kr">right</span> <span class="n">pointer</span> 
    <span class="bp">find</span> <span class="n">area</span>
    <span class="n">update</span> <span class="n">area</span> <span class="k">as</span> <span class="n">needed</span>
    <span class="n">move</span> <span class="n">either</span> <span class="kr">left</span> <span class="n">or</span> <span class="kr">right</span> <span class="n">pointer</span> <span class="n">inward</span> <span class="p">(</span><span class="n">whichever</span> <span class="k">is</span> <span class="n">smaller</span><span class="p">)</span>
</div></code></pre><p>The time complexity here is O(1/2n) which translates to O(n) on average. This is because we will on average gravitate towards the middle of our array with our pointers. It is guaranteed we will never move greater than the length of the array. The space complexity is O(1) because we only have 3 constant variables, the area &amp; the left + right pointers.</p><p>We should think how to find the area at each iteration. This can be found of width ** height. The height is the smaller of the 2 values because the problem description says we cannot tip our container. And the width is the distance between the 2 pointers aka rightPointer - leftPointer.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">height</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span> <span class="c1">// edge cases </span>
<span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rightPointer</span> <span class="p">=</span> <span class="n">height</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">area</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// setup our pointers</span>

<span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;</span> <span class="n">rightPointer</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">leftValue</span> <span class="p">=</span> <span class="n">height</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span>
    <span class="kd">let</span> <span class="nv">rightValue</span> <span class="p">=</span> <span class="n">height</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span>
    <span class="kd">let</span> <span class="nv">iterativeArea</span> <span class="p">=</span> <span class="p">(</span><span class="n">rightPointer</span> <span class="o">-</span> <span class="n">leftPointer</span><span class="p">)</span> <span class="o">*</span> <span class="bp">min</span><span class="p">(</span><span class="n">leftValue</span><span class="p">,</span> <span class="n">rightValue</span><span class="p">)</span> <span class="c1">// find our area at this cycle in our loop</span>
    
    <span class="n">area</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">iterativeArea</span><span class="p">)</span> <span class="c1">// update our area value as needed</span>
    
    <span class="k">if</span> <span class="n">leftValue</span> <span class="o">&lt;</span> <span class="n">rightValue</span> <span class="p">{</span> <span class="c1">// left value is smaller, move left pointer in</span>
        <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">leftValue</span> <span class="o">&gt;</span> <span class="n">rightValue</span> <span class="p">{</span> <span class="c1">// right value is smaller, move right pointer in</span>
        <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// values are equal, move both pointers</span>
        <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">area</span>
</div></code></pre><hr><h1>Conclusion</h1><p>When facing array problems, try to keep in mind some of these tricks we learned in these problems. You will start to find programming problems follow similar patterns! Happy Coding!</p><hr>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/leetcode/how-to-solve-a-leetcode-problem</guid><title>How to solve a Leetcode problem</title><description>Leetcode. The bane of many a programmer</description><link>https://swiftrefresher.com/leetcode/how-to-solve-a-leetcode-problem</link><pubDate>Mon, 14 Mar 2022 22:15:00 -0400</pubDate><content:encoded><![CDATA[<h1>Overview</h1><p>Overall, you will find that many leetcode problems are similar to one another. Once you build a solid foundation of knowledge (Blind 75) you will be able to conquer any problem! Keep this in mind when you are looking for patterns within problems. If a string problem stumps you, try thinking of it from an array perspective and vice versa! When I think about Leetcode solutions, I take the following steps:</p><h3>The process</h3><ol><li>Clarify the question with your interviewer. ASK QUESTIONS! Don't rush into it.</li><li>Understand the problem. Know WHY the answers are correct vs incorrect.</li><li>Approach a Brute Force solution, in THEORY but do not code yet.</li><li>Write some pseudocode for your brute force solution.</li><li>Run through test cases, on your pseudocode to make sure it works. (Time permitting)</li><li>Identify bottlenecks, and optimize as necessary.</li><li>Code the final solution.</li><li>TEST!</li></ol><h3>Testing</h3><p>When testing our solutions, it's always good to think about edge cases to test against. This shows our interviewer our deep knowledge of the underlying data structure, as well as the ability to think outside of the box. Here is my (not so) exhaustive list of testing criteria for arrays and strings.</p><h5>Arrays</h5><ol><li>Nil input value</li><li>Empty array</li><li>Single value in array</li><li>Repeating values in the array</li><li>Large array</li></ol><h5>Strings</h5><ol><li>Nil input value</li><li>Empty string</li><li>Special characters in strings (ie. $%^&amp;#😎😃)</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/ios-fundamentals/arrays</guid><title>Arrays Overview</title><description>Programmers best friend</description><link>https://swiftrefresher.com/ios-fundamentals/arrays</link><pubDate>Thu, 3 Mar 2022 23:15:00 -0500</pubDate><content:encoded><![CDATA[<h1>Arrays</h1><h2>Overview</h2><p>I figured we could start with one of the simplest data structures on our journey. Array's are a swift collection type &amp; they can hold elements of a single type, whether it be Integers, Strings, or Structs/Classes. They are linear collections that are accessible using indexes starting at index Zero.</p><h3>Array's in Memory</h3><p>Swift arrays come in 2 different variations depending on how you initialize them:</p><p>Static arrays are an array implementation in which the size of the array is determined on initialization. Under the hood, the machine will allocate a fixed amount of memory to store this initialized array. Which is nice! But comes at a cost. In order to append values, the machine will copy the entire array over, and allocate new memory space for it + the new value you want to add. This is a linear operation.</p><p>Dynamic arrays are an array implementation that preemptively allocates DOUBLE the memory needed to store the arrays values. Therefore when you want to append a new value, that operation is constant time due to the already free space available to add the value into memory. When all the extra free space is filled up, the array is copied and stored elsewhere. This operation is Amortized constant time, when inserting at the end of the array.</p><h3>Under the hood Swift Implementation</h3><p>When looking through the swift source code on arrays, you will see the underlying implementation of arrays uses Structs. This means arrays are value types, and whenever you copy an array over to a new variable, the value of the array is copied and stored in a new memory address. Any changes to this copied variable will not affect the original array. For example:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">originalArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="kd">var</span> <span class="nv">copyArray</span> <span class="p">=</span> <span class="n">originalArray</span>
<span class="n">copyArray</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="bp">print</span><span class="p">(</span><span class="n">originalArray</span><span class="p">)</span> <span class="c1">// [1, 2, 3]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">copyArray</span><span class="p">)</span> <span class="c1">// [1, 2, 3, 4]</span>
</div></code></pre><p>To be even more efficient, Swift uses copy-on-write optimization for arrays. This means copies of arrays are stored at the same memory address until one of the copies is mutated. Then the array is stored into a new memory address. Keep this in mind when writing efficient code, because in swift copying the array over a bunch is not the time consuming event. The mutation of the copy is what will cost you in Big O time.</p><h3>Big O operations on Arrays</h3><ul><li>Accessing value at an index <strong>O(1)</strong></li><li>Update value at an index <strong>O(1)</strong></li><li>Insert value at beginning <strong>O(n)</strong></li><li>Insert value at middle <strong>O(n)</strong></li><li>Insert value at end:<ul><li>Dynamic arrays: Amortized <strong>O(1)</strong></li><li>Static arrays: <strong>O(n)</strong></li></ul></li></ul><ul><li>Remove value at beginning <strong>O(n)</strong></li><li>Remove value at middle <strong>O(n)</strong></li><li>Remove value at end <strong>O(1)</strong></li><li>Copy array <strong>O(n)</strong></li></ul><h3>Array Declarations</h3><p>Arrays are very easy to declare (dynamic arrays):</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">arrayOne</span> <span class="p">=</span> <span class="p">[</span><span class="nb">String</span><span class="p">]()</span>
<span class="kd">let</span> <span class="nv">arrayTwo</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span>
<span class="kd">let</span> <span class="nv">arrayThree</span> <span class="p">=</span> <span class="p">[</span><span class="n">CustomObjectOne</span><span class="p">,</span> <span class="n">CustomObjectTwo</span><span class="p">]</span>
</div></code></pre><p>The swift compiler does some really cool things under the hood to infer the underlying type based on how you declare the variable.</p><p>You can also determine the size of the array &amp; repeated values of the array on variable declaration like so (static array):</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">arrayFour</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">repearing</span><span class="p">:</span> <span class="s">&quot;Four&quot;</span> <span class="bp">count</span><span class="p">:</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">// [&quot;Four&quot;, &quot;Four&quot;, &quot;Four&quot;, &quot;Four&quot;, &quot;Four&quot;, &quot;Four&quot;]</span>
</div></code></pre><h2>Operations on Arrays</h2><p>Inserting elements in arrays is simple, there are a couple main API's depending on your use case:</p><pre><code><div class="highlight"><span></span><span class="n">arrayFive</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="c1">// at to the end</span>
<span class="n">arrayFive</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">contentsOf</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span> <span class="c1">// add a sequence</span>
<span class="c1">// [1, 2, 8, 0, 7]</span>

<span class="n">arrayFive</span><span class="p">.</span><span class="bp">insert</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">at</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// 0-based index</span>
<span class="c1">// [1, 2, 8, 9, 0, 7]</span>
</div></code></pre><p>Here is how to delete elements in an array:</p><pre><code><div class="highlight"><span></span><span class="n">arrayFive</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span>
<span class="n">arrayFive</span><span class="p">.</span><span class="bp">removeLast</span><span class="p">()</span>
<span class="c1">// [2, 8, 9, 0]</span>

<span class="n">arrayFive</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">at</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> 
<span class="c1">// remove index 0</span>
<span class="c1">// [8, 9, 0]</span>
</div></code></pre><p>By accessing an element on an array you can substitute the value in place:</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="kd">let</span> <span class="nv">element</span> <span class="p">=</span> <span class="n">arrayFive</span><span class="p">.</span><span class="n">firstIndex</span><span class="p">(</span><span class="n">of</span><span class="p">:</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">arrayFive</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="mi">9</span>
<span class="p">}</span>
<span class="c1">// [9, 9, 0]</span>
</div></code></pre><h2>Higher Order Functions</h2><h3>Sort</h3><p>Say you have a collection of elements in the form of an array, and you want to sort these elements by some sort of predicate. The swift collection type comes with the built in sorted by function. This function returns a new array from your desired sorting mechanism. For example:</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="p">(</span><span class="n">Base</span><span class="p">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">Base</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="nb">Bool</span><span class="p">)</span> <span class="kr">rethrows</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">Base</span><span class="p">.</span><span class="n">Element</span><span class="p">]</span> 
</div></code></pre><p>The sorted by function takes a predicate in which you can define how to sort your elements.</p><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">FooStruct</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">value</span><span class="p">:</span> <span class="nb">Int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">nonSortedArray</span> <span class="p">=</span> <span class="p">[</span><span class="n">FooStruct</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="mi">15</span><span class="p">),</span> <span class="n">FooStruct</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">),</span> <span class="n">FooStruct</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="mi">9</span><span class="p">)]</span>
<span class="c1">// Trailing closure notation</span>
<span class="kd">var</span> <span class="nv">sortedArrayOne</span> <span class="p">=</span> <span class="n">nonSortedArray</span><span class="p">.</span><span class="bp">sorted</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="k">in</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">value</span>
<span class="p">}</span>
<span class="c1">// Shorthand notation</span>
<span class="kd">var</span> <span class="nv">sortedArrayTwo</span> <span class="p">=</span> <span class="n">nonSortedArray</span><span class="p">.</span><span class="bp">sorted</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="nv">$1</span><span class="p">.</span><span class="n">value</span> <span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">sortedArrayTwo</span><span class="p">)</span> <span class="c1">// [FooStruct(value: 3), FooStruct(value: 9), FooStruct(value: 15)] </span>
</div></code></pre><h3>Map</h3><p>The main purpose of Map is to iterate on every element in the array, but instead of sorting the elements, you can transform each element based on a closure you pass into it. Here is the underlying implementation:</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">map</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">transform</span><span class="p">:</span> <span class="p">(</span><span class="kc">Self</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">T</span><span class="p">)</span> <span class="kr">rethrows</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span>
</div></code></pre><p>Given the return type of the map function is T, we can pass in one type of array, and return a different type of array. For example taking in an array of numbers, mapping over them, and returning that array represented in String form.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">newArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="bp">map</span> <span class="p">{</span> <span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span>
    <span class="k">return</span> <span class="nb">String</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="p">}</span>
</div></code></pre><h3>Filter</h3><p>You can specify a filter in the form of a closure, and you can filter an array given your criteria.</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">filter</span><span class="p">(</span><span class="kc">_</span> <span class="n">isIncluded</span><span class="p">:</span> <span class="p">@</span><span class="n">escaping</span> <span class="p">(</span><span class="kc">Self</span><span class="p">.</span><span class="n">Elements</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">LazyFilterSequence</span><span class="p">&lt;</span><span class="kc">Self</span><span class="p">.</span><span class="n">Elements</span><span class="p">&gt;</span>
</div></code></pre><p>For example lets get all numbers from our array that are greater than 1.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">filteredArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="bp">map</span><span class="p">{</span> <span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">1</span>
<span class="p">}</span>
</div></code></pre><h3>Reduce</h3><p>This function allows us to combine all the elements in a collection, and return a unified common (and also generic) type!</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">reduce</span><span class="p">&lt;</span><span class="n">Result</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">initialResult</span><span class="p">:</span> <span class="n">Result</span><span class="p">,</span> <span class="kc">_</span> <span class="n">nextPartialResult</span><span class="p">:</span> <span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="n">Bound</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">Result</span><span class="p">)</span> <span class="kr">rethrows</span> <span class="p">-&gt;</span> <span class="n">Result</span>
</div></code></pre><p>Let's say we want to take all of our numbers in an array, and combine them into a single long String.</p><pre><code><div class="highlight"><span></span><span class="c1">// Long version</span>
<span class="kd">let</span> <span class="nv">reduced</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">].</span><span class="bp">reduce</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{(</span><span class="n">result</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="k">in</span> 
    <span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="nb">String</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Inline version</span>
<span class="kd">let</span> <span class="nv">reduced</span> <span class="p">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">].</span><span class="bp">reduce</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">+</span> <span class="nb">String</span><span class="p">(</span><span class="nv">$1</span><span class="p">)</span> <span class="p">}</span>
</div></code></pre><h3>FlatMap</h3><p>This takes in a closure and applies this closure to every element in the array. It returns the flattened sequence post traversal.</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">flatMap</span><span class="p">&lt;</span><span class="n">SegmentOfResult</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">transform</span><span class="p">:</span> <span class="p">((</span><span class="n">key</span><span class="p">:</span> <span class="n">Key</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Value</span><span class="p">))</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">SegmentOfResult</span><span class="p">)</span> <span class="kr">rethrows</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">SegmentOfResult</span><span class="p">.</span><span class="n">Element</span><span class="p">]</span> <span class="k">where</span> <span class="n">SegmentOfResult</span> <span class="p">:</span> <span class="n">Sequence</span>
</div></code></pre><p>Remember that map can return a different array type than was traversed upon. But with FlatMap we can transform, and then flatten. Typically this function is used in sequences of sequences.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">strings</span> <span class="p">=</span> <span class="p">[[</span><span class="s">&quot;Hello&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s">&quot;GoodBye&quot;</span><span class="p">]]</span>
<span class="kd">let</span> <span class="nv">finalStrings</span> <span class="p">=</span> <span class="n">strings</span><span class="p">.</span><span class="n">flatMap</span><span class="p">({</span> <span class="nv">$0</span> <span class="p">})</span>
<span class="bp">print</span><span class="p">(</span><span class="n">finalStrings</span><span class="p">)</span> <span class="c1">// [&quot;Hello transformed&quot;, &quot;Goodbye transformed&quot;]</span>
</div></code></pre><h3>CompactMap</h3><p>This function is frequently used with sequences that contain optionals. It is a safe way to traverse an array, and safely unwrap the value, and return the new sequence</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">compactMap</span><span class="p">&lt;</span><span class="n">ElementOfResult</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">transform</span><span class="p">:</span> <span class="p">(</span><span class="n">Base</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">ElementOfResult</span><span class="p">?)</span> <span class="kr">rethrows</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">ElementOfResult</span><span class="p">]</span>
</div></code></pre><p>For example:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">optionals</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">?]</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">finalOptionals</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]</span> <span class="p">=</span> <span class="n">optionals</span><span class="p">.</span><span class="n">compactMap</span><span class="p">({</span> <span class="nv">$0</span> <span class="p">})</span>
<span class="bp">print</span><span class="p">(</span><span class="n">finalOptionals</span><span class="p">)</span> <span class="c1">// [1, 6, 7]</span>
</div></code></pre><h2>Array Slicing</h2><p>Slicing arrays, and getting specific ranges of arrays in swift can be slightly tricky as opposed to other programming languages.</p><h3>Ranges</h3><p>Starting in Swift 5, you can use the subscript of an arrays range, to get specific parts of an array. You use the swift built in Range type for this.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">test</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">test2</span> <span class="p">=</span> <span class="n">test</span><span class="p">[</span><span class="mf">0.</span><span class="p">.&lt;</span><span class="mi">2</span><span class="p">]</span> <span class="c1">// Give us the indices from the first array 0 up to, but not including the 2nd zero based index.</span>
<span class="bp">print</span><span class="p">(</span><span class="n">test2</span><span class="p">)</span> <span class="c1">// [3, 2]</span>

<span class="kd">let</span> <span class="nv">nums</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">99</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">nums2</span> <span class="p">=</span> <span class="n">nums</span><span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="mi">5</span><span class="p">]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span> <span class="c1">// [10, 3, 4, 2, 11, 14]</span>
</div></code></pre><h3>Prefix/Suffix</h3><p>There are also built in swift functions for getting the beginning and end sections of an array. All you need to do is pass the X number of prefixed or suffixed values you want from the array as a parameter in the function. Prefix is for the first X values from the array, and suffix is for the last X values you want from the array.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">longNums</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">88</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">312</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">firstThree</span> <span class="p">=</span> <span class="n">longNums</span><span class="p">.</span><span class="kr">prefix</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">lastThree</span> <span class="p">=</span> <span class="n">longNums</span><span class="p">.</span><span class="bp">suffix</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="bp">print</span><span class="p">(</span><span class="n">firstThree</span><span class="p">)</span> <span class="c1">// [10, 3, 2]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">lastThree</span><span class="p">)</span> <span class="c1">// [99, 100, 312]</span>
</div></code></pre><h2>Conclusion</h2><p>And thats it! You are now a Swift Array master, so give yourself a pat on the back. Coming soon we will be taking the arrays, and giving some real life application in Leetcode Problems. We will go over common tips &amp; tricks you will encounter in Leetcode array problems. Stay Tuned!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/about/about</guid><title>About</title><description>A little about myself 😄</description><link>https://swiftrefresher.com/about/about</link><pubDate>Thu, 3 Mar 2022 22:15:00 -0500</pubDate><content:encoded><![CDATA[<h2>Welcome!</h2><p>Hello everyone! My name is Alex Stevens, and I decided to do what a million other people have already done. Start a Swift blog. I feel this will be a good way to advance my iOS domain knowledge, as well as serve as a point of reference for future job interviews. I plan to cover all aspects of iOS Development from Computer Science algorithms, to App Extensions, to SwiftUI/Combine. I hope everyone joins me in on this journey, and I hope this will be a good resource to any iOS Engineer out there, no matter what part of your journey you are on. From a new grad, or a seasoned engineer looking to crack into the mobile development space, welcome! --Alex</p>]]></content:encoded></item></channel></rss>