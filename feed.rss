<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Swift Refresher</title><description>Welcome to my Swift Blog!</description><link>https://swiftrefresher.com</link><language>en</language><lastBuildDate>Tue, 22 Feb 2022 22:12:35 -0500</lastBuildDate><pubDate>Tue, 22 Feb 2022 22:12:35 -0500</pubDate><ttl>250</ttl><atom:link href="https://swiftrefresher.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://swiftrefresher.com/home/arrays-strings-leetcode</guid><title>Leetcode Array's &amp; Strings</title><description>Now let's apply our array knowledge to some leetcode problems.</description><link>https://swiftrefresher.com/home/arrays-strings-leetcode</link><pubDate>Sat, 19 Feb 2022 11:09:00 -0500</pubDate><content:encoded><![CDATA[<h1>Leetcode Array's &amp; Strings</h1><p>Overall, you will find that array and string problems in Leetcode are pretty interchangable and similar. Keep this in mind when you are looking for patterns within problems. If a string problem stumps you, try thinking of it from an array perspective and vice versa! When I think about Leetcode solutions, I take the following steps:</p><ol start="0"><li>Clarify the question with your interviewer. ASK QUESTIONS! Don't rush into it.</li><li>Understand the problem. Know WHY the answers are correct vs incorrect.</li><li>Approach a Brute Force solution, in THEORY but do not code yet.</li><li>Write some psuedocode for your brute force solution.</li><li>Run through test cases, on your psuedocode to make sure it works.</li><li>Identify bottlenecks, and optimize as necessary.</li><li>Code the final solution.</li><li>TEST!</li></ol><h3>Testing</h3><p>When testing our solutions, it's always good to think about edge cases to test against. This shows our interviewer our deep knowledge of the underlying data structure, as well as the ability to think outside of the box. Here is my (not so) exhaustive list of testing criteria for arrays and strings.</p><h5>Arrays</h5><ol><li>Nil input value</li><li>Empty array</li><li>Single value in array</li><li>Repeating values in the array</li><li>Large array</li></ol><h5>Strings</h5><ol><li>Nil input value</li><li>Empty string</li><li>Special characters in strings (ie. $%^&amp;#ðŸ˜ŽðŸ˜ƒ)</li></ol><h3>TwoSum</h3><p>This is a classic introductory problem &amp; it is a good place for us to start our leetcode journey. Read over the problem statement below.</p><img src="https://swiftrefresher.com/ArraysLeetcode/twosum.png"/><p>Pretty straightforward right? Let's take this step by step and make sure we understand the solution. We need the indices of 2 numbers that add up to a target. We can assume there is one answer, and we may not use the same element twice. Easy enough.</p><p>A brute force solution here is pretty obvious, let's go through each element in the array, and iterate over every other element, to see if we add up to a target. This is a common brute force method for most array problems. This will give us a <strong>O(nÂ²)</strong> time &amp; <strong>O(1)</strong> spacial solution. Let's write some pseudocode for this solution and test it. While testing, make sure to capture edge cases!</p><pre><code><span class="keyword">for</span> number <span class="keyword">in</span> array
    <span class="keyword">for</span> every other number <span class="keyword">in</span> array
        <span class="keyword">if</span> number + other number = target
            <span class="keyword">return</span> [number index, other number index]
</code></pre><p>Let's run through a quick test here for our solution. Say we are given an array of [4, 2, 1, 3] and our target is 3. We start at 4, and loop through the rest of the array numbers. 4 + 2 != 3.....4 + 1 != 3..and so on. No luck for our first number 4. So let's move on to the next number 2. Lucky for us, our first try with number 2 works! 2 + 1 = 3. So in this case we would return the indices of 2 &amp; 1 in array form. Namely, [1, 2].</p><p>Now this simple testing may seem redundant, but it's important we build the foundational blocks for solving these easy problems, so when we arrive at harder problems, we have this base knowledge.</p><p>It is time to consider some bottlenecks, and think how we can optimize our solution. Firstly, if you notice some nested for loops in your code, that is a code smell. Think how those can be optimized. By using some auxiliary data structure for storage you can easily look up past calculations for your use case. In our case, we should try to optimize our <strong>O(nÂ²)</strong> time solution into a <strong>O(n)</strong> time solution. For array problems this is the mecca. This brings us to our introduction of hash tables/dictionary's. We can have constant lookup in swift dictionaries.</p><p>In our case lets consider we loop through the array 1 time, and in a hash table, we store the key as the element of our array and the value as the index of each value. So our original array of [4, 2, 1, 3] turns into a dictionary of [4: 0, 2: 1, 1: 2, 3: 3]. Now in our problem, we can go through our array 1 time, and at each element we can see if the inverse of the target exists. Namely it comes down to this pseudocode:</p><pre><code><span class="keyword">for</span> number <span class="keyword">in</span> array
    add to dictionary. [number: index of number]
    
<span class="keyword">for</span> number <span class="keyword">in</span> array
    inverse = target - number
    <span class="keyword">if</span> dictionary[inverse] exists
        <span class="keyword">return</span> [number, dictionary[inverse]]
</code></pre><p>After testing, we see this is a lot more efficient, and it works! We gave up some constant space in order for time efficiency, but these tradeoffs are things you can discuss with your interviewer. Now let's code our final solution. Don't forget to cover those edge cases, and to practice safe optional unwrapping!</p><pre><code><span class="keyword">guard</span> nums.<span class="property">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> { <span class="keyword">return</span> [] } <span class="comment">// edge case for empty array + single element in array.</span>
<span class="keyword">var</span> hashTable = [<span class="type">Int</span>:<span class="type">Int</span>]()
<span class="keyword">for</span> (index, element) <span class="keyword">in</span> nums.<span class="call">enumerated</span>() {
    hashTable[element] = index
}

<span class="keyword">for</span> (index, element) <span class="keyword">in</span> nums.<span class="call">enumerated</span>() {
    <span class="keyword">let</span> inverse = target - element
    <span class="keyword">if let</span> existingInverse = hashTable[inverse], unwrappedInverse != index { <span class="comment">// we should not be using the same element within itself. Make sure to read the problem carefully!</span>
        <span class="keyword">return</span> [existingInverse, index]
    }
}

<span class="keyword">return</span> [] <span class="comment">// we have no solution.</span> 

</code></pre><p>Nice work!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/home/arrays</guid><title>Arrays</title><description>Let's get started with Data Structures! Starting with a classic: Arrays.</description><link>https://swiftrefresher.com/home/arrays</link><pubDate>Thu, 9 Dec 2021 03:26:00 -0500</pubDate><content:encoded><![CDATA[<h1>Arrays</h1><h2>Overview</h2><p>I figured we could start with one of the simplest data structures on our journey. Array's are a swift collection type &amp; they can hold elements of a single type, whether it be Integers, Strings, or Structs/Classes. They are linear collections that are accesible using indexes starting at index Zero.</p><h2>Array's in Memory</h2><p>Swift arrays come in 2 different variations depending on how you initialize them:</p><p>Static arrays are an array implementation in which the size of the array is determined on initialization. Under the hood, the machine will allocate a fixed amount of memory to store this initialized array. Which is nice! But comes at a cost. In order to append values, the machine will copy the entire array over, and allocate new memory space for it + the new value you want to add. This is a linear operation.</p><p>Dynamic arrays are an array implementation that preemptively allocates DOUBLE the memory needed to store the arrays values. Therefore when you want to append a new value, that operation is constant time due to the already free space available to add the value into memory. When all the extra free space is filled up, the array is copied and stored elsewhere. This operation is Amortized constant time, when inserting at the end of the array.</p><h2>Under the hood Swift Implementation</h2><p>When looking through the swift source code on arrays, you will see the underlying implementation of arrays uses Structs. This means arrays are value types, and whenever you copy an array over to a new variable, the value of the array is copied and stored in a new memory address. Any changes to this copied variable will not affect the original array. For example:</p><pre><code><span class="keyword">var</span> originalArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]
<span class="keyword">var</span> copyArray = originalArray
copyArray.<span class="call">append</span>(<span class="number">4</span>)

<span class="call">print</span>(originalArray) <span class="comment">// [1, 2, 3]</span>
<span class="call">print</span>(copyArray) <span class="comment">// [1, 2, 3, 4]</span>

</code></pre><p>To be even more efficient, Swift uses copy-on-write optimization for arrays. This means copies of arrays are stored at the same memory address until one of the copies is mutated. Then the array is stored into a new memory address. Keep this in mind when writing efficient code, because in swift copying the array over a bunch is not the time consuming event. The mutation of the copy is what will cost you in Big O time.</p><h2>Big O operations on Arrays</h2><ul><li>Accessing value at an index <strong>O(1)</strong></li><li>Update value at an index <strong>O(1)</strong></li><li>Insert value at beginning <strong>O(n)</strong></li><li>Insert value at middle <strong>O(n)</strong></li><li>Insert value at end:<ul><li>Dynamic arrays: Amortized <strong>O(1)</strong></li><li>Static arrays: <strong>O(n)</strong></li></ul></li></ul><ul><li>Remove value at beginning <strong>O(n)</strong></li><li>Remove value at middle <strong>O(n)</strong></li><li>Remove value at end <strong>O(1)</strong></li><li>Copy array <strong>O(n)</strong></li></ul><h2>Array Declarations</h2><p>Arrays are very easy to declare (dynamic arrays):</p><pre><code><span class="keyword">let</span> arrayOne = [<span class="type">String</span>]()
<span class="keyword">let</span> arrayTwo: [<span class="type">Int</span>] = []
<span class="keyword">let</span> arrayThree = [<span class="type">CustomObjectOne</span>, <span class="type">CustomObjectTwo</span>]
</code></pre><p>The swift compiler does some really cool things under the hood to infer the underlying type based on how you declare the variable.</p><p>You can also determine the size of the array &amp; repeated values of the array on variable declaration like so (static array):</p><pre><code><span class="keyword">let</span> arrayFour = <span class="type">Array</span>(repearing: <span class="string">"Four"</span> count: <span class="number">6</span>) <span class="comment">// ["Four", "Four", "Four", "Four", "Four", "Four"]</span>
</code></pre><h2>Operations on Arrays</h2><p>Inserting elements in arrays is simple, there are a couple main API's depending on your use case:</p><pre><code>arrayFive.<span class="call">append</span>(<span class="number">8</span>) <span class="comment">// at to the end</span>
arrayFive.<span class="call">append</span>(contentsOf: [<span class="number">0</span>, <span class="number">7</span>]) <span class="comment">// add a sequence
// [1, 2, 8, 0, 7]</span>

arrayFive.<span class="call">insert</span>(<span class="number">9</span>, at: <span class="number">3</span>) <span class="comment">// 0-based index
// [1, 2, 8, 9, 0, 7]</span>
</code></pre><p>Here is how to delete elements in an array:</p><pre><code>arrayFive.<span class="call">removeFirst</span>()
arrayFive.<span class="call">removeLast</span>()
<span class="comment">// [2, 8, 9, 0]</span>

arrayFive.<span class="call">remove</span>(at: <span class="number">0</span>) 
<span class="comment">// remove index 0
// [8, 9, 0]</span>
</code></pre><p>By accessing an element on an array you can substitute the value in place:</p><pre><code><span class="keyword">if let</span> element = arrayFive.<span class="call">firstIndex</span>(of: <span class="number">8</span>) {
    arrayFive[element] = <span class="number">9</span>
}
<span class="comment">// [9, 9, 0]</span>
</code></pre><h2>Higher Order Functions</h2><h3>Sort</h3><p>Say you have a collection of elements in the form of an array, and you want to sort these elements by some sort of predicate. The swift collection type comes with the built in sorted by function. This function returns a new array from your desired sorting mechanism. For example:</p><pre><code><span class="keyword">func</span> sorted(by: (<span class="type">Base</span>.<span class="type">Element</span>, <span class="type">Base</span>.<span class="type">Element</span>) <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">Base</span>.<span class="type">Element</span>] 
</code></pre><p>The sorted by function takes a predicate in which you can define how to sort your elements.</p><pre><code><span class="keyword">struct</span> FooStruct {
    <span class="keyword">var</span> value: <span class="type">Int</span>
}

<span class="keyword">var</span> nonSortedArray = [<span class="type">FooStruct</span>(value: <span class="number">15</span>), <span class="type">FooStruct</span>(value: <span class="number">3</span>), <span class="type">FooStruct</span>(value: <span class="number">9</span>)]
<span class="comment">// Trailing closure notation</span>
<span class="keyword">var</span> sortedArrayOne = nonSortedArray.<span class="dotAccess">sorted</span> (a, b) -&gt; <span class="type">Bool</span> <span class="keyword">in</span> {
    <span class="keyword">return</span> a.<span class="property">value</span> &lt; b.<span class="property">value</span>
}
<span class="comment">// Shorthand notation</span>
<span class="keyword">var</span> sortedArrayTwo = nonSortedArray.<span class="call">sorted</span> { $0.<span class="property">value</span> &lt; $1.<span class="property">value</span> }

<span class="call">print</span>(sortedArrayTwo) <span class="comment">// [FooStruct(value: 3), FooStruct(value: 9), FooStruct(value: 15)]</span> 
</code></pre><h3>Map</h3><p>The main purpose of Map is to iterate on every element in the array, but instead of sorting the elements, you can transform each element based on a closure you pass into it. Here is the underlying implementation:</p><pre><code><span class="keyword">func</span> map&lt;T&gt;(<span class="keyword">_</span> transform: (<span class="type">Self</span>.<span class="type">Element</span>) <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>]
</code></pre><p>Given the return type of the map function is T, we can pass in one type of array, and return a different type of array. For example taking in an array of numbers, mapping over them, and returning that array represented in String form.</p><pre><code><span class="keyword">let</span> newArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="call">map</span> { (item) -&gt; <span class="type">String</span>
    <span class="keyword">return</span> <span class="type">String</span>(item)
}
</code></pre><h3>Filter</h3><p>You can specify a filter in the form of a closure, and you can filter an array given your criteria.</p><pre><code><span class="keyword">func</span> filter(<span class="keyword">_</span> isIncluded: <span class="keyword">@escaping</span> (<span class="type">Self</span>.<span class="type">Elements</span>.<span class="type">Element</span>) -&gt; <span class="type">Bool</span>) -&gt; <span class="type">LazyFilterSequence</span>&lt;<span class="type">Self</span>.<span class="type">Elements</span>&gt;
</code></pre><p>For example lets get all numbers from our array that are greater than 1.</p><pre><code><span class="keyword">let</span> filteredArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].map{ (item) -&gt; <span class="type">Bool</span> <span class="keyword">in
    return</span> item &gt; <span class="number">1</span>
}

</code></pre><h3>Reduce</h3><p>This function allows us to combine all the elements in a collection, and return a unified common (and also generic) type!</p><pre><code><span class="keyword">func</span> reduce&lt;Result&gt;(<span class="keyword">_</span> initialResult: <span class="type">Result</span>, <span class="keyword">_</span> nextPartialResult: (<span class="type">Result</span>, <span class="type">Bound</span>) <span class="keyword">throws</span> -&gt; <span class="type">Result</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Result</span>
</code></pre><p>Lets say we want to take all of our numbers in an array, and combine them into a single long String.</p><pre><code><span class="comment">// Long version</span>
<span class="keyword">let</span> reduced = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>].<span class="call">reduce</span>(<span class="string">""</span>) {(result, item) -&gt; <span class="type">String</span> <span class="keyword">in 
    return</span> result + <span class="type">String</span>(item)
}
<span class="comment">// Inline version</span>
<span class="keyword">let</span> reduced = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>].<span class="call">reduce</span>(<span class="string">""</span>) { $0 + <span class="type">String</span>($1) }

</code></pre><h3>FlatMap</h3><p>This takes in a closure and applies this closure to every element in the array. It returns the flattened sequence post traversal.</p><pre><code><span class="keyword">func</span> flatMap&lt;SegmentOfResult&gt;(<span class="keyword">_</span> transform: ((key: <span class="type">Key</span>, value: <span class="type">Value</span>)) <span class="keyword">throws</span> -&gt; <span class="type">SegmentOfResult</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">SegmentOfResult</span>.<span class="type">Element</span>] <span class="keyword">where</span> <span class="type">SegmentOfResult</span> : <span class="type">Sequence</span>
</code></pre><p>Remember that map can return a different array type than was traversed upon. But with FlatMap we can transform, and then flatten. Typically this function is used in squences of sequences.</p><pre><code><span class="keyword">let</span> strings = [[<span class="string">"Hello"</span>], [<span class="string">"GoodBye"</span>]]
<span class="keyword">let</span> finalStrings = strings.<span class="call">flatMap</span>({ $0 })
<span class="call">print</span>(finalStrings) <span class="comment">// ["Hello transformed", "Goodbye transformed"]</span>
</code></pre><h3>CompactMap</h3><p>This function is frequently used with sequences that contain optionals. It is a safe way to traverse an array, and safely unwrap the value, and return the new sequence</p><pre><code><span class="keyword">func</span> compactMap&lt;ElementOfResult&gt;(<span class="keyword">_</span> transform: (<span class="type">Base</span>.<span class="type">Element</span>) <span class="keyword">throws</span> -&gt; <span class="type">ElementOfResult</span>?) <span class="keyword">rethrows</span> -&gt; [<span class="type">ElementOfResult</span>]
</code></pre><p>For example:</p><pre><code><span class="keyword">let</span> optionals: [<span class="type">Int</span>?] = [<span class="number">1</span>, <span class="keyword">nil</span>, <span class="number">6</span>, <span class="number">7</span>]
<span class="keyword">let</span> finalOptionals: [<span class="type">Int</span>] = optionals.<span class="call">compactMap</span>({ $0 })
<span class="call">print</span>(finalOptionals) <span class="comment">// [1, 6, 7]</span>
</code></pre><h2>Array slicing</h2><p>Slicing arrays, and getting specific ranges of arrays in swift can be slightly tricky as opposed to other programming languages.</p><h3>Ranges</h3><p>Starting in Swft 5, you can use the subscript of an arrays range, to get specific parts of an array. You use the swift built in Range type for this.</p><pre><code><span class="keyword">let</span> test = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]
<span class="keyword">let</span> test2 = test[<span class="number">0</span>..&lt;<span class="number">2</span>] <span class="comment">// Give us the indices from the first array 0 up to, but not including the 2nd zero based index.</span>
<span class="call">print</span>(test2) <span class="comment">// [3, 2]</span>

<span class="keyword">let</span> nums = [<span class="number">10</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">99</span>]
<span class="keyword">let</span> nums2 = nums[<span class="number">0</span>..<span class="number">5</span>]
<span class="call">print</span>(nums2) <span class="comment">// [10, 3, 4, 2, 11, 14]</span>
</code></pre><h3>Prefix / Suffix</h3><p>There are also built in swift functions for getting the beginning and end sections of an array. All you need to do is pass the X number of prefixed or suffixed values you want from the array as a parameter in the function. Prefix is for the first X values from the array, and suffix is for the last X values you want from the array.</p><pre><code><span class="keyword">let</span> longNums = [<span class="number">10</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">45</span>, <span class="number">67</span>, <span class="number">88</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">312</span>]
<span class="keyword">let</span> firstThree = longNums.<span class="call">prefix</span>(<span class="number">3</span>)
<span class="keyword">let</span> lastThree = longNums.<span class="call">suffix</span>(<span class="number">3</span>)

<span class="call">print</span>(firstThree) <span class="comment">// [10, 3, 2]</span>
<span class="call">print</span>(lastThree) <span class="comment">// [99, 100, 312]</span>
</code></pre><h2>Conclusion</h2><p>And thats it! You are now a Swift Array master, so give yourself a pat on the back. Coming soon we will be taking the arrays, and giving some real life application in Leetcode Problems. We will go over common tips &amp; tricks you will encounter in Leetcode array problems. Stay Tuned!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/home/first-post</guid><title>About myself!</title><description>Why I chose to create a Swift blog.</description><link>https://swiftrefresher.com/home/first-post</link><pubDate>Fri, 26 Nov 2021 08:33:00 -0500</pubDate><content:encoded><![CDATA[<h1>About myself!</h1><p>Hello everyone! My name is Alex Stevens, and I decided to do what a million other<br> people have already done. Start a Swift blog. I feel\ this will be a good way to advance my iOS domain knowledge, as well as serve as a point of reference for future job interviews. I plan to cover all aspects of iOS Development from Computer Science algorithms, to App Extensions, to SwiftUI/Combine.

I hope everyone joins me in on this journey, and I hope this will be a good resource to any iOS Engineer out there, no matter what part of your journey you are on. From a new grad, or a seasoned engineer looking to crack into the mobile development space, welcome!

--Alex
</p>]]></content:encoded></item></channel></rss>