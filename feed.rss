<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Blog</title><description>A description of A Blog</description><link>https://your-website-url.com</link><language>en</language><lastBuildDate>Mon, 7 Feb 2022 22:41:58 -0500</lastBuildDate><pubDate>Mon, 7 Feb 2022 22:41:58 -0500</pubDate><ttl>250</ttl><atom:link href="https://your-website-url.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://your-website-url.com/home/arrays</guid><title>Arrays</title><description>Let's get started with Data Structures! Starting with a classic: Arrays.</description><link>https://your-website-url.com/home/arrays</link><pubDate>Thu, 9 Dec 2021 03:26:00 -0500</pubDate><content:encoded><![CDATA[<h1>Arrays</h1><h2>Overview</h2><p>I figured we could start with one of the simplest data structures on our journey. Array's are a swift collection type &amp; they can hold elements of a single type, whether it be Integers, Strings, or Structs/Classes. They are linear collections that are accesible using indexes starting at index Zero.</p><h2>Array's in Memory</h2><p>Swift arrays come in 2 different variations depending on how you initialize them:</p><p>Static arrays are an array implementation in which the size of the array is determined on initialization. Under the hood, the machine will allocate a fixed amount of memory to store this initialized array. Which is nice! But comes at a cost. In order to append values, the machine will copy the entire array over, and allocate new memory space for it + the new value you want to add. This is a linear operation.</p><p>Dynamic arrays are an array implementation that preemptively allocates DOUBLE the memory needed to store the arrays values. Therefore when you want to append a new value, that operation is constant time due to the already free space available to add the value into memory. When all the extra free space is filled up, the array is copied and stored elsewhere. This operation is Amortized constant time, when inserting at the end of the array.</p><h2>Under the hood Swift Implementation</h2><p>When looking through the swift source code on arrays, you will see the underlying implementation of arrays uses Structs. This means arrays are value types, and whenever you copy an array over to a new variable, the value of the array is copied and stored in a new memory address. Any changes to this copied variable will not affect the original array. For example:</p><pre><code><span class="keyword">var</span> originalArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]
<span class="keyword">var</span> copyArray = originalArray
copyArray.<span class="call">append</span>(<span class="number">4</span>)

<span class="call">print</span>(originalArray) <span class="comment">// [1, 2, 3]</span>
<span class="call">print</span>(copyArray) <span class="comment">// [1, 2, 3, 4]</span>

</code></pre><p>To be even more efficient, Swift uses copy-on-write optimization for arrays. This means copies of arrays are stored at the same memory address until one of the copies is mutated. Then the array is stored into a new memory address. Keep this in mind when writing efficient code, because in swift copying the array over a bunch is not the time consuming event. The mutation of the copy is what will cost you in Big O time.</p><h2>Big O operations on Arrays</h2><ul><li>Accessing value at an index <strong>O(1)</strong></li><li>Update value at an index <strong>O(1)</strong></li><li>Insert value at beginning <strong>O(n)</strong></li><li>Insert value at middle <strong>O(n)</strong></li><li>Insert value at end:<ul><li>Dynamic arrays: Amortized <strong>O(1)</strong></li><li>Static arrays: <strong>O(n)</strong></li></ul></li></ul><ul><li>Remove value at beginning <strong>O(n)</strong></li><li>Remove value at middle <strong>O(n)</strong></li><li>Remove value at end <strong>O(1)</strong></li><li>Copy array <strong>O(n)</strong></li></ul><h2>Array Declarations</h2><p>Arrays are very easy to declare (dynamic arrays):</p><pre><code><span class="keyword">let</span> arrayOne = [<span class="type">String</span>]()
<span class="keyword">let</span> arrayTwo: [<span class="type">Int</span>] = []
<span class="keyword">let</span> arrayThree = [<span class="type">CustomObjectOne</span>, <span class="type">CustomObjectTwo</span>]
</code></pre><p>The swift compiler does some really cool things under the hood to infer the underlying type based on how you declare the variable.</p><p>You can also determine the size of the array &amp; repeated values of the array on variable declaration like so (static array):</p><pre><code><span class="keyword">let</span> arrayFour = <span class="type">Array</span>(repearing: <span class="string">"Four"</span> count: <span class="number">6</span>) <span class="comment">// ["Four", "Four", "Four", "Four", "Four", "Four"]</span>
</code></pre><h2>Operations on Arrays</h2><p>Inserting elements in arrays is simple, there are a couple main API's depending on your use case:</p><pre><code>arrayFive.<span class="call">append</span>(<span class="number">8</span>) <span class="comment">// at to the end</span>
arrayFive.<span class="call">append</span>(contentsOf: [<span class="number">0</span>, <span class="number">7</span>]) <span class="comment">// add a sequence
// [1, 2, 8, 0, 7]</span>

arrayFive.<span class="call">insert</span>(<span class="number">9</span>, at: <span class="number">3</span>) <span class="comment">// 0-based index
// [1, 2, 8, 9, 0, 7]</span>
</code></pre><p>Here is how to delete elements in an array:</p><pre><code>arrayFive.<span class="call">removeFirst</span>()
arrayFive.<span class="call">removeLast</span>()
<span class="comment">// [2, 8, 9, 0]</span>

arrayFive.<span class="call">remove</span>(at: <span class="number">0</span>) 
<span class="comment">// remove index 0
// [8, 9, 0]</span>
</code></pre><p>By accessing an element on an array you can substitute the value in place:</p><pre><code><span class="keyword">if let</span> element = arrayFive.<span class="call">firstIndex</span>(of: <span class="number">8</span>) {
    arrayFive[element] = <span class="number">9</span>
}
<span class="comment">// [9, 9, 0]</span>
</code></pre><h2>Higher Order Functions</h2><ol><li>The first higher order function is Sort. Say you have a collection of elements in the form of an array, and you want to sort these elements by some sort of predicate. The swift collection type comes with the built in sorted by function. This function returns a new array from your desired sorting mechanism. For example:</li></ol><pre><code><span class="keyword">func</span> sorted(by: (<span class="type">Base</span>.<span class="type">Element</span>, <span class="type">Base</span>.<span class="type">Element</span>) <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">Base</span>.<span class="type">Element</span>] 
</code></pre><p>The sorted by function takes a predicate in which you can define how to sort your elements.</p><pre><code><span class="keyword">struct</span> FooStruct {
    <span class="keyword">var</span> value: <span class="type">Int</span>
}

<span class="keyword">var</span> nonSortedArray = [<span class="type">FooStruct</span>(value: <span class="number">15</span>), <span class="type">FooStruct</span>(value: <span class="number">3</span>), <span class="type">FooStruct</span>(value: <span class="number">9</span>)]
<span class="comment">// Trailing closure notation</span>
<span class="keyword">var</span> sortedArrayOne = nonSortedArray.<span class="dotAccess">sorted</span> (a, b) -&gt; <span class="type">Bool</span> <span class="keyword">in</span> {
    <span class="keyword">return</span> a.<span class="property">value</span> &lt; b.<span class="property">value</span>
}
<span class="comment">// Shorthand notation</span>
<span class="keyword">var</span> sortedArrayTwo = nonSortedArray.<span class="call">sorted</span> { $0.<span class="property">value</span> &lt; $1.<span class="property">value</span> }

<span class="call">print</span>(sortedArrayTwo) <span class="comment">// [FooStruct(value: 3), FooStruct(value: 9), FooStruct(value: 15)]</span> 
</code></pre><ol start="2"><li>Another higher order function is Map. The main purpose of Map is to iterate on every element in the array, but instead of sorting the elements, you can transform each element based on a closure you pass into it. Here is the underlying implementation:</li></ol><pre><code><span class="keyword">func</span> map&lt;T&gt;(<span class="keyword">_</span> transform: (<span class="type">Self</span>.<span class="type">Element</span>) <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>]
</code></pre><p>Given the return type of the map function is T, we can pass in one type of array, and return a different type of array. For example taking in an array of numbers, mapping over them, and returning that array represented in String form.</p><pre><code><span class="keyword">let</span> newArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="call">map</span> { (item) -&gt; <span class="type">String</span>
    <span class="keyword">return</span> <span class="type">String</span>(item)
}
</code></pre><ol start="3"><li>A very common, and frequently used higher order function is Filter. You can specify a filter in the form of a closure, and you can filter an array given your criteria.</li></ol><pre><code><span class="keyword">func</span> filter(<span class="keyword">_</span> isIncluded: <span class="keyword">@escaping</span> (<span class="type">Self</span>.<span class="type">Elements</span>.<span class="type">Element</span>) -&gt; <span class="type">Bool</span>) -&gt; <span class="type">LazyFilterSequence</span>&lt;<span class="type">Self</span>.<span class="type">Elements</span>&gt;
</code></pre><p>For example lets get all numbers from our array that are greater than 1.</p><pre><code><span class="keyword">let</span> filteredArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].map{ (item) -&gt; <span class="type">Bool</span> <span class="keyword">in
    return</span> item &gt; <span class="number">1</span>
}

</code></pre><ol start="4"><li>Perhaps the hardest to grasp higher order function is Reduce. This function allows us to combine all the elements in a collection, and return a unified common (and also generic) type!</li></ol><pre><code><span class="keyword">func</span> reduce&lt;Result&gt;(<span class="keyword">_</span> initialResult: <span class="type">Result</span>, <span class="keyword">_</span> nextPartialResult: (<span class="type">Result</span>, <span class="type">Bound</span>) <span class="keyword">throws</span> -&gt; <span class="type">Result</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Result</span>
</code></pre><p>Lets say we want to take all of our numbers in an array, and combine them into a single long String.</p><pre><code><span class="comment">// Long version</span>
<span class="keyword">let</span> reduced = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>].<span class="call">reduce</span>(<span class="string">""</span>) {(result, item) -&gt; <span class="type">String</span> <span class="keyword">in 
    return</span> result + <span class="type">String</span>(item)
}
<span class="comment">// Inline version</span>
<span class="keyword">let</span> reduced = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>].<span class="call">reduce</span>(<span class="string">""</span>) { $0 + <span class="type">String</span>($1) }

</code></pre><h3>Leetcode Patterns to look out for</h3>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/home/first-post</guid><title>About myself!</title><description>Why I chose to create a Swift blog.</description><link>https://your-website-url.com/home/first-post</link><pubDate>Fri, 26 Nov 2021 08:33:00 -0500</pubDate><content:encoded><![CDATA[<h1>About myself!</h1><p>Hello everyone! My name is Alex Stevens, and I decided to do what a million other<br> people have already done. Start a Swift blog. I feel\ this will be a good way to advance my iOS domain knowledge, as well as serve as a point of reference for future job interviews. I plan to cover all aspects of iOS Development from Computer Science algorithms, to App Extensions, to SwiftUI/Combine.

I hope everyone joins me in on this journey, and I hope this will be a good resource to any iOS Engineer out there, no matter what part of your journey you are on. From a new grad, or a seasoned engineer looking to crack into the mobile development space, welcome!

--Alex
</p>]]></content:encoded></item></channel></rss>