<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Swift Refresher</title><description>Keeping you up to date on the latest developments in the world of Swift &amp; iOS programming!</description><link>https://swiftrefresher.com</link><language>en</language><lastBuildDate>Fri, 26 Aug 2022 15:17:33 -0400</lastBuildDate><pubDate>Fri, 26 Aug 2022 15:17:33 -0400</pubDate><ttl>250</ttl><atom:link href="https://swiftrefresher.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://swiftrefresher.com/combine/combine-201</guid><title>Combine 201: Diving a little deeper</title><description>Taking our combine knowledge a little further</description><link>https://swiftrefresher.com/combine/combine-201</link><pubDate>Mon, 22 Aug 2022 18:38:00 -0400</pubDate><content:encoded><![CDATA[<h1>Combine 201: Diving a little deeper</h1><p>We got familiar with combine in our <a href="https://swiftrefresher.com/combine/intro-to-combine">Combine 101 Article</a>, so now it is time to further our knowledge a bit with some deeper Combine principles.</p><p>As a refresher, Publishers publish values to objects that subscribe to the data. These objects are called Subscribers. One thing we didn't touch on a lot though, is how simple swift allows our Publisher/Subscriber relationship to be.</p><p>Let's say for example we have a Publisher, and we want to extrapolate, or mutate some data from our publishing stream. We could do something like this:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="n">Just</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="n">publisher</span><span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span> <span class="p">},</span> <span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">values</span> <span class="k">in</span>
    <span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">values</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// check if the number is even, if it is, print it!</span>
            <span class="bp">print</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})</span>
</div></code></pre><p>In the above code, we are printing all even numbers from the array of numbers published by our Publisher. But with the Combine Library, swift makes this much more simple! We can combine (get it ðŸ˜Ž) multiple publishers together as long as they have matching same input &amp; output values. So our above code turns into this:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="n">Just</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="kd">let</span> <span class="nv">output</span> <span class="p">=</span> <span class="n">publisher</span>
    <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="bp">filter</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">==</span> <span class="mi">0</span>  <span class="p">}</span> <span class="p">}</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">})</span>
</div></code></pre><p>When this code is ran we have our same logic. We receive an array of values from the Publisher, filter on them to find the even numbers, and then print the result. In this case we use the map operator on our defined Publisher. This function is called an operator on a Publisher, and these operators can be chained together to make some really cool &amp; clean code. Let's go over a few common operators.</p><h2>Combine Operators</h2><p>So we already went over <strong>.map()</strong> and it works exactly like map does in the Swift foundational library. We use it to map over the list of elements and transform the element as needed. Let's go over some of the most common operators available to us.</p><h3>dropFirst</h3><p>The first common operator we will be covering is <code>dropFirst</code>. Just as its name suggests, it will drop the first value the publisher receives, and will continue publishing all values after that. We can also specify how many preceding values we ignore by passing an integer as a parameter into <code>dropFirst(_)</code></p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">]].</span><span class="n">publisher</span>

<span class="kd">let</span> <span class="nv">output</span> <span class="p">=</span> <span class="n">publisher</span>
    <span class="p">.</span><span class="n">compactMap</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
    <span class="p">.</span><span class="n">flatMap</span><span class="p">({</span> <span class="nv">$0</span><span class="p">.</span><span class="n">publisher</span> <span class="p">})</span>
    <span class="p">.</span><span class="bp">dropFirst</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">})</span>
    
<span class="c1">// 5, 6, 7</span>
</div></code></pre><p>In this example we dropped both 1 &amp; 4 from the stream.</p><h3>compactMap</h3><p>As you can imagine based on it's predecessor, compact map will return a list of non-nil values if we give the publisher a list of Optional values, like an array of [Int?] for example.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="kc">nil</span><span class="p">].</span><span class="n">publisher</span>

<span class="kd">let</span> <span class="nv">output</span> <span class="p">=</span> <span class="n">publisher</span>
    <span class="p">.</span><span class="n">compactMap</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">})</span>

<span class="c1">// 1, 4, 5, 6, 7</span>
</div></code></pre><h3>flatMap</h3><p>flatMap will concatenate all of the nested elements of a sequence into one 'flat' sequence. This works well when dealing with an array of array's.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">]].</span><span class="n">publisher</span>

<span class="kd">let</span> <span class="nv">output</span> <span class="p">=</span> <span class="n">publisher</span>
    <span class="p">.</span><span class="n">compactMap</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
    <span class="p">.</span><span class="n">flatMap</span><span class="p">({</span> <span class="nv">$0</span><span class="p">.</span><span class="n">publisher</span> <span class="p">})</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">})</span>
    
<span class="c1">// 1, 4, 5, 6, 7</span>
</div></code></pre><h3>contains</h3><p>Just like the Swift <strong>contains</strong> function commonly found on sequences, the Combine library sequence will return a published boolean if the value it receives contains a specific value.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">]].</span><span class="n">publisher</span>

<span class="kd">let</span> <span class="nv">output</span> <span class="p">=</span> <span class="n">publisher</span>
    <span class="p">.</span><span class="n">compactMap</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
    <span class="p">.</span><span class="n">flatMap</span><span class="p">({</span> <span class="nv">$0</span><span class="p">.</span><span class="n">publisher</span> <span class="p">})</span>
    <span class="p">.</span><span class="bp">contains</span><span class="p">(</span><span class="k">where</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">==</span> <span class="mi">5</span> <span class="p">})</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">})</span>

<span class="c1">// true</span>
</div></code></pre><p>From our earlier example, our publisher is emitting the 5 value, so our publisher would return true.</p><h3>first</h3><p>Here we pass the closure some predicate to look for in our sequence, and return the first value to satisfy our defined predicate.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">]].</span><span class="n">publisher</span>

<span class="kd">let</span> <span class="nv">output</span> <span class="p">=</span> <span class="n">publisher</span>
    <span class="p">.</span><span class="n">compactMap</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">}</span>
    <span class="p">.</span><span class="n">flatMap</span><span class="p">({</span> <span class="nv">$0</span><span class="p">.</span><span class="n">publisher</span> <span class="p">})</span>
    <span class="p">.</span><span class="bp">first</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">==</span> <span class="mi">5</span> <span class="p">}</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">})</span>
</div></code></pre><p>In this example we look for the first even value, which is 4 in our case.</p><p>There are tons of Publisher operators out there, so our list just touches the tip of the iceberg! I would suggest checking out the Apple documentation for a comprehensive list of available operators. This brings us to our next Combine topic...</p><h2>AnyCancellable's</h2><p>Swift's <strong>Cancellable</strong> type is foundational to how we use combine, and for reactive principles as a whole. Ideally if we have a stream of information being published, there is a chance we will want to cancel this stream of info after a given time.</p><p>Let's start at the bottom. Swift gives us a <code>Cancellable</code> protocol we can conform to, if we want an activity that supports cancellation. The protocol has support for a function called <strong>cancel()</strong> which from Apple: "frees up any allocated resources. It also stops side effects such as timers, network access, or disk I/O.". Ok Cool. We can support a cancellation function, that frees up resources, but what does that mean for us?</p><p>Apple also gives us an <strong>AnyCancellable</strong> type, which is a type-erased, Cancellable conforming, object. This object executes a closure on cancellation. So essentially when we go to create an AnyCancellable, we can initialize it with some work to do, when it finally cancels. From the Apple documentation, "An AnyCancellable instance automatically calls cancel() when deinitialized". So this is interesting, when the object is deallocated from memory, the object will call <strong>cancel()</strong> on itself, and thus the closure we initialized it with. Ok, that makes sense.</p><p>So if we piece this together, we can safely assume the purpose of <strong>AnyCancellable</strong> is to hold a reference to the subscription somewhere other than the subscription itself. If our object we retain the subscription on gets deallocated, our <strong>AnyCancellable</strong> will also get deallocated and thus will call <strong>cancel()</strong> on itself. This will then free up all resources held by the subscription.</p><p>So in summary, when we subscribe to a publisher using a built-in function like <strong>sink</strong> or <strong>assign</strong>, the function returns us an <strong>AnyCancellable</strong>. This <strong>AnyCancellable</strong> type will free up all resources whenever it is deallocated. And we must retain this <strong>AnyCancellable</strong> in our parent object because we do not want our subscriptions to get automatically deallocated whenever we leave the scope of their creation!!</p><p>It might be easier to see in code:</p><pre><code><div class="highlight"><span></span><span class="kd">class</span> <span class="nc">ViewModel</span> <span class="p">{</span>
    <span class="kd">init</span><span class="p">(){}</span>
    
    <span class="kd">func</span> <span class="nf">doSomeWork</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Timer</span>
            <span class="p">.</span><span class="n">publish</span><span class="p">(</span><span class="n">every</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">on</span><span class="p">:</span> <span class="n">RunLoop</span><span class="p">.</span><span class="n">main</span><span class="p">,</span> <span class="k">in</span><span class="p">:</span> <span class="p">.</span><span class="k">default</span><span class="p">)</span>
            <span class="p">.</span><span class="n">autoconnect</span><span class="p">()</span>
            <span class="p">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">date</span> <span class="k">in</span>
                <span class="bp">print</span><span class="p">(</span><span class="n">date</span><span class="p">.</span><span class="n">ISO8601Format</span><span class="p">())</span>
            <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Here we have some view model, in which we want to print the date every 1 second. But when we run this, nothing happens!! This is because of what we talked about earlier. As soon as our <strong>doSomeWork()</strong> scope function ends, our <strong>AnyCancellable</strong> that is returned from sink is deallocated because we did not store it anywhere. One simple change can fix this:</p><pre><code><div class="highlight"><span></span><span class="kd">class</span> <span class="nc">ViewModel</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kd">var</span> <span class="nv">cancellable</span><span class="p">:</span> <span class="n">AnyCancellable</span><span class="p">?</span>
    <span class="kd">init</span><span class="p">(){}</span>
    
    <span class="kd">func</span> <span class="nf">doSomeWork</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">cancellable</span> <span class="p">=</span> <span class="n">Timer</span>
            <span class="p">.</span><span class="n">publish</span><span class="p">(</span><span class="n">every</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">on</span><span class="p">:</span> <span class="n">RunLoop</span><span class="p">.</span><span class="n">main</span><span class="p">,</span> <span class="k">in</span><span class="p">:</span> <span class="p">.</span><span class="k">default</span><span class="p">)</span>
            <span class="p">.</span><span class="n">autoconnect</span><span class="p">()</span>
            <span class="p">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">date</span> <span class="k">in</span>
                <span class="bp">print</span><span class="p">(</span><span class="n">date</span><span class="p">.</span><span class="n">ISO8601Format</span><span class="p">())</span>
            <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>By assigning our cancellable to a property in our view model, as long as our view model stays alive, our subscription does as well! Neat! One last topic in our Combine 201 article...</p><h2>How to debug with Combine</h2><p>Debugging Combine can be very difficult with long stack traces &amp; confusing/ambiguous messages in our console.</p><h3>Print</h3><p>I gave a preview of one way we can debug in the <a href="https://swiftrefresher.com/combine/intro-to-combine">Combine 101 Article</a>, but didn't expand upon it. In the previous article we used <strong>print()</strong> to output in our console. We can just add the print operator to our data stream. and Ta-Da! The console will print out the lifecycle of our publisher like so:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;Cow&quot;</span><span class="p">,</span> <span class="s">&quot;Pig&quot;</span><span class="p">,</span> <span class="s">&quot;Human&quot;</span><span class="p">].</span><span class="n">publisher</span>

<span class="kd">let</span> <span class="nv">_</span> <span class="p">=</span> <span class="n">publisher</span>
    <span class="p">.</span><span class="bp">print</span><span class="p">()</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span> <span class="p">})</span>
 
 
<span class="c1">// console:</span>

<span class="c1">// receive subscription: ([&quot;Cow&quot;, &quot;Pig&quot;, &quot;Human&quot;])</span>
<span class="c1">// request unlimited</span>
<span class="c1">// receive value: (Cow)</span>
<span class="c1">// receive value: (Pig)</span>
<span class="c1">// receive value: (Human)</span>
<span class="c1">// receive finished</span>
</div></code></pre><p>Here we can see we receive a subscription, and our request is unlimited (our stream can theoretically stream an infinite # of values). Then our receiveValue closure is called 3 times, once for each of our array values, and we receive a message for when the stream is finished. This is very helpful in case you want to track down the lifecycle of your subscription and if some values are not being received as expected!</p><h3>HandleEvents</h3><p><strong>handleEvents()</strong> is pretty nice because we can handle every possible event our subscription can give us. It has the same events that were printed for the <strong>print()</strong> operator, except this time we can pass custom closures for each event to handle it our own way if desired. Each of these closures are optional so we can only use specific ones for our use case!</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;Cow&quot;</span><span class="p">,</span> <span class="s">&quot;Pig&quot;</span><span class="p">,</span> <span class="s">&quot;Human&quot;</span><span class="p">].</span><span class="n">publisher</span>

<span class="kd">let</span> <span class="nv">_</span> <span class="p">=</span> <span class="n">publisher</span>
    <span class="p">.</span><span class="n">handleEvents</span><span class="p">(</span><span class="n">receiveSubscription</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="n">subscription</span><span class="p">)</span> <span class="k">in</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Receive subscription </span><span class="si">\(</span><span class="n">subscription</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">},</span> <span class="n">receiveOutput</span><span class="p">:</span> <span class="p">{</span> <span class="n">output</span> <span class="k">in</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Received output: </span><span class="si">\(</span><span class="n">output</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">},</span> <span class="n">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Receive completion </span><span class="si">\(</span><span class="n">completion</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">},</span> <span class="n">receiveCancel</span><span class="p">:</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Receive cancel&quot;</span><span class="p">)</span>
    <span class="p">},</span> <span class="n">receiveRequest</span><span class="p">:</span> <span class="p">{</span> <span class="n">demand</span> <span class="k">in</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Receive request: </span><span class="si">\(</span><span class="n">demand</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">}).</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span> <span class="p">})</span>
    
<span class="c1">// console:</span>

<span class="c1">// Receive subscription [&quot;Cow&quot;, &quot;Pig&quot;, &quot;Human&quot;]</span>
<span class="c1">// Receive request: unlimited</span>
<span class="c1">// Received output: Cow</span>
<span class="c1">// Received output: Pig</span>
<span class="c1">// Received output: Human</span>
<span class="c1">// Receive completion finished</span>
</div></code></pre><h3>Breakpoint</h3><p>Swift went above and beyond with this one! We can trigger a breakpoint as an operator within a combine subscription stream. The closure requires to have a Boolean condition, when if the condition is met, we will trigger a breakpoint.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;Cow&quot;</span><span class="p">,</span> <span class="s">&quot;Pig&quot;</span><span class="p">,</span> <span class="s">&quot;Human&quot;</span><span class="p">].</span><span class="n">publisher</span>

<span class="kd">let</span> <span class="nv">_</span> <span class="p">=</span> <span class="n">publisher</span>
    <span class="p">.</span><span class="n">breakpoint</span><span class="p">(</span><span class="n">receiveOutput</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">==</span> <span class="s">&quot;Pig&quot;</span> <span class="p">})</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span> <span class="p">})</span>
</div></code></pre><p>With this code, when our data stream receives our 2nd value of Pig, Xcode will stop execution for us in the form of a breakpoint. This is because of the closure we passed into the breakpoint operator. This could come in handy!</p><h2>Conclusion</h2><p>We continue to further our skills within Combine. Whether it be how to debug combine errors when we come across them, different operators we can use to manipulate our data stream, and how <strong>AnyCancellable</strong> works under the hood. There is more to learn but we have come a long way!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/leetcode/blind-75-stack</guid><title>Blind 75: Stacks</title><description>A short introduction into Stacks</description><link>https://swiftrefresher.com/leetcode/blind-75-stack</link><pubDate>Tue, 16 Aug 2022 11:02:00 -0400</pubDate><content:encoded><![CDATA[<h1>Intro</h1><p>This will be a very short article, as the Blind 75 list only contains 1 problem revolving around the stack data structure. It is still a good pattern to learn, as there are several stack problems you may encounter, but they all follow the same pattern.</p><p>Stacks are like limited arrays. Stacks are also LIFO (Last-In-First-Out Ordering), such that the last element you push on to it, is the first one that will be removed. You can think of them like Stacks of plates. Stacks feature several functions for the user to interact with, such as: <strong>Pop</strong> <strong>Peek</strong> and <strong>Push</strong>.</p><ul><li><strong>Push</strong> as you would expect pushes a new value on to the stack. Adding at the end on an array is O(1); it always takes the same amount of time, regardless of the size of the array.</li><li><strong>Peek</strong> allows you to view the top most object in the stack, without removing it from the stack entirely.</li><li><strong>Pop</strong> removes the top-most value from the stack, and it is gone forever from the stack.</li></ul><p>The term "Stack Overflow" is based on the Stack data structure. When your CPU continually pushes return addresses onto a stack, but those addresses are never removed, your CPU Stack memory 'overflows' and crashes your application. This can happen in infinite loops when the return address of your function is never removed from memory.</p><h1>Valid Parentheses</h1><p>Here is a very well-known Stack problem. It is a leetcode easy so let's briefly run through it together.</p><img src="https://swiftrefresher.com/validparentheses.png"/><h3>Brute Force</h3><p>Since we know this is a stack problem, let's derive a brute force solution. First off, we need to know whether to push or pop characters on the stack. If know if the character is a closing bracket, we will not be pushing on to the stack. The quickest way to check this in constant time is a HashTable given the consistent lookup they give us.</p><p>So to start, we need a dictionary to search the beginning and ending brackets. Something resembling [")":"(" , "]": "[" , "}": "{"].</p><p>Now we go character by character. If the character is a key in our dictionary, and the value equals that key, we can pop off the stack. If by the end of our traversal we have a non-empty stack we know the string is not valid.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">string</span>
    <span class="k">if</span> <span class="n">top</span> <span class="n">of</span> <span class="n">stack</span> <span class="n">equals</span> <span class="n">the</span> <span class="n">inverse</span> <span class="n">bracket</span> <span class="n">of</span> <span class="n">our</span> <span class="n">letter</span><span class="p">,</span> <span class="n">pop</span> <span class="n">from</span> <span class="n">the</span> <span class="n">stack</span> 
    <span class="k">else</span> <span class="n">push</span> <span class="n">on</span> <span class="n">the</span> <span class="n">stack</span>
    
<span class="k">return</span> <span class="k">if</span> <span class="n">stack</span> <span class="k">is</span> <span class="n">empty</span>
</div></code></pre><p>Time complexity here at worst is O(n), because we need to traverse every letter in the string. Peeking pushing and popping from a stack is O(1) time. Space complexity here is O(1) due to the fixed nature of our hashTable. It does not grow.</p><p>This solution is great and all but there are certain scenarios in which we are doing extra work. Think of the example "()]()", if in the middle of our iteration we encounter a non-balanced character, we know we can return false early. Let's dive deeper into this.</p><h3>[ Enhanced Stack ]</h3><h3>[ O(n) average time + O(1) space ]</h3><p>We need to think when we would find a time to return from the function early.</p><p>First off, we know we should push onto the stack, if we encounter an opening brace. We can explicitly check for that.</p><p>Second off, if we encounter a closing bracket (another explicit check), we should check if the stack is empty. If the stack is empty, we can bail early because there is not an associated opening bracket for our close bracket.</p><p>Pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">string</span>
    <span class="k">if</span> <span class="n">opening</span> <span class="n">bracket</span>
        <span class="n">push</span> <span class="n">on</span> <span class="n">stack</span>
    <span class="k">if</span> <span class="n">closing</span> <span class="n">bracket</span>
        <span class="k">if</span> <span class="n">stack</span> <span class="n">empty</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="k">else</span> 
            <span class="k">if</span> <span class="n">the</span> <span class="n">top</span> <span class="n">of</span> <span class="n">the</span> <span class="n">stack</span> <span class="k">is</span> <span class="n">the</span> <span class="n">inverse</span> <span class="n">of</span> <span class="n">our</span> <span class="n">closing</span> <span class="n">bracket</span>
                <span class="n">pop</span> <span class="n">from</span> <span class="n">stack</span>
            <span class="k">else</span> 
                <span class="k">return</span> <span class="kc">false</span>

<span class="k">return</span> <span class="n">stack</span> <span class="k">is</span> <span class="n">empty</span> <span class="n">or</span> <span class="n">not</span>
</div></code></pre><p>This keeps the same time complexity &amp; space complexity from earlier, but it just saves us some work in specific input cases. Here is the final solution:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">stack</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Character</span><span class="p">]()</span>
<span class="kd">var</span> <span class="nv">hash</span><span class="p">:</span> <span class="p">[</span><span class="nb">Character</span><span class="p">:</span><span class="nb">Character</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;)&quot;</span><span class="p">:</span><span class="s">&quot;(&quot;</span><span class="p">,</span> <span class="s">&quot;}&quot;</span><span class="p">:</span><span class="s">&quot;{&quot;</span><span class="p">,</span><span class="s">&quot;]&quot;</span><span class="p">:</span><span class="s">&quot;[&quot;</span><span class="p">]</span>

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">letter</span> <span class="p">==</span> <span class="s">&quot;(&quot;</span> <span class="o">||</span> <span class="n">letter</span> <span class="p">==</span> <span class="s">&quot;{&quot;</span> <span class="o">||</span> <span class="n">letter</span> <span class="p">==</span> <span class="s">&quot;[&quot;</span> <span class="p">{</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">letter</span> <span class="p">==</span> <span class="s">&quot;)&quot;</span> <span class="o">||</span> <span class="n">letter</span> <span class="p">==</span> <span class="s">&quot;}&quot;</span> <span class="o">||</span> <span class="n">letter</span> <span class="p">==</span> <span class="s">&quot;]&quot;</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="n">stack</span><span class="p">.</span><span class="bp">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stack</span><span class="p">.</span><span class="bp">last</span><span class="p">!</span> <span class="p">==</span> <span class="n">hash</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">popLast</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">stack</span><span class="p">.</span><span class="bp">count</span> <span class="p">==</span> <span class="mi">0</span>
</div></code></pre><p>Cheers! On to the next section.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/leetcode/blind-75-sliding-window</guid><title>Blind 75: Sliding Window Problems</title><description>Getting crazy with arrays!</description><link>https://swiftrefresher.com/leetcode/blind-75-sliding-window</link><pubDate>Tue, 19 Jul 2022 18:02:00 -0400</pubDate><content:encoded><![CDATA[<h1>Best Time to Buy and Sell Stock</h1><p>This is a good strategy for iterating on array problems. Let's build the foundation!</p><img src="https://swiftrefresher.com/besttimebuysellstock.png"/><p>This is a very straightforward problem with real world application. Lets take it step by step.</p><h3>Brute Force</h3><p>A brute force solution here is obvious, let's go through each element in the array, and iterate every combination of elements to find the maximum profit.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">currentMaxProfit</span> <span class="o">&gt;</span> <span class="bp">max</span> <span class="n">profit</span> <span class="n">AND</span> <span class="n">currentMaxProfit</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="bp">max</span> <span class="n">profit</span> <span class="p">=</span> <span class="n">currentMaxProfit</span>
            
<span class="k">return</span> <span class="bp">max</span> <span class="n">profit</span> 
</div></code></pre><p>This is a very inefficient solution, with the time constraint being O(nÂ²). We at least have consistent space because we only hold a variable for the max profit. There is a better way of going about this problem though.<br><br>For this problem, we should approach using the sliding window methodology.</p><h3>[ Sliding Window ]</h3><h3>[ O(n) worst time + O(1) space ]</h3><p>The sliding window is when we have 2 pointers representing a window range, and we either move the start of the window, or expand the window based on the criteria we are looking for. In this specific problem, we have 2 criteria:</p><ol><li>Move the first index (start of the window) when the end of the window is greater than the beginning of the window. In this scenario our profit would be negative so we need to reset our search.</li><li>Expand our window when we have the criteria for a possible max profit.</li></ol><p>Pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">while</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">the</span> <span class="n">window</span> <span class="k">is</span> <span class="n">within</span> <span class="n">the</span> <span class="n">bounds</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>
    <span class="k">if</span> <span class="n">we</span> <span class="n">can</span> <span class="n">have</span> <span class="n">a</span> <span class="bp">max</span> <span class="n">profit</span>
        <span class="n">maxProfit</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="bp">max</span> <span class="n">profit</span><span class="p">,</span> <span class="n">current</span> <span class="n">profit</span><span class="p">)</span>
    <span class="k">else</span> 
        <span class="n">reset</span> <span class="n">beginning</span> <span class="n">of</span> <span class="n">window</span>
    <span class="n">end</span> <span class="n">of</span> <span class="n">window</span> <span class="n">append</span> <span class="n">by</span> <span class="mi">1</span>
</div></code></pre><p>At worst here we get, O(n) time performance. This is if we cannot have a viable maximum profit in the entire array. Space is still consistent, due to the various array pointers.</p><p>Let's go into implementation now.</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for cases we cannot create a window.</span>
<span class="k">guard</span> <span class="n">prices</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nv">maxProf</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// start max profit at zero</span>
<span class="kd">var</span> <span class="nv">start</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// beginning of window pointer</span>
<span class="kd">var</span> <span class="nv">end</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// end of window pointer</span>

<span class="k">while</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span> <span class="c1">// while the end of the window is within the bounds of the array</span>
    <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// if the first number is less than second and we have a possible profit</span>
        <span class="n">maxProf</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">maxProf</span><span class="p">,</span> <span class="n">prices</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">start</span><span class="p">])</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">start</span> <span class="p">=</span> <span class="n">end</span> <span class="c1">// reset window</span>
    <span class="p">}</span>
    <span class="n">end</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// move end of window always</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">maxProf</span>
</div></code></pre><p>Beautiful. This will be instrumental in future problems.</p><hr><h1>Longest Substring Without Repeating Characters</h1><p>Time to turn the heat on a little bit! This sliding window is a little different than before.</p><img src="https://swiftrefresher.com/longestsubstringwithoutrepeatchars.png"/><h3>Brute Force</h3><p>As with most array problems, if we use some nested loops to find our condition, we will arrive at the answer (albeit with extreme inefficiency).</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">we</span> <span class="n">have</span> <span class="n">not</span> <span class="n">seen</span> <span class="n">inner</span> <span class="n">letter</span> <span class="n">yet</span> <span class="k">in</span> <span class="n">this</span> <span class="n">iteration</span>
            <span class="n">add</span> <span class="n">to</span> <span class="n">our</span> <span class="n">iterative</span> <span class="bp">count</span>
            <span class="n">update</span> <span class="n">longest</span> <span class="k">if</span> <span class="n">possible</span>
        <span class="k">else</span>
            <span class="k">break</span>
            
<span class="k">return</span> <span class="n">longest</span> <span class="n">substring</span> <span class="n">char</span> <span class="bp">count</span> 
</div></code></pre><p>This solution is built on us keeping track of our current longest substring at any given iteration in the array. If we add to our current iterative substring count, we need to update our global variable as well. The condition for us to reset our search is if we find a character we have seen before.</p><p>Time complexity is O(nÂ³) due to our nested loops and substring checking. Depending on our preferred method of searching for past letters, if we use a hash table, this search is consistent O(1). Space complexity is O(n) because we need a data structure that expands for the letters we have previously seen. HashTable space complexity is O(n) where n is the number of unique characters (at worst).</p><h3>[ Sliding Window ]</h3><h3>[ O(nÂ²) worst time + O(n) space ]</h3><p>You guessed it! We have another sliding window problem. This time we need to be really careful with our 2 window conditions. Our 2 conditions are: expanding our window or reset the front of our window. The question is, what causes these conditions AND how specifically do we reset &amp; expand our window.</p><p>In our case, we know we need to expand our window when we have not seen a letter before (this includes the front of our window). To expand we can just move the end of our window by 1.</p><p>Otherwise we reset our window. BUT resetting our window only means we move the front by one. We need to ensure we do not skip any letter combinations.</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">a</span> <span class="n">hashtable</span> <span class="n">with</span> <span class="n">seen</span> <span class="n">letters</span>

<span class="k">while</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">our</span> <span class="n">window</span> <span class="k">is</span> <span class="k">in</span> <span class="n">bounds</span>
    <span class="k">if</span> <span class="n">we</span> <span class="n">have</span> <span class="n">not</span> <span class="n">seen</span> <span class="n">the</span> <span class="n">end</span> <span class="n">letter</span> <span class="n">before</span>
        <span class="c1">// expand</span>
        <span class="n">move</span> <span class="n">end</span> <span class="n">variable</span>
        <span class="n">update</span> <span class="n">global</span> <span class="n">variable</span>
        <span class="n">update</span> <span class="n">hashtable</span>
    <span class="k">else</span>
        <span class="c1">// reset window</span>
        <span class="n">move</span> <span class="n">start</span> <span class="n">of</span> <span class="n">window</span> <span class="mi">1</span> <span class="n">place</span>
        <span class="n">move</span> <span class="n">end</span> <span class="n">to</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">reset</span> <span class="n">hashtable</span>
        
<span class="k">return</span> <span class="n">global</span> <span class="n">variable</span>
        
</div></code></pre><p>Time complexity here is O(nÂ²) at worst. This occurs when we have all unique characters in our string. Our loop will essentially check every combination of substrings in this case. Space complexity is O(n) due to the expansion of the hashtable. N is representative of unique characters in our string.</p><p>Time to implement!</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span> <span class="c1">// edge case check</span>
<span class="kd">var</span> <span class="nv">longest</span> <span class="p">=</span> <span class="mi">1</span>
<span class="kd">var</span> <span class="nv">start</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// window start</span>
<span class="kd">var</span> <span class="nv">end</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// window end</span>

<span class="kd">let</span> <span class="nv">letters</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1">// swift optimization</span>

<span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="n">letters</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="p">:</span> <span class="kc">true</span><span class="p">]</span> <span class="c1">// HashTable with 1st letter </span>

<span class="k">while</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span> <span class="p">{</span> <span class="c1">// While in bounds</span>
    <span class="kd">let</span> <span class="nv">startLetter</span> <span class="p">=</span> <span class="n">letters</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="kd">let</span> <span class="nv">endLetter</span> <span class="p">=</span> <span class="n">letters</span><span class="p">[</span><span class="n">end</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// expand window</span>
        <span class="n">end</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">longest</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">longest</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="c1">// update longest if possible</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span> <span class="c1">// add to hashTable</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// reset window start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// move start</span>
        <span class="n">end</span> <span class="p">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// reset end</span>
        <span class="n">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="n">letters</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="p">:</span> <span class="kc">true</span><span class="p">]</span> <span class="c1">// reset hash</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">longest</span>
</div></code></pre><p>Well done!</p><hr><h1>Longest Repeating Character Replacement</h1><p>This is a particularly unique sliding window problem. I personally struggled with this one. Let's dive in.</p><img src="https://swiftrefresher.com/longestrepeatingcharacterreplacement.png"/><h3>Brute Force</h3><p>There are a couple factors at play here. First off, we can check every substring available in the input string by using nested for loops. But as we check each substring what exactly are we looking for? In a given substring, we need to see if the number of letters we need to replace is less than our input K. And we know we need to replace all characters that are not equal to the most frequent character in a given substring.</p><p>Let's say for example we have a substring "ABAA" and K=2. We know that A is the most frequent letter, so every instance of a letter that isn't A needs replaced. So we can search the substring for all non-A letters and as long as that number is less than or equal to K, its a valid substring. It would look something like this</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">every</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">S</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">remaining</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">S</span>
        <span class="bp">find</span> <span class="bp">count</span> <span class="n">of</span> <span class="n">most</span> <span class="n">frequent</span> <span class="n">character</span>
        <span class="bp">count</span> <span class="n">of</span> <span class="n">everything</span> <span class="k">else</span> <span class="p">=</span> <span class="n">substring</span> <span class="n">length</span> <span class="o">-</span> <span class="n">most</span> <span class="n">frequent</span> 
        <span class="k">if</span> <span class="bp">count</span> <span class="n">of</span> <span class="n">everything</span> <span class="k">else</span> <span class="o">&lt;=</span> <span class="n">K</span>
            <span class="k">continue</span> <span class="n">inner</span> <span class="n">loop</span>
        <span class="k">else</span> 
            <span class="k">break</span> <span class="n">inner</span> <span class="n">loop</span>
</div></code></pre><p>Pretty darn inefficient right? Let's dive into time and space complexity here. The nested loops alone give us O(nÂ²) time. Within our loops, finding the count of the most frequent letter is another search through our substring is another O(n) time. Total this gives us O(nÂ³). Yikes. The space complexity is at worst O(n) where n is the length of the S input string. This is because we can never have to search a substring longer than the input string.</p><h3>[ Sliding Window + HashTable ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>So for efficiency sake here, we can speed a few things up. First off the searching a substring can be expedited with a HashTable. We can keep track of the counts for any given substring at all times, and have consistent time searching for each character count. We can also keep a global variable representing the most frequent character count.</p><p>For the nested loops, we can use a sliding window instead to massively decrease our algorithm time. If we have a valid substring, we can keep expanding our window to the right. If we do not have a valid substring, we need to shrink our window from the left (Move the start pointer forward). Here is the pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">string</span>
    <span class="n">add</span> <span class="n">to</span> <span class="n">hashTable</span>
    <span class="n">update</span> <span class="n">global</span> <span class="bp">max</span> <span class="n">character</span> <span class="n">frequency</span> <span class="n">value</span>
    
    <span class="k">while</span> <span class="n">our</span> <span class="n">substring</span> <span class="k">is</span> <span class="n">invalid</span>
        <span class="n">shrink</span> <span class="n">window</span> <span class="n">from</span> <span class="n">the</span> <span class="n">start</span>
        <span class="n">update</span> <span class="n">HashTable</span> <span class="n">accordingly</span>
        
    <span class="n">update</span> <span class="n">global</span> <span class="n">variable</span> <span class="k">for</span> <span class="n">our</span> <span class="n">result</span>
    
<span class="k">return</span> <span class="n">global</span>
</div></code></pre><p>With this solution, we have at worst O(n) time where n is the length of the input string. This is because the worst that can happen, is we expand our window all the way to the right, have the last letter make the substring invalid, and then shrink our window to the end. This averages out to be O(n) time. Space complexity is O(26N) because we know we are only using capital english letters, there are only 26 of those, so our HashTable storage will never be bigger than 26 Keys. This averages out to O(n) space.</p><p>Let's implement the real solution.</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">charCount</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Character</span><span class="p">:</span> <span class="nb">Int</span><span class="p">]()</span> <span class="c1">// HashTable to keep track of character counts in our substring</span>
<span class="kd">var</span> <span class="nv">maxCharCount</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// Max Character Count, largest in our HashTable at any given moment</span>
<span class="kd">var</span> <span class="nv">result</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// Our return result</span>
<span class="kd">var</span> <span class="nv">start</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// Start of window pointer</span>

<span class="kd">let</span> <span class="nv">sArr</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1">// Easy Char access in Swift</span>

<span class="k">for</span> <span class="n">end</span> <span class="k">in</span> <span class="mi">0</span> <span class="p">..</span><span class="o">&lt;</span> <span class="n">sArr</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span> <span class="c1">// while our end pointer is in bounds</span>
    <span class="kd">var</span> <span class="nv">currentWindowSize</span> <span class="p">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// get our current window size</span>
    <span class="kd">let</span> <span class="nv">endLetter</span> <span class="p">=</span> <span class="n">sArr</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="c1">// end letter</span>
    <span class="kd">var</span> <span class="nv">startLetter</span> <span class="p">=</span> <span class="n">sArr</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="c1">// start letter</span>
    
    <span class="n">charCount</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="p">=</span> <span class="n">charCount</span><span class="p">[</span><span class="n">endLetter</span><span class="p">,</span> <span class="k">default</span><span class="p">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// We have a new end letter, increment its count in the HashTable</span>
    <span class="n">maxCharCount</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">maxCharCount</span><span class="p">,</span> <span class="n">charCount</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span><span class="o">!</span><span class="p">)</span> <span class="c1">// See if the newly added letter, ups the maximum char count in the substring</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">currentWindowSize</span> <span class="o">-</span> <span class="n">maxCharCount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">k</span> <span class="p">{</span> <span class="c1">// If our substring is invalid (Our # of chars we need to change is bigger than we are allowed (K)  )</span>
        <span class="n">charCount</span><span class="p">[</span><span class="n">startLetter</span><span class="p">]</span> <span class="p">=</span> <span class="n">charCount</span><span class="p">[</span><span class="n">startLetter</span><span class="p">]</span><span class="o">!</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// Decrement the start of our window count, as we are shrinking our window</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// Shrink our window forward because string is invalid</span>
        
        <span class="n">currentWindowSize</span> <span class="p">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// Update window size</span>
        <span class="n">startLetter</span> <span class="p">=</span> <span class="n">sArr</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="c1">// Update Start Letter</span>
    <span class="p">}</span>
    <span class="n">result</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">currentWindowSize</span><span class="p">)</span> <span class="c1">// update our global result for the longest substring</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">result</span>
</div></code></pre><p>Sheesh!</p><hr><h1>Minimum Window Substring</h1><p>Ahhh our first Leetcode Hard. No need to fear!</p><img src="https://swiftrefresher.com/minimumwindowsubstring.png"/><h3>Brute Force</h3><p>So this is definitely a tricky one. It takes some in-depth thinking to even arrive at a brute force solution.</p><p>The idea behind the brute force solution is to keep 2 hash tables. One hash table containing character counts we need for our substring to be considered 'valid', and one hash table containing the character counts of our current sliding window substring. In our example problem where s = "ADOBECODEBANC", and t = "ABC", we know we will have a hash table representing the characters we need, and that hash table will be ['A': 1, 'B': 1, 'C': 1]. When we start our hash table for the character count in our substring will be ['A': 0, 'B': 0, 'C': 0], as we have not seen any of these letters yet.</p><p>Now we slide our window. What makes a substring valid? Well that is if: for every key in our haveHashTable, the character count is â‰¥ the corresponding letter count in the needHashTable. For example, in our starting substring of 'A'...our haveHashTable will be ['A': 1, 'B': 0, 'C': 0], but we know that its not a valid substring because the character counts for both 'B' and 'C' are â‰¤ the 'B' and 'C' counts in our needHashTable (the count for each of these is 1). We will continue to slide our window until our substring is valid. What happens when our substring is valid?</p><p>If we have a valid substring, we need to globally record the length, and update our result. Then we will pop from the start of our window, until our substring is no longer valid. The repeated work here, is every time we want to check if a substring is valid, we need to loop through every key in our haveHashTable. Gross!</p><p>It would look something like this:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">S</span>
    <span class="k">if</span> <span class="n">its</span> <span class="n">a</span> <span class="n">character</span> <span class="n">we</span> <span class="n">need</span><span class="p">,</span> <span class="n">update</span> <span class="n">haveHashTable</span>
    
    <span class="k">while</span> <span class="n">substring</span> <span class="k">is</span> <span class="n">valid</span>
        <span class="n">update</span> <span class="n">global</span> <span class="n">minimum</span> <span class="n">variable</span> <span class="k">as</span> <span class="n">applicable</span>
        <span class="n">pop</span> <span class="n">from</span> <span class="n">front</span> <span class="n">of</span> <span class="n">window</span> <span class="p">(</span><span class="n">update</span> <span class="n">haveHashTable</span><span class="p">,</span> <span class="n">and</span> <span class="n">move</span> <span class="n">the</span> <span class="n">start</span> <span class="n">of</span> <span class="n">the</span> <span class="n">window</span> <span class="mi">1</span> <span class="n">place</span> <span class="n">to</span> <span class="n">the</span> <span class="kr">right</span><span class="p">)</span>
        
<span class="k">return</span> <span class="n">minimum</span>
</div></code></pre><p>We know that we have O(n) time by searching through the entire string S, and if we need to go all the way forward, and then pop the front all the way to the back, that still averages out to O(n). We have O(26n) time for seeing if our substring is valid, which on average comes out to O(n) time. This comes out to be O(nÂ²) at worst. Space complexity here is O(2n) because we need 2 hashTables that can be at most 26 Keys long, and on average O(2n) comes out to be O(n) space.</p><p>How can we make this better?</p><h3>[ Sliding Window + HashTables + Global Character Count Variables ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>The idea here is, we know we have repeated work by checking if a substring is valid. So we can tweak our logic a little bit to make this linear time. Let's keep two variables: One for the number of characters we have (the sum of all keys in haveHashTable) and one for the number of characters we need (the sum of all keys in needHashTable). If numberOfCharactersWeHave == numberOfCharactersWeNeed, then we know our substring is valid. For example in the substring 'ADOBEC', our needHashTable will be ['A': 1, 'B': 1, 'C': 1], and our haveHashTable will be ['A': 1, 'B': 1, 'C': 1]. The sum of all values for both of these hashTables = 3. Since 3 == 3, we know our substring is valid.</p><p>BUT, we need to be careful here. We should only update our numberOfCharactersWeHave if we slide the window into a character we actually need, and if the character count for what we have == its count for what we need. Also, when we pop from the start of our window, we should only decrement numberOfCharactersWeHave if the letter is something we need, and the substring is no longer valid (its count for what we have is less than its count for what we need). By doing these 2 things we satisfy our condition from the brute force solution.</p><p>In the brute force solution, we only have a valid substring if the character count in haveHashTable â‰¥ the corresponding letter count in the needHashTable. So with our new logic, we only decrement the character count if the count falls below our needHashTable threshold. Conversely, we only increment if our character counts are equal.</p><p>In pseudocode it looks like this:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">S</span>
    <span class="k">if</span> <span class="n">its</span> <span class="n">a</span> <span class="n">character</span> <span class="n">we</span> <span class="n">need</span><span class="p">,</span> <span class="n">update</span> <span class="n">haveHashTable</span>
    <span class="n">update</span> <span class="n">our</span> <span class="n">numberOfCharactersWeHave</span> <span class="n">only</span> <span class="k">if</span> <span class="n">the</span> <span class="n">end</span> <span class="n">letter</span> <span class="k">is</span> <span class="n">something</span> <span class="n">we</span> <span class="n">need</span> <span class="o">&amp;&amp;</span> <span class="n">its</span> <span class="bp">count</span> <span class="k">for</span> <span class="n">what</span> <span class="n">we</span> <span class="n">have</span> <span class="n">equals</span> <span class="n">its</span> <span class="bp">count</span> <span class="k">for</span> <span class="n">what</span> <span class="n">we</span> <span class="n">need</span>
    
    <span class="k">while</span> <span class="n">numberOfCharactersWeHave</span> <span class="n">equals</span> <span class="n">numberOfCharactersWeNeed</span>
        <span class="n">update</span> <span class="n">global</span> <span class="n">minimum</span> <span class="n">variable</span> <span class="k">as</span> <span class="n">applicable</span>
        <span class="n">pop</span> <span class="n">from</span> <span class="kr">left</span> <span class="n">of</span> <span class="n">window</span> <span class="p">(</span> <span class="k">if</span> <span class="n">the</span> <span class="n">character</span> <span class="k">is</span> <span class="k">in</span> <span class="n">our</span> <span class="n">haveHashTable</span> <span class="n">update</span> <span class="n">it</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">the</span> <span class="n">start</span> <span class="n">letter</span> <span class="k">is</span> <span class="n">something</span> <span class="n">we</span> <span class="n">need</span><span class="p">,</span> <span class="n">and</span> <span class="n">the</span> <span class="n">substring</span> <span class="k">is</span> <span class="n">no</span> <span class="n">longer</span> <span class="n">valid</span> <span class="p">(</span><span class="n">its</span> <span class="bp">count</span> <span class="k">for</span> <span class="n">what</span> <span class="n">we</span> <span class="n">have</span> <span class="o">&lt;</span> <span class="n">its</span> <span class="bp">count</span> <span class="k">for</span> <span class="n">what</span> <span class="n">we</span> <span class="n">need</span><span class="p">)</span> <span class="n">decrement</span> <span class="n">numberOfCharactersWeHave</span>
        <span class="n">move</span> <span class="n">start</span> <span class="n">pointer</span> <span class="n">by</span> <span class="mi">1</span>
        
<span class="k">return</span> <span class="n">minimum</span>
</div></code></pre><p>The time complexity here is now liner. We still traverse the string S, but checking if a substring is valid is a consistent operation. We are only checking 2 variables. This means we now have O(n) time. The space complexity still remains O(n) due to the 2 hash tables to store character counts. Let's implement the real thing (and apologies for the extra code and comments, I wanted to make it as clear as possible).</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">inputS</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1">// for easier swift access</span>
<span class="kd">let</span> <span class="nv">inputT</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1">// for easier swift access</span>

<span class="kd">var</span> <span class="nv">haveHash</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Character</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span>
<span class="kd">var</span> <span class="nv">needHash</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Character</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span>

<span class="kd">var</span> <span class="nv">slidingWindowStart</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">var</span> <span class="nv">globalMinSubstringLength</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">.</span><span class="bp">max</span>
<span class="kd">var</span> <span class="nv">globalMinSubstring</span> <span class="p">=</span> <span class="s">&quot;&quot;</span>

<span class="kd">var</span> <span class="nv">numberOfCharactersWeHave</span> <span class="p">=</span> <span class="mi">0</span>

<span class="c1">// set up our hashTable for letters we need</span>
<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">inputS</span> <span class="p">{</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span> <span class="p">}</span>
<span class="c1">// set up our hashTable for letters we need</span>
<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">inputT</span> <span class="p">{</span> <span class="n">needHash</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">=</span> <span class="n">needHash</span><span class="p">[</span><span class="n">letter</span><span class="p">,</span> <span class="k">default</span><span class="p">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nv">numberOfCharactersWeNeed</span> <span class="p">=</span> <span class="n">needHash</span><span class="p">.</span><span class="bp">count</span>

<span class="k">for</span> <span class="p">(</span><span class="n">endLetterIndex</span><span class="p">,</span> <span class="n">endLetter</span><span class="p">)</span> <span class="k">in</span> <span class="n">inputS</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// update haveHash if applicable</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">endLetterCountInHaveHash</span> <span class="p">=</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="p">{</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="p">=</span> <span class="n">endLetterCountInHaveHash</span> <span class="o">+</span> <span class="mi">1</span>  <span class="p">}</span>
    <span class="c1">// see if our have character count can be appended. </span>
    <span class="c1">// that is, the end letter is something we need &amp;&amp; its count for what we have == its count for what we need</span>
    <span class="k">if</span> <span class="n">needHash</span><span class="p">[</span><span class="n">endLetter</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">needHashCount</span> <span class="p">=</span> <span class="n">needHash</span><span class="p">[</span><span class="n">endLetter</span><span class="p">],</span> <span class="kd">let</span> <span class="nv">haveHashCount</span> <span class="p">=</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">endLetter</span><span class="p">],</span> <span class="n">needHashCount</span> <span class="p">==</span> <span class="n">haveHashCount</span> <span class="p">{</span>
        <span class="n">numberOfCharactersWeHave</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="c1">// while we have all the characters we need (the substring is valid)</span>
    <span class="k">while</span> <span class="n">numberOfCharactersWeHave</span> <span class="p">==</span> <span class="n">numberOfCharactersWeNeed</span> <span class="p">{</span>
        <span class="c1">// get length of current substring</span>
        <span class="kd">let</span> <span class="nv">lengthOfCurrentSubstring</span> <span class="p">=</span> <span class="p">(</span><span class="n">endLetterIndex</span> <span class="o">-</span> <span class="n">slidingWindowStart</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1">// update global minimum substring if possible</span>
        <span class="k">if</span> <span class="n">lengthOfCurrentSubstring</span> <span class="o">&lt;</span> <span class="n">globalMinSubstringLength</span> <span class="p">{</span>
            <span class="n">globalMinSubstring</span> <span class="p">=</span> <span class="nb">String</span><span class="p">(</span><span class="n">inputS</span><span class="p">[</span><span class="n">slidingWindowStart</span><span class="p">...</span><span class="n">endLetterIndex</span><span class="p">])</span>
            <span class="n">globalMinSubstringLength</span> <span class="p">=</span> <span class="n">lengthOfCurrentSubstring</span>
        <span class="p">}</span>
        
        <span class="kd">let</span> <span class="nv">startLetter</span> <span class="p">=</span> <span class="n">inputS</span><span class="p">[</span><span class="n">slidingWindowStart</span><span class="p">]</span>
        <span class="c1">// pop from left of window if the character is in our have hash</span>
        <span class="k">if</span> <span class="kd">let</span> <span class="nv">haveHashStartLetterCount</span> <span class="p">=</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">startLetter</span><span class="p">]</span> <span class="p">{</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">startLetter</span><span class="p">]</span> <span class="p">=</span> <span class="n">haveHashStartLetterCount</span> <span class="o">-</span> <span class="mi">1</span>  <span class="p">}</span>
        <span class="c1">// if the start letter is something we need, and the substring is no longer valid (its count for what we have &lt; its count for what we need) update our numberOfCharactersWeHave</span>
        <span class="k">if</span> <span class="kd">let</span> <span class="nv">needHashStartLetterCount</span> <span class="p">=</span> <span class="n">needHash</span><span class="p">[</span><span class="n">startLetter</span><span class="p">],</span> <span class="kd">let</span> <span class="nv">haveHashStartLetterCount</span> <span class="p">=</span> <span class="n">haveHash</span><span class="p">[</span><span class="n">startLetter</span><span class="p">],</span> <span class="n">haveHashStartLetterCount</span> <span class="o">&lt;</span> <span class="n">needHashStartLetterCount</span> <span class="p">{</span> <span class="n">numberOfCharactersWeHave</span> <span class="o">-=</span> <span class="mi">1</span> <span class="p">}</span>
        <span class="c1">// move left window pointer</span>
        <span class="n">slidingWindowStart</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">globalMinSubstring</span>
</div></code></pre><hr><h1>Conclusion</h1><p>Sliding window problems can come in all shapes and sizes. Keep an eye out when you see the word 'Substring' in a problem, as it may well mean its a sliding window problem! Once you get the pattern of them down, they are easy-peasy.</p><hr>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/combine/intro-to-combine</guid><title>Combine 101: Introduction</title><description>Getting into some reactive programming</description><link>https://swiftrefresher.com/combine/intro-to-combine</link><pubDate>Tue, 21 Jun 2022 21:27:00 -0400</pubDate><content:encoded><![CDATA[<h1>Combine 101: Introduction</h1><p>If you have been around in the Swift world for a long time, or you are new to iOS development, odds are you have heard of the Combine framework. The combine framework was introduced by Apple at WWDC19, and was Apple's native answer to RxSwift, ReactiveSwift or any other functional reactive programming frameworks you may have heard of/used before.</p><h3>So what is it?</h3><p>Combine is a first party, <em>declarative</em> framework for asynchronous processing values (streams of data) over time. Instead of having multiple callbacks, completion handlers, or delegations, you can create a singular processing chain for your stream of data.</p><p>The key part here is the framework is declarative, meaning you describe what the program does &amp; not the flow of control. This is compared to imperative styles of programming where our code is how the program works &amp; implementing tasks to mutate some state. <em>Combine</em> is has functional reactive principles as well. This means our program reacts to each stream of data, and is based in functions with a set input &amp; set output. As you will see in some code examples, Combine is both declarative, functional and reactive because our data flows from one function to another, with each function having a defined input and output.</p><p>We can think of Combine having 3 main players: Publishers, Subscribers, and Operators. Let's get familiar with each one!</p><h2>Publishers</h2><p>The Publisher type, is a protocol defined in Swift. Swift Publishers are used to transmit sequences of values over time. You can think of this as a man shouting information from a rooftop at intermittent periods of time. He is a publisher.<br><br>Publishers have 2 associatedtypes representing the Output of the Publisher, and how the Publisher will fail. We can define each of these. Also the Publisher protocol has a <code>receive(subscriber:)</code> function hook a subscriber up to itself. Per the contract for the this function, a publisherâ€™s output must match subscriberâ€™s input, and so should the failure types.</p><p>Most Swift foundation objects/functions support built in publishers as of 2022. For example, NotificationCenter &amp; NSTimer:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">notificationPublisher</span> <span class="p">=</span> <span class="n">NotificationCenter</span><span class="p">.</span><span class="n">Publisher</span><span class="p">(</span><span class="n">center</span><span class="p">:</span> <span class="p">.</span><span class="k">default</span><span class="p">,</span> 
                                                         <span class="n">name</span><span class="p">:</span> <span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="s">&quot;Test&quot;</span><span class="p">),</span> 
                                                         <span class="n">object</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">timerPublisher</span> <span class="p">=</span> <span class="n">Timer</span><span class="p">.</span><span class="n">TimerPublisher</span><span class="p">(</span><span class="n">interval</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> 
                                          <span class="n">runLoop</span><span class="p">:</span> <span class="n">RunLoop</span><span class="p">.</span><span class="n">main</span><span class="p">,</span> 
                                          <span class="n">mode</span><span class="p">:</span> <span class="p">.</span><span class="k">default</span><span class="p">)</span>
</div></code></pre><p>We have created these objects and now they can stream and emit values over time, we can also react to these values however we wish.</p><p>As opposed to creating our own objects that implement the Publisher protocol, Apple suggests we use one of their built-in types whenever we need a custom publisher. We can either:</p><ol><li>Use a concrete subclass of <code>Subject</code> like <code>PassThroughSubject</code> for example, to manually send values</li><li>Use a <code>CurrentValueSubject</code></li><li>Add the <code>@Published</code> annotation wrapper to a property we wish</li></ol><h3>What are Subjects?</h3><p>A subject is a type of Publisher that exposes functions, in order for outside callers to Publish events into the stream of data. Swift gives us 2 built-in Subjects for free. These are namely <em>CurrentValueSubject</em> and <em>PassThroughSubject</em>.</p><p>A <em>CurrentValueSubject</em> starts with an initial value, and publishes every time that value changes. We can also access the inner value with this type of Subject.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">subject</span> <span class="p">=</span> <span class="n">CurrentValueSubject</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">,</span> <span class="n">Never</span><span class="p">&gt;(</span><span class="s">&quot;Test&quot;</span><span class="p">)</span> <span class="c1">// initial value of Test</span>

<span class="bp">print</span><span class="p">(</span><span class="n">subject</span><span class="p">.</span><span class="n">value</span><span class="p">)</span> <span class="c1">// prints &#39;Test&#39;</span>

<span class="n">subject</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">&quot;Blog&quot;</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">subject</span><span class="p">.</span><span class="n">value</span><span class="p">)</span> <span class="c1">// prints &#39;Blog&#39;</span>
</div></code></pre><p>A <em>PassThroughSubject</em> does not have an initial value, but broadcasts data downstream. This type also drops values if there are no subscribers, or the current demand is zero. We are unable to access any values within this object.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">subject</span> <span class="p">=</span> <span class="n">PassthroughSubject</span><span class="p">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="n">Never</span><span class="p">&gt;()</span> <span class="c1">// no initial value</span>

<span class="c1">// subscribe to events</span>
<span class="n">subject</span><span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;finished&quot;</span><span class="p">)</span>
<span class="p">},</span> <span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="p">})</span>

<span class="n">subject</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">&quot;Alex&quot;</span><span class="p">)</span>
<span class="n">subject</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">&quot;is Blogging!&quot;</span><span class="p">)</span> 
<span class="n">subject</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">completion</span><span class="p">:</span> <span class="p">.</span><span class="n">finished</span><span class="p">)</span> <span class="c1">// done!</span>
<span class="c1">// Alex</span>
<span class="c1">// is Blogging!</span>
<span class="c1">// finished</span>
</div></code></pre><h3>@Published property wrapper</h3><p>Swift allows us to add a publisher to any property by using the <em>@Published</em> property wrapper. You can access the inner publisher by using the <code>$</code> symbol in front of your property. It is important to note the @Published property wrapper is class-constrained, we cannot use them in structs. Let's see a code example (Note, we will learn about AnyCancellable soon!)</p><pre><code><div class="highlight"><span></span><span class="kr">final</span> <span class="kd">class</span> <span class="nc">FooClass</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kd">var</span> <span class="nv">subscriber</span><span class="p">:</span> <span class="n">AnyCancellable</span><span class="p">?</span>
    <span class="p">@</span><span class="n">Published</span> <span class="kd">var</span> <span class="nv">isOn</span><span class="p">:</span> <span class="nb">Bool</span> <span class="p">=</span> <span class="kc">false</span> <span class="c1">// published</span>
    
    <span class="kd">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// this will print false, then true</span>
        <span class="n">subscriber</span> <span class="p">=</span> <span class="err">$</span><span class="n">isOn</span>
            <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
                <span class="bp">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="p">})</span>
       <span class="n">change</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="kd">func</span> <span class="nf">change</span><span class="p">()</span> <span class="p">{</span>
       <span class="n">isOn</span><span class="p">.</span><span class="n">toggle</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Also worth noting, the publishing will happen in the object's willSet block, so anyone downstream will get the new value before it is set.</p><h2>Subscribers</h2><p>Up until now we have been referring to those listening to publishers as "Downstream". But they have a formal name, and that name is <em>Subscriber</em>. A Subscriber listens to events sent from a Publisher. A subscriber can receive either an input value, or a completion value with some indicator of a success/failure.</p><p>Swift gives us 2 built in Subscribers: <em>Subscribers.Sink</em> &amp; <em>Subscribers.Assign</em>.</p><p><em>Subscribers.Sink</em> is a simple Subscriber class that requests an unlimited amount of values upon its subscription.</p><p><em>Subscribers.Assign</em> assigns received elements to a property indicated by a key path.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">publisher</span> <span class="p">=</span> <span class="n">Just</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>

<span class="n">publisher</span><span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="kc">_</span> <span class="k">in</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;finished&quot;</span><span class="p">)</span>
<span class="p">},</span> <span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="p">})</span>

<span class="c1">// false</span>
<span class="c1">// finished</span>
</div></code></pre><h2>Publisher + Subscriber Lifecycle</h2><p>Let's explore what happens under the hood when we build a subscription between a publisher &amp; subscriber</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">subject</span> <span class="p">=</span> <span class="n">PassthroughSubject</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">,</span> <span class="n">Never</span><span class="p">&gt;()</span>

<span class="kd">let</span> <span class="nv">token</span> <span class="p">=</span> <span class="n">subject</span>
    <span class="p">.</span><span class="bp">print</span><span class="p">()</span>
    <span class="p">.</span><span class="n">sink</span><span class="p">(</span><span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="s">&quot;received by subscriber: </span><span class="si">\(</span><span class="nv">$0</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span> <span class="p">})</span>

<span class="n">subject</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">// receive subscription: (PassthroughSubject) [Subscriber connects to a publisher] [Publisher creates a subscription] [Publisher acknowledges subscription request]</span>
<span class="c1">// request unlimited [Subscriber requests number of elements it want to receive] [Our Demand is currently unlimited]</span>
<span class="c1">// receive value: (1) [The Publisher sends values by calling receive(_:) on the subscriber]</span>
<span class="c1">// received by subscriber: 1 [Returns how many items are expected to be received] [Subscriber can only increase or leave demand the same]</span>
<span class="c1">// receive cancel [Subscription either ends in a cancel, successful finish, or fail with an error]</span>
</div></code></pre><h1>Conclusion</h1><p>This concludes our intro into combine! Hope you learned a good foundation for our next few articles!</p><h4>Helpful links:</h4><p><a href="https://developer.apple.com/videos/play/wwdc2019/722/">WWDC19 Intro video</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/leetcode/blind-75-arrays</guid><title>Blind 75: Arrays + Hashing + 2 pointers</title><description>Arrays + Leetcode = Match made in heaven</description><link>https://swiftrefresher.com/leetcode/blind-75-arrays</link><pubDate>Wed, 16 Mar 2022 21:02:00 -0400</pubDate><content:encoded><![CDATA[<h1>TwoSum</h1><p>This is a classic introductory problem &amp; it is a good place for us to start our leetcode journey. Read over the problem statement below.</p><img src="https://swiftrefresher.com/twosum.png"/><p>Pretty straightforward right? Let's take this step by step and make sure we understand the solution. We need the indices of 2 numbers that add up to a target. We can assume there is one answer, and we may not use the same element twice. Easy enough.</p><h3>Brute Force</h3><p>A brute force solution here is pretty obvious, let's go through each element in the array, and iterate over every other element, to see if we add up to a target. This is a common brute force method for most array problems. This will give us a O(nÂ²) time &amp; O(1) spacial solution. Let's write some pseudocode for this solution and test it. While testing, make sure to capture edge cases!</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">+</span> <span class="n">other</span> <span class="n">number</span> <span class="p">=</span> <span class="n">target</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">number</span> <span class="n">index</span><span class="p">,</span> <span class="n">other</span> <span class="n">number</span> <span class="n">index</span><span class="p">]</span>
</div></code></pre><p>It is time to consider some bottlenecks, and think how we can optimize our solution. Firstly, if you notice some nested for loops in your code, that is a code smell. Think how those can be optimized. In our case if we try to pass thru the array only once, while also sequentially finding the solution, we heavily optimize our solution.</p><h3>Approach 1</h3><h3>[ Sort + 2 pointer ]</h3><h3>[ O(nLog(n)) time + O(n) space ]</h3><p>For this specific problem we know we want 2 numbers that add up to a target. That is, X + Y = Z. If we have X, we know that we are searching for Z - Y. If we sort our array, we can make this search much faster.</p><p>Back to our above example, we have an array of [4, 2, 1, 3] and we need a target of 3. If we first sort the array, we can use 2 pointers to incrementally get closer to our target number. By sorting our array is [1, 2, 3, 4]. We have a left pointer at the beginning of the array and a right pointer at the end of the array. Let's add these numbers up. 1 + 4 = 5, which is greater than our target of 3. The sum is greater than our target, so let's move the right pointer inward. Now our pointers are targeted at 1, and 3. 1 + 3 = 4, a summation that is still greater than our target. So we move the right pointer inward once more. This makes our pointers at 1 and 2, and if we add those up we find our target.</p><p>Pseudocode:</p><pre><code><div class="highlight"><span></span><span class="bp">sort</span> <span class="n">array</span>
<span class="k">while</span> <span class="kr">left</span> <span class="n">pointer</span> <span class="o">&lt;</span> <span class="kr">right</span> <span class="n">pointer</span>
    <span class="n">add</span> <span class="n">up</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">pointers</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="p">=</span> <span class="n">target</span>
        <span class="k">return</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">pointer</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span>
        <span class="n">move</span> <span class="kr">right</span> <span class="n">pointer</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span>
        <span class="n">move</span> <span class="kr">left</span> <span class="n">pointer</span>
</div></code></pre><p>There are some considerations here. By sorting we can get, on average, O(nLog(n)) time performance. So by sorting and then searching our array we are looking at O(nLog(n)) + O(n) time complexity. Which comes out to be O(nLog(n)). This is a pretty significant time vs space tradeoff and this should be discussed with your interviewer.<br><br>Let's go into implementation now.</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for empty array + single element in array.</span>
<span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]()</span> <span class="p">}</span>

<span class="kd">let</span> <span class="nv">sorted</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">sorted</span><span class="p">()</span>
<span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">var</span> <span class="nv">rightPointer</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span>

<span class="c1">// Search our array</span>
<span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;</span> <span class="n">rightPointer</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">sum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="o">+</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="p">{</span>
        <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="p">{</span>
        <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">break</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Because the swift index(of:) function returns us an &#39;Array&lt;Int&gt;.Index?&#39; </span>
<span class="c1">// we need to manually get the integer Index value by doing one more loop.</span>
<span class="kd">let</span> <span class="nv">leftNum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">rightNum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span>

<span class="kd">var</span> <span class="nv">returnValue</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]()</span>

<span class="c1">// Beautiful swift! Reads just like english :) </span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="k">where</span> <span class="p">(</span><span class="n">num</span> <span class="p">==</span> <span class="n">leftNum</span> <span class="o">||</span> <span class="n">num</span> <span class="p">==</span> <span class="n">rightNum</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">returnValue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">returnValue</span>
</div></code></pre><p>Ta-Da! This is one passing solution to solve the 2 sum problem. This methodology will be the preferred method of solving in 3sum, 4sum and etc problems.</p><h3>Approach 2</h3><h3>[ Hash Table ]</h3><h3>[ O(n) time + space ]</h3><p>By using some auxiliary data structure for storage you can easily look up past calculations for your use case. In our case, we should try to optimize our O(nÂ²) time solution into a O(n) time solution. For array problems this is the mecca. This brings us to our introduction of hash tables/dictionary's. We can have constant lookup in swift dictionaries.</p><p>In our case let's consider we loop through the array 1 time, and in a hash table, we store the key as the element of our array and the value as the index of each value. So our original array of [4, 2, 1, 3] turns into a dictionary of [4: 0, 2: 1, 1: 2, 3: 3]. Now in our problem, we can go through our array 1 time, and at each element we can see if the inverse of the target exists. Namely it comes down to this pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">add</span> <span class="n">to</span> <span class="n">dictionary</span><span class="p">.</span> <span class="p">[</span><span class="n">number</span><span class="p">:</span> <span class="n">index</span> <span class="n">of</span> <span class="n">number</span><span class="p">]</span>
    
<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">inverse</span> <span class="p">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">number</span>
    <span class="k">if</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">inverse</span><span class="p">]</span> <span class="n">exists</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">number</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">inverse</span><span class="p">]]</span>
</div></code></pre><p>After testing, we see this is a lot more efficient, and it works! We gave up some constant space in order for time efficiency, but these tradeoffs are things you can discuss with your interviewer. Now let's code our final solution. Don't forget to cover those edge cases, and to practice safe optional unwrapping!</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for empty array + single element in array.</span>
<span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[]</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span>
<span class="c1">// Create our hashtable mapping</span>
<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">hashTable</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="n">index</span>
<span class="p">}</span>
<span class="c1">// Now search our array for the inverse!</span>
<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">inverse</span> <span class="p">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">element</span>
    <span class="c1">// we should not be using the same element within itself. Make sure to read the problem carefully!</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">existingInverse</span> <span class="p">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">inverse</span><span class="p">],</span> <span class="n">unwrappedInverse</span> <span class="o">!=</span> <span class="n">index</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">existingInverse</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="p">[]</span> <span class="c1">// we have no solution. </span>
</div></code></pre><p>Nice work!</p><hr><h1>ThreeSum</h1><p>This problem builds off of our previous problem, with a little more complexity. Check out the problem statement below.</p><img src="https://swiftrefresher.com/threesum.png"/><p>If we remember one of the solutions for the TwoSum problem, when we sort the array then use 2 pointers to find our target it leads to decently efficient code.</p><h3>Brute Force</h3><p>With most array problems, the brute force solution is straightforward. By using nested loops, we can iterate on all possible answer combinations until we find the solution(s) we want. In this case, this is an O(nÂ³) solution. With all of our "sum" problems we can represent the brute force as a O(nË£) where x = the number 'sum' the problem is asking for.</p><p>Pseudocode:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">secondNumber</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">for</span> <span class="n">thirdNumber</span> <span class="k">in</span> <span class="n">array</span>
            <span class="k">if</span> <span class="n">number</span> <span class="o">+</span> <span class="n">secondNumber</span> <span class="o">+</span> <span class="n">thirdNumber</span> <span class="p">=</span> <span class="mi">0</span> <span class="n">AND</span> <span class="n">we</span> <span class="n">have</span> <span class="n">not</span> <span class="n">added</span> <span class="n">this</span> <span class="n">answer</span> <span class="n">combination</span> <span class="n">before</span>
                <span class="n">add</span> <span class="n">these</span> <span class="n">numbers</span> <span class="n">to</span> <span class="n">our</span> <span class="k">return</span> <span class="n">value</span>
</div></code></pre><p>Obviously the nested nature of these arrays should be avoided. So let's take a step back and iterate on our approach from the TwoSum problem.</p><h3>Approach</h3><h3>[ Sort + 2 pointer ]</h3><h3>[ O(nÂ²) time + O(n) space ]</h3><p>We know we need to add up to a target of 0, with 3 different numbers. In formulaic terms, we have X + Y + Z = 0. For each element in our array, we have one of the elements in our equation. So we are left with -Z = X + Y, where Z is our element in the array.</p><p>By sorting our array at the beginning of our function, we can reuse our TwoSum logic. Add up X + Y. If that sum is less than our target (-Z) we need to increase our sum &amp; vice versa. Since our array is sorted, and we can represent X and Y as leftPointer's and rightPointer's in our array, it is easy to increase and decrease our sum as needed. Namely we can do something similar to this.</p><pre><code><div class="highlight"><span></span><span class="bp">sort</span> <span class="n">array</span>
<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="bp">sorted</span> <span class="n">array</span>
    <span class="bp">find</span> <span class="n">the</span> <span class="n">targetNumber</span>
    <span class="bp">find</span> <span class="n">the</span> <span class="n">leftPointer</span>
    <span class="bp">find</span> <span class="n">the</span> <span class="n">rightPointer</span>
    
    <span class="k">while</span> <span class="n">leftPointer</span> <span class="n">less</span> <span class="n">than</span> <span class="n">rightPointer</span>
        <span class="n">sum</span> <span class="p">=</span> <span class="n">leftPointer</span> <span class="o">+</span> <span class="n">rightPointer</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="k">is</span> <span class="n">less</span> <span class="n">than</span> <span class="n">target</span>
            <span class="n">move</span> <span class="n">leftPointer</span> <span class="n">inward</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="k">is</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">target</span>
            <span class="n">move</span> <span class="n">rightPointer</span> <span class="n">inward</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="n">equals</span> <span class="n">target</span> <span class="n">AND</span> <span class="n">not</span> <span class="n">duplicated</span>
            <span class="n">we</span> <span class="n">have</span> <span class="n">our</span> <span class="n">combination</span><span class="p">!</span>
            <span class="n">add</span> <span class="n">to</span> <span class="n">answer</span>
            <span class="n">move</span> <span class="n">both</span> <span class="n">leftPointer</span> <span class="n">and</span> <span class="n">rightPointer</span> <span class="n">inward</span>
</div></code></pre><p>Some time + space considerations here. By sorting we have O(nLog(n)) and then searching every element in the array gives us O(nLog(n)) + O(nÂ²). Since O(nÂ²) is much greater than O(nLog(n)), the O(nLog(n)) cancels out and does not need to be considered in the final time complexity calculations, so the final time complexity is O(nÂ²) time where n is the length of our input array. For space, we need to keep track of the answer in an array, so the space complexity is O(n) where n is the length of the answer.</p><p>Let's implement the real answer.</p><pre><code><div class="highlight"><span></span><span class="c1">// edge case for empty array + single element + only 2 elements in array.</span>
<span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[[</span><span class="nb">Int</span><span class="p">]]()</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nv">returnVal</span> <span class="p">=</span> <span class="p">[[</span><span class="nb">Int</span><span class="p">]]()</span>
<span class="kd">let</span> <span class="nv">sorted</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="bp">sorted</span><span class="p">()</span>

<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="bp">sorted</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">target</span> <span class="p">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">element</span>
    <span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="kd">var</span> <span class="nv">rightPointer</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="c1">// search for our target, within bounds</span>
    <span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;</span> <span class="n">rightPointer</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">sum</span> <span class="p">=</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="o">+</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span> <span class="p">{</span>
            <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// Sum is too small, increase our sum</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="p">{</span>
            <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1">// Sum is too big, decrease our sum</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">sum</span> <span class="p">==</span> <span class="n">target</span> <span class="p">{</span>
            <span class="c1">// We found an answer!</span>
            <span class="kd">let</span> <span class="nv">correctAns</span> <span class="p">=</span> <span class="p">[</span><span class="n">element</span><span class="p">,</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">],</span> <span class="bp">sorted</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]]</span>
            <span class="c1">// Preemptively move our pointers inward </span>
            <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="n">returnVal</span><span class="p">.</span><span class="bp">contains</span><span class="p">(</span><span class="n">correctAns</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// add to our answer</span>
                <span class="n">returnVal</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">correctAns</span><span class="p">)</span>
            <span class="p">}</span> 
        <span class="p">}</span>  
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">returnVal</span>
</div></code></pre><p>Boom! Nicely done.</p><hr><h1>Contains Duplicates</h1><p>This is a pretty straightforward problem, but builds our foundational knowledge when it comes to HashTables! Find the problem statement below.</p><img src="https://swiftrefresher.com/containsduplicates.png"/><p>Very easy problem to grasp. Now let's try to find ourselves a brute force solution, and optimize it.</p><h3>Brute Force</h3><p>A very easy brute force solution, leads us to an O(nÂ²) time complexity solution with O(1) space. This would be to go by each element in the array, and have a nested loop to see if our outer element is found within our inner loop. Like so:</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">number</span> <span class="n">equals</span> <span class="n">other</span> <span class="n">number</span> <span class="n">we</span> <span class="n">have</span> <span class="n">found</span> <span class="n">a</span> <span class="n">duplicate</span><span class="p">.</span>
</div></code></pre><p>By introducing a HashTable into the problem, we know that HashTable's have constant lookup, but at worst, they take up O(n) space where N = length of the input array. Also since HashTable's have unique keys, we will be able to store all of the elements in our array just once.</p><h3>Approach</h3><h3>[ HashTable + Consistent Lookup ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>We can initialize a HashTable at the beginning of our problem, where the key of the HashTable is the same type of element in our input array, in this case Integer. As we loop through our array, we can check if the HashTable already contains a key-element pair that matches Integer at each iteration of the loop. If the key-element pair exists, we can break out of the loop, and return true for our function. If the key-element pair does not exist, we can add it to the HashTable.</p><pre><code><div class="highlight"><span></span><span class="n">Create</span> <span class="n">HashTable</span> <span class="n">with</span> <span class="n">key</span> <span class="n">of</span> <span class="n">Integer</span> <span class="n">and</span> <span class="n">element</span> <span class="n">of</span> <span class="n">whatever</span> <span class="n">you</span> <span class="n">would</span> <span class="n">like</span> 

<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">if</span> <span class="n">element</span> <span class="n">exists</span> <span class="n">with</span> <span class="n">number</span> <span class="k">as</span> <span class="n">the</span> <span class="n">key</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="k">else</span>
        <span class="n">add</span> <span class="n">to</span> <span class="n">the</span> <span class="n">HashTable</span>
</div></code></pre><p>Pretty simple right! Like I mentioned above, the time and space are both O(n). This is why HashTables are so powerful, is because they give us consistent lookup time when we need some auxiliary storage in our problems. Now it is time to implement the real solution.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span> <span class="c1">// edge-case check against small or empty inputs</span>

<span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span> <span class="c1">// i opted for an Int:Int pair, but you could have easily done Int:Bool, etc. </span>
        
<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// loop our input array</span>
    <span class="k">if</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span> <span class="c1">// We have found a duplicate!</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="n">index</span> <span class="c1">// Add element to HashTable</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="kc">false</span> <span class="c1">// No duplicates here...</span>
</div></code></pre><p>Easy-Peasy.</p><hr><h1>Product Of Array Except Self</h1><p>This problem is our first introduction on how to traverse an array both forwards and backwards! Let's dive in.</p><img src="https://swiftrefresher.com/productexceptself.png"/><p>We need to come up with a brute force solution to start, and like every other array problem, we can nest iterations in order to get every possible combination in the array.</p><h3>Brute Force</h3><p>We can start at each point in a given array and calculate every other arrays product, and add it to a return value. This leads us to a O(nÂ²) time complexity and an O(n) spatial complexity because we need to store the length of the return array in our function. This is O(nÂ²) time due to the nested nature of our iterations within the array.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">iterate</span> <span class="n">through</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">array</span>
        <span class="n">calculate</span> <span class="n">the</span> <span class="n">product</span>
    <span class="n">add</span> <span class="n">product</span> <span class="n">to</span> <span class="k">return</span> <span class="n">value</span> 
</div></code></pre><h3>Approach</h3><h3>[ Forward + Backward Iteration ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>We can optimize this problem by filling in our return array only twice. We can loop forward through our auxiliary return array once, keep a running product at each iteration, and use the running product to fill our return value array. Then we can reset our running product count, and iterate our array backwards to keep a running count of all the values minus itself.</p><p>The thinking here is, as we iterate our array we can fill in our return value in place. On the first loop, returnArray[i] will contain proceeding product of nums[i] (exclusive). After the second loop, each returnArray[i] is updated by multiplying to succeeding product of nums[i].</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">running</span> <span class="bp">count</span> <span class="n">starting</span> <span class="n">at</span> <span class="mi">1</span>
<span class="n">create</span> <span class="k">return</span> <span class="n">array</span> <span class="n">of</span> <span class="n">all</span> <span class="mi">1</span><span class="err">&#39;</span><span class="n">s</span>

<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span> <span class="n">forward</span> <span class="n">direction</span>
    <span class="n">update</span> <span class="k">return</span> <span class="n">array</span> <span class="n">with</span> <span class="n">running</span> <span class="bp">count</span>
    <span class="n">update</span> <span class="n">running</span> <span class="bp">count</span> <span class="n">by</span> <span class="n">multiplying</span> <span class="n">number</span> <span class="n">to</span> <span class="n">existing</span> <span class="bp">count</span> 
    
<span class="n">reset</span> <span class="n">running</span> <span class="bp">count</span>

<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span> <span class="n">backwards</span> <span class="n">direction</span>
    <span class="n">update</span> <span class="k">return</span> <span class="n">array</span> <span class="n">by</span> <span class="n">multiplying</span> <span class="n">running</span> <span class="bp">count</span> <span class="n">by</span> <span class="n">number</span> <span class="k">in</span> <span class="n">input</span> <span class="n">array</span>
    <span class="n">update</span> <span class="n">running</span> <span class="bp">count</span> <span class="n">by</span> <span class="n">multiplying</span> <span class="n">number</span> <span class="n">to</span> <span class="n">existing</span> <span class="bp">count</span>
    
<span class="k">return</span>
</div></code></pre><p>This gives us an O(n) time solution since we only have to iterate twice, namely forward and backwards. O(2n) = O(n) on average. Space is still consistently O(n). Now let's implement the real solution.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[]</span> <span class="p">}</span> <span class="c1">// guard against edge cases</span>
<span class="kd">var</span> <span class="nv">auxArray</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">repeating</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">count</span><span class="p">:</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span><span class="p">)</span> <span class="c1">// create a return array of all 1&#39;s</span>
<span class="kd">var</span> <span class="nv">runningCount</span> <span class="p">=</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.&lt;</span><span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span> <span class="c1">// forward iteration</span>
    <span class="n">auxArray</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">runningCount</span>
    <span class="n">runningCount</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="c1">// update running count of product</span>
<span class="p">}</span>

<span class="n">runningCount</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// reset the running count</span>

<span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="bp">stride</span><span class="p">(</span><span class="n">from</span><span class="p">:</span> <span class="n">nums</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">through</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">by</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// backward iteration</span>
    <span class="n">auxArray</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">*=</span> <span class="n">runningCount</span>
    <span class="n">runningCount</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="c1">// update running count of product</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">auxArray</span>
</div></code></pre><p>Good Job!</p><hr><h1>Valid Anagram</h1><p>This problem expands our knowledge on array best practices! Let's tackle it.</p><img src="https://swiftrefresher.com/validanagram.png"/><h3>Brute Force</h3><p>Let's start by thinking of a brute force solution. My brute force solution I came up with involved a little different of an approach as opposed to other array problems. Nesting arrays in this problem isn't quite where my head first went. Initially I thought it would be easiest to sort both input strings, and then go letter by letter to compare the two strings. When we find a deviation between the two, we do not have a valid anagram.</p><pre><code><div class="highlight"><span></span><span class="bp">sort</span> <span class="n">string</span> <span class="n">s</span>
<span class="bp">sort</span> <span class="n">string</span> <span class="n">t</span>

<span class="n">make</span> <span class="n">sure</span> <span class="n">they</span> <span class="n">are</span> <span class="n">the</span> <span class="n">same</span> <span class="n">length</span> 

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">s</span> <span class="n">or</span> <span class="n">t</span> <span class="n">length</span>
    <span class="k">if</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">s</span> <span class="n">does</span> <span class="n">not</span> <span class="bp">equal</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">t</span>
        <span class="k">return</span> <span class="kc">false</span>
        
<span class="k">if</span> <span class="n">we</span> <span class="kr">get</span> <span class="n">here</span><span class="p">,</span> <span class="n">we</span> <span class="n">have</span> <span class="n">a</span> <span class="n">valid</span> <span class="n">anagram</span>
</div></code></pre><p>Looping the strings is not the issue here. Sorting 2 different strings, and then looping is not very optimal. By sorting we can get, on average, O(nLog(n)) time performance. Make that sorting twice plus looping the strings we are looking at O(2nLog(n)) + O(n) time complexity. We can simplify this to O(3nLog(n)) -&gt; O(nLog(n)) time, with O(1) consistent space complexity.</p><p>We know we can do better though. It may be worth giving up our consistent space complexity to get a better time complexity.</p><h3>Approach</h3><h3>[ HashTable with letter occurrences ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>We can introduce our arrays best friend! A hash table. We can store the occurrences of each letter in our hashTable. Utilizing a hash table here gives us consistent O(1) lookup when we need to know how many times we have seen a character. We have 2 strings, for one string we can increase the number of occurrences, for another string we can decrease the number of occurrences. In a perfect world, our hash table should have values of all 0's if it is a valid anagram.</p><pre><code><div class="highlight"><span></span><span class="n">check</span> <span class="n">string</span> <span class="n">lengths</span> <span class="n">are</span> <span class="bp">equal</span>
<span class="n">create</span> <span class="n">hash</span> <span class="n">table</span>

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">s</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span> <span class="bp">contains</span> <span class="n">this</span> <span class="n">letter</span> <span class="n">already</span>
        <span class="n">increment</span> <span class="n">its</span> <span class="n">occurrence</span> <span class="n">number</span> <span class="n">by</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span> <span class="n">does</span> <span class="n">not</span> <span class="n">contain</span> <span class="n">this</span> <span class="n">letter</span>
        <span class="n">add</span> <span class="n">it</span> <span class="n">to</span> <span class="n">the</span> <span class="n">hash</span> <span class="n">table</span> <span class="n">with</span> <span class="n">an</span> <span class="n">occurrence</span> <span class="n">of</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">t</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span> <span class="bp">contains</span> <span class="n">this</span> <span class="n">letter</span> <span class="n">already</span>
        <span class="n">decrement</span> <span class="n">its</span> <span class="n">occurrence</span> <span class="n">number</span> <span class="n">by</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span> <span class="n">does</span> <span class="n">not</span> <span class="n">contain</span> <span class="n">this</span> <span class="n">letter</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="n">we</span> <span class="n">have</span> <span class="n">found</span> <span class="n">a</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">t</span> <span class="n">that</span> <span class="n">s</span> <span class="n">does</span> <span class="n">not</span> <span class="n">have</span>
        
<span class="k">for</span> <span class="n">values</span> <span class="k">in</span> <span class="n">our</span> <span class="n">hash</span> <span class="n">table</span>
    <span class="k">if</span> <span class="n">our</span> <span class="n">value</span> <span class="k">is</span> <span class="n">not</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">false</span>

<span class="k">return</span> <span class="kc">true</span>
</div></code></pre><p>This solution contains 3 loops. This equates to O(3n) â†’ O(n) on average time complexity. Our space complexity is O(n) where n is the number of unique characters in s and t. This can also be represented as O(max(s.length, t.length)) at worst case. It's time to bring it all together:</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">s</span><span class="p">.</span><span class="bp">count</span> <span class="p">==</span> <span class="n">t</span><span class="p">.</span><span class="bp">count</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span> <span class="c1">// edge case where our string lengths may not be equal</span>
<span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Character</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span>

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">s</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">existing</span> <span class="p">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">=</span> <span class="n">existing</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// if we have already seen this character, append its count by 1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// we have not seen this character yet, add to hash table</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">letter</span> <span class="k">in</span> <span class="n">t</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">existing</span> <span class="p">=</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">hashTable</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="p">=</span> <span class="n">existing</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// decrement the character occurrence by 1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span> <span class="c1">// t contains a letter s does not have. not a valid anagram</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">hashTable</span><span class="p">.</span><span class="n">values</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span> <span class="c1">// we have found a letter where s contains more occurrences than t, and vice versa</span>
<span class="p">}</span>
<span class="k">return</span> <span class="kc">true</span> <span class="c1">// valid!</span>
</div></code></pre><p>Nice!</p><hr><h1>Valid Palindrome</h1><p>Similar to our problem with Anagrams, this problem is a play on a string, but can easily be thought of as an array problem. One thing to note about this problem is PAY ATTENTION! The little details on some of these leetcode problems can kill you. Notice we should ignore non alphanumeric characters + ignore spaces. Also notice how we should be treating all alphanumerics as lowercased.</p><img src="https://swiftrefresher.com/validpalindrome.png"/><h3>Brute Force</h3><p>As always we start with a Brute Force solution and optimize. Here we can think of the string as an array of characters. Initially we can consider the option of nested arrays with a pointer. We start at the first letter, traverse to the last letter, and make sure they match. Then go to the 2nd letter, traverse to the 2nd to last letter and see if they match. We can do this for all letters nums[x]...nums[length-x] until we meet in the middle.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">alphanumeric</span> <span class="n">character</span> <span class="k">in</span> <span class="n">string</span> 
    <span class="n">traverse</span> <span class="n">to</span> <span class="n">length</span> <span class="o">-</span> <span class="n">x</span> <span class="n">letter</span> <span class="n">of</span> <span class="n">the</span> <span class="n">string</span><span class="p">,</span> <span class="n">that</span> <span class="k">is</span> <span class="n">alphanumeric</span>
        <span class="k">if</span> <span class="n">letters</span> <span class="n">are</span> <span class="n">the</span> <span class="n">same</span>
            <span class="k">continue</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="kc">false</span>
</div></code></pre><p>The bottleneck within this problem is the inner traversal of the string to get to the length - x character in the string. Our brute force solution is on average O(nÂ²) time complexity, with a consistent O(1) spatial complexity. We do not keep any extra storage so we do not take up any extra space. Depending how we check if numbers are alphanumeric, our time complexity may be even slower than O(nÂ²).</p><h3>Approach</h3><h3>[ 2 pointers ]</h3><h3>[ O(n) time + O(1) space ]</h3><p>We can utilize the 2 pointer method, commonly found in arrays for this problem. If we take our string, and put a pointer at the beginning and end of the string, we can move our 2 pointers closer together until they meet in the middle, with O(1/2n) time complexity -&gt; which averages out to O(n).</p><p>We should also take considerations on how to check if a character is alphanumeric. We could create an array of letters and an array of numbers, and check if those array's contain our character. By doing this we introduce poor time complexity into our code. Say our string contains multiple Z's. We would need to traverse the entire alphabet array to see if the character is a letter. A more efficient solution would be to utilize properties on the Swift Standard Library. The Character object comes with built in "isLetter" and "isNumber" properties. Under the hood Swift compares the ASCII encoding value of your character to different ranges of letters and numbers, to ensure it is alphanumeric. This is a much more efficient solution than the array of letters approach.</p><pre><code><div class="highlight"><span></span><span class="n">create</span> <span class="kr">left</span> <span class="n">pointer</span>
<span class="n">create</span> <span class="kr">right</span> <span class="n">pointer</span>
<span class="n">create</span> <span class="n">array</span> <span class="n">of</span> <span class="n">lowercased</span> <span class="n">letters</span> <span class="c1">// O(n)</span>

<span class="k">while</span> <span class="kr">left</span> <span class="n">pointer</span> <span class="o">&lt;=</span> <span class="kr">right</span> <span class="n">pointer</span> <span class="c1">// O(1/2n) at worst</span>
    <span class="n">make</span> <span class="n">sure</span> <span class="kr">left</span> <span class="n">pointer</span> <span class="k">is</span> <span class="n">alphanumeric</span>
        <span class="k">if</span> <span class="n">not</span><span class="p">,</span> <span class="k">continue</span> <span class="n">thru</span> <span class="n">the</span> <span class="n">loop</span>
    <span class="n">make</span> <span class="n">sure</span> <span class="kr">right</span> <span class="n">pointer</span> <span class="k">is</span> <span class="n">alphanumeric</span>
        <span class="k">if</span> <span class="n">not</span><span class="p">,</span> <span class="k">continue</span> <span class="n">thru</span> <span class="n">the</span> <span class="n">loop</span>
    <span class="k">if</span> <span class="kr">left</span> <span class="n">pointer</span> <span class="n">does</span> <span class="n">not</span> <span class="bp">equal</span> <span class="kr">right</span> <span class="n">pointer</span>
        <span class="k">return</span> <span class="kc">false</span>
    
    <span class="n">move</span> <span class="kr">left</span> <span class="n">and</span> <span class="kr">right</span> <span class="n">pointers</span> <span class="n">inward</span> <span class="k">in</span> <span class="n">the</span> <span class="n">array</span>
</div></code></pre><p>We do not necessarily have to convert our string into an array of lowercased letters. I chose to do this because of the difficulty of indexing a string in swift. To index a certain letter in a string, you cannot just subscript like: str[9]. You must use the built in String.Index type. So for proper, clean code you may implement something like this:</p><pre><code><div class="highlight"><span></span><span class="kd">extension</span> <span class="nc">StringProtocol</span> <span class="p">{</span>
    <span class="kd">subscript</span><span class="p">(</span><span class="n">offset</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Character</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="n">offset</span><span class="p">)]</span>
    <span class="p">}</span>
<span class="p">}</span>
</div></code></pre><p>Given the short amount of time in a leetcode interview, I tend to stay away, and just convert to an array when possible. Make sure to weigh trade-offs with your interviewer though! If keep the structure as the original string, we would just have to convert the letters to lowercase on each comparison.</p><p>Let's implement our O(n) time, and O(1) space solution.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">s</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">}</span> <span class="c1">// guard against edge cases</span>
             
<span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rightPointer</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// create our pointers</span>
<span class="kd">var</span> <span class="nv">arr</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">lowercased</span><span class="p">())</span> <span class="c1">// convert to an array</span>

<span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;=</span> <span class="n">rightPointer</span> <span class="p">{</span> <span class="c1">// loop until our pointers meet in the middle</span>
    <span class="k">guard</span> <span class="n">arr</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">].</span><span class="n">isLetter</span> <span class="o">||</span> <span class="n">arr</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">].</span><span class="n">isNumber</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// make sure left is alphanumeric</span>
        <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// if not, move left pointer inward and continue the loop</span>
        <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">guard</span> <span class="n">arr</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">].</span><span class="n">isLetter</span> <span class="o">||</span> <span class="n">arr</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">].</span><span class="n">isNumber</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// make sure right is alphanumeric</span>
        <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1">// if not, move the right pointer inward and continue the loop</span>
        <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span> <span class="o">!=</span> <span class="n">arr</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// if our letters are not equal, return false</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
                
    <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// move left inward</span>
    <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1">// move right inward</span>
<span class="p">}</span>
<span class="k">return</span> <span class="kc">true</span>
</div></code></pre><p>Great Job! and remember, keep an eye out for the little details in a problem description.</p><hr><h1>Group Anagrams</h1><p>This next problem expands our previous knowledge around what makes an anagram valid. Now let's use this base knowledge to group similar sets of anagrams!</p><img src="https://swiftrefresher.com/groupanagrams.png"/><h3>Brute Force</h3><p>The brute force solution for this problem is pretty straight forward. We can use nested For Loops to find all the anagram groups for a given element, group similar ones, and return the groups in a nested return array.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">word</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">start</span> <span class="n">an</span> <span class="n">anagram</span> <span class="n">group</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">every</span> <span class="n">other</span> <span class="n">word</span> <span class="k">in</span> <span class="n">the</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">outer</span> <span class="n">and</span> <span class="n">inner</span> <span class="n">word</span> <span class="n">are</span> <span class="n">valid</span> <span class="n">anagrams</span> <span class="n">of</span> <span class="n">each</span> <span class="n">other</span> <span class="o">&amp;</span> <span class="n">not</span> <span class="k">in</span> <span class="n">anagram</span> <span class="n">group</span> <span class="n">array</span>
            <span class="n">add</span> <span class="n">words</span> <span class="n">to</span> <span class="n">anagram</span> <span class="n">group</span> <span class="n">array</span>
    <span class="n">add</span> <span class="n">anagram</span> <span class="n">group</span> <span class="n">array</span> <span class="n">to</span> <span class="k">return</span> <span class="n">value</span>
    
<span class="k">return</span> <span class="n">the</span> <span class="k">return</span> <span class="n">value</span>
</div></code></pre><p>This is obviously an inefficient solution due to the 2 nested arrays. This solution would give us an O(nÂ²) time solution + the time to check if the words are anagrams of one another + the time to check if the words are not in an anagram array. This total time equates to O(nÂ²xw), where n is the length of the input array, x is the length of the longest word, and w is the length of the longest anagram array. Not great. Space complexity is O(n) where n is the length of the return value.</p><h3>Approach</h3><h3>[ Sort + HashTable ]</h3><h3>[ O(wnLog(n)) time + O(wn) space ]</h3><p>The bottle necks we can identify from our brute force solution, is obviously: validating 2 words are anagrams of one another, and the grouping mechanism of the nested loops. We need to be able to find the groups faster.</p><p>One easy way to think about this is: We can find if two strings are anagrams of one another by sorting the letters in the strings alphabetically. For example, we know "rat" &amp; "tar" are anagrams because if we sort those two strings, "art" &amp; "art" are equal to one another.</p><p>Another good thought to have is, if we know a strings sorted representation we can figure out its group easily with a HashTable. If we know "rat" &amp; "art" &amp; tar" are all anagrams of one another, we can sort all of them in a Hashtable with their common sorted representation of "art" as HashTable key. It would look something like this:</p><pre><code><div class="highlight"><span></span><span class="kr">get</span> <span class="bp">sorted</span> <span class="n">representations</span> <span class="n">of</span> <span class="n">the</span> <span class="n">input</span> <span class="n">array</span><span class="p">...</span><span class="bp">sort</span> <span class="n">each</span> <span class="n">element</span>

<span class="k">for</span> <span class="n">index</span> <span class="n">of</span> <span class="bp">sorted</span>
    <span class="k">if</span> <span class="n">our</span> <span class="bp">sorted</span> <span class="n">representation</span> <span class="k">is</span> <span class="n">already</span> <span class="k">in</span> <span class="n">the</span> <span class="n">HashTable</span>
        <span class="kr">get</span> <span class="n">the</span> <span class="n">value</span><span class="p">,</span> <span class="n">and</span> <span class="n">add</span> <span class="n">the</span> <span class="n">element</span> <span class="n">of</span> <span class="n">the</span> <span class="n">input</span> <span class="n">array</span> <span class="p">(</span><span class="n">at</span> <span class="n">this</span> <span class="n">index</span><span class="p">)</span> <span class="n">to</span> <span class="n">the</span> <span class="n">hashTable</span> <span class="n">value</span>
    <span class="k">if</span> <span class="n">our</span> <span class="bp">sorted</span> <span class="n">representation</span> <span class="k">is</span> <span class="n">NOT</span> <span class="k">in</span> <span class="n">the</span> <span class="n">HashTable</span>
        <span class="n">add</span> <span class="n">it</span><span class="p">,</span> <span class="n">with</span> <span class="n">a</span> <span class="n">value</span> <span class="n">of</span> <span class="n">the</span> <span class="n">element</span> <span class="n">of</span> <span class="n">the</span> <span class="n">input</span> <span class="n">array</span><span class="p">,</span> <span class="n">at</span> <span class="n">this</span> <span class="n">index</span><span class="p">.</span>


<span class="k">for</span> <span class="n">values</span> <span class="k">in</span> <span class="n">our</span> <span class="n">HashTable</span>
    <span class="n">append</span> <span class="n">them</span> <span class="n">to</span> <span class="n">the</span> <span class="k">return</span> <span class="n">value</span>

<span class="k">return</span> <span class="n">the</span> <span class="k">return</span> <span class="n">value</span>
</div></code></pre><p>This can be a little wordy on the plan english implementation but we will see it with code soon enough. The space complexity of this solution is O(wn) where w is the number of unique words, and n is the length of the longest word. The time complexity of this problem is the time it takes to sort the input array O(nLogn) times the number of words in the input array that are unique. This comes out to be O(wnLog(n)) time.</p><p>The final product:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">sorted</span> <span class="p">=</span> <span class="n">strs</span><span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nb">String</span><span class="p">(</span><span class="nv">$0</span><span class="p">.</span><span class="bp">sorted</span><span class="p">())</span> <span class="p">}</span> <span class="c1">// Our array of sorted representations</span>
<span class="kd">var</span> <span class="nv">returnVal</span> <span class="p">=</span> <span class="p">[[</span><span class="nb">String</span><span class="p">]]()</span>
<span class="kd">var</span> <span class="nv">hashMap</span> <span class="p">=</span> <span class="p">[</span><span class="nb">String</span><span class="p">:</span> <span class="p">[</span><span class="nb">String</span><span class="p">]]()</span>
        
<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span> <span class="k">in</span> <span class="bp">sorted</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">var</span> <span class="nv">existing</span> <span class="p">=</span> <span class="n">hashMap</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// if our element is already in the HashTable</span>
        <span class="n">existing</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">strs</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="c1">// Get the grouped words, and add our new word to the existing array</span>
        <span class="n">hashMap</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="n">existing</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">hashMap</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span><span class="n">strs</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span> <span class="c1">// It is not in HashTable yet, lets add the unique string to it as a key, with our original word as the value</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="n">hashMap</span><span class="p">.</span><span class="n">values</span> <span class="p">{</span> <span class="n">returnVal</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// For all grouped words, lets append it to our return value.</span>

<span class="k">return</span> <span class="n">returnVal</span>
</div></code></pre><p>Well Done!</p><hr><h1>Longest Consecutive Sequence</h1><p>This problem is our introduction into common leetcode problems, namely sequences and subsequences.</p><img src="https://swiftrefresher.com/longestconsecutivesequence.png"/><h3>Brute Force</h3><p>We should make sure we read the problem carefully here. There are a couple things to keep in mind:</p><ul><li>The numbers are unsorted</li><li>We do not care <em>what</em> the longest consecutive sequence is, we just care about the length of the longest sequence</li><li>We <em>must</em> have an O(n) solution</li></ul><p>Because we need an O(n) solution, it may be a waste of our time thinking of Brute force solutions. We know also that we cannot sort this list of unsorted numbers, because sorting alone will give us, at best, O(nLogn) time complexity.</p><p>It's important here to realize what makes a sequence. If we have a number X, we know we have a sequence if X - 1 or X + 1 exists. If we wanted to think of a brute force solution, we could start by iterating on every element and looking for something that would match a sequence on each number. If we find a number, we could loop once again expanding left and right of our sequence.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">inner</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="k">if</span> <span class="n">inner</span> <span class="n">makes</span> <span class="n">a</span> <span class="n">sequence</span>
            <span class="n">search</span> <span class="k">for</span> <span class="n">expansion</span> <span class="n">of</span> <span class="kr">left</span> <span class="n">of</span> <span class="n">sequence</span>
            <span class="n">search</span> <span class="k">for</span> <span class="n">expansion</span> <span class="n">of</span> <span class="kr">right</span> <span class="n">of</span> <span class="n">sequence</span>
        <span class="n">keep</span> <span class="n">track</span> <span class="k">if</span> <span class="n">this</span> <span class="k">is</span> <span class="n">the</span> <span class="n">longest</span> <span class="n">we</span> <span class="n">have</span> <span class="n">seen</span>
<span class="k">return</span> <span class="n">the</span> <span class="n">longest</span> <span class="n">we</span> <span class="n">have</span> <span class="n">seen</span>
</div></code></pre><p>Overall this works, but has terrible efficiency. We have two nested loops, which gives us O(nÂ²) time complexity. Plus for our expansion of the left &amp; right of our sequence, we would continually search in our array for those. At best a searching algorithm could give us O(2Logn) because we have to do it twice. Overall this gives us O(nÂ²Logn) time complexity. Just not great.</p><h3>Approach</h3><h3>[ HashTable ]</h3><h3>[ O(n) time + O(n) space ]</h3><p>Yep! You guessed it, we are bringing back our friend the hash table. We can look for the existence of a sequence as we iterate on our array. And store each value in our array to see if we have seen a possible sequence already.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">keep</span> <span class="n">track</span> <span class="n">of</span> <span class="n">this</span> <span class="n">iterative</span> <span class="n">sequence</span> <span class="n">length</span>
    <span class="k">while</span> <span class="err">Â±</span> <span class="mi">1</span> <span class="n">of</span> <span class="n">our</span> <span class="n">number</span> <span class="n">exists</span> <span class="k">in</span> <span class="n">the</span> <span class="n">hashTable</span>
        <span class="n">append</span> <span class="n">to</span> <span class="n">our</span> <span class="n">sequence</span>
        <span class="n">keep</span> <span class="n">expanding</span> <span class="k">in</span> <span class="n">the</span> <span class="n">direction</span> <span class="n">we</span> <span class="n">are</span> <span class="n">checking</span>
    <span class="n">add</span> <span class="n">this</span> <span class="n">number</span> <span class="n">to</span> <span class="n">the</span> <span class="n">hashTable</span>
    <span class="n">what</span> <span class="k">is</span> <span class="n">bigger</span><span class="p">,</span> <span class="n">the</span> <span class="n">longest</span> <span class="n">sequence</span> <span class="n">we</span> <span class="n">have</span> <span class="n">seen</span><span class="p">?</span> <span class="n">or</span> <span class="n">this</span> <span class="n">iterative</span> <span class="n">sequence</span> <span class="n">length</span><span class="p">?</span>

<span class="k">return</span> <span class="n">longest</span>
</div></code></pre><p>This is an O(n) solution, where n is the length of the input array, because we only iterate through the array once, and our while loop is just checking for the existence of a number in a hash table. Hash Table's give us O(1) lookup which is awesome. Our space is O(n) because we are just filling a hashTable, and a hashTable can only be n length where n is the number of unique numbers in our input array. Let's create the final answer:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">longest</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// Initially our greatest sequence will be 0</span>
<span class="kd">var</span> <span class="nv">hashMap</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">:</span><span class="nb">Bool</span><span class="p">]()</span>

<span class="k">for</span> <span class="n">element</span> <span class="k">in</span> <span class="n">nums</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">minusOne</span> <span class="p">=</span> <span class="n">element</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// Create a variable for the left section of our possible sequence</span>
    <span class="kd">var</span> <span class="nv">plusOne</span> <span class="p">=</span> <span class="n">element</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// Create a variable for the right section of our possible sequence</span>
    <span class="kd">var</span> <span class="nv">thisSequenceLongest</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">hashMap</span><span class="p">[</span><span class="n">minusOne</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// While we have seen a left sequence (it exists in our hashTable)</span>
        <span class="n">thisSequenceLongest</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">minusOne</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1">// Keep expanding</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="n">hashMap</span><span class="p">[</span><span class="n">plusOne</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// While we have seen a right sequence (it exists in our hashTable)</span>
        <span class="n">thisSequenceLongest</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">plusOne</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// Keep expanding</span>
    <span class="p">}</span>
    <span class="n">hashMap</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span> <span class="c1">// Add this element to our hashTable</span>
    <span class="n">longest</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">longest</span><span class="p">,</span> <span class="n">thisSequenceLongest</span><span class="p">)</span> <span class="c1">// Update the longest sequence we have seen</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">longest</span>
</div></code></pre><p>Nice! This was definitely a tricky one.</p><hr><h1>Encode and Decode Strings</h1><p>This is a LeetCode premium question, but still worth going over as it gives good insight on Array/String manipulation! This is a classic Google question too. Here is the screenshot:</p><img src="https://swiftrefresher.com/encodedecodestrings.png"/><h3>Possible Ideas</h3><p>Pretty straight forward! And considering there is not really a point to optimize a brute force solution lets walk through some thoughts.<br><br>1. We have to create 2 functions, an encoding function &amp; a decoding function. The importance is how we need to encode our original array, so our decoding function will know how to handle the string. 2. We need to make this generic enough to use any ASCII characters. 3. This must be stateless. No class level variables allowed.</p><p>So when I looked at this problem, my first thought was 'I need a way to mark the separation of values in our original array'. For example if we have an input array of ["Alex", "Loves", "Google"] then I need a special character to mark the difference between "Alex" and "Google". With this thinking, I chose "#" as my separation character. ["Alex", "Loves", "Google"] would turn into â†’ "Alex#Loves#Google". Nice!</p><p>This causes concern though. In our original problem statement, the question mentioned we need these functions to be generic enough to host any ASCII character. If we use any ASCII character as our separation element, there is the chance the separation element appears in our input array. Let's take the input array of ["Alex", "#", "R"] for example. If our separation element is "#" our input array would be encoded to "Alex###R". When we go to decode this, and decode based on separation elements, does the string "Alex###R" translate to ["Alex", "##R"]? Or ["Alex#", "#R"]? Or ["Alex#", "#", "R"]? There is no way to know. And no matter the separation character we choose to use, this will be a problem.</p><p>To solve this, we need a way to define 1. the separation of characters, and 2. the beginning and end of an element. A straight forward way to go about this is by using the word's length + separation character at the beginning of each element. For example ["Alex", "#", "R"] is encoded into "4#Alex1##1#R". The thinking here is, when we get to separation character, the previous number to it will tell us how far ahead to skip for our element. So on and so forth ad nauseam. Let's get some psuedocode together for the encoding and decoding.</p><pre><code><div class="highlight"><span></span><span class="n">Encoding</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">word</span> <span class="k">in</span> <span class="n">input</span>
        <span class="n">concatenate</span> <span class="k">return</span> <span class="n">string</span> <span class="n">with</span><span class="p">:</span> <span class="n">word</span> <span class="n">length</span> <span class="o">+</span> <span class="s">&quot;#&quot;</span> <span class="o">+</span> <span class="n">word</span>
    <span class="k">return</span> <span class="n">the</span> <span class="n">encoded</span> <span class="n">string</span>
    
    
<span class="n">Decoding</span><span class="p">:</span>
    <span class="n">start</span> <span class="n">at</span> <span class="n">the</span> <span class="n">beginning</span> <span class="n">of</span> <span class="n">the</span> <span class="n">encoded</span> <span class="n">string</span>
    <span class="k">while</span> <span class="n">this</span> <span class="n">index</span> <span class="k">is</span> <span class="k">in</span> <span class="n">bounds</span> <span class="n">of</span> <span class="n">the</span> <span class="n">string</span>
        <span class="n">start</span> <span class="n">a</span> <span class="n">new</span> <span class="n">index</span> <span class="k">for</span> <span class="n">the</span> <span class="n">current</span> <span class="n">element</span>
        <span class="k">while</span> <span class="n">this</span> <span class="n">new</span> <span class="n">index</span> <span class="k">is</span> <span class="n">not</span> <span class="n">a</span> <span class="n">separation</span> <span class="n">character</span>
            <span class="n">append</span> <span class="n">to</span> <span class="n">new</span> <span class="n">index</span> <span class="n">by</span> <span class="mi">1</span>
        <span class="k">else</span>
            <span class="kr">get</span> <span class="n">word</span> <span class="n">size</span> <span class="n">from</span> <span class="n">index</span> <span class="p">-&gt;</span> <span class="n">newIndex</span>
            <span class="kr">get</span> <span class="n">word</span> <span class="n">from</span> <span class="n">new</span> <span class="n">index</span> <span class="p">-&gt;</span> <span class="n">word</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">append</span> <span class="n">word</span> <span class="n">to</span> <span class="n">response</span>
            <span class="n">track</span> <span class="n">new</span> <span class="n">index</span> <span class="n">at</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">the</span> <span class="bp">last</span> <span class="n">added</span> <span class="n">word</span>
</div></code></pre><p>Lot of Math there! Let's talk some time complexities. Encoding function will obviously be O(n) time where n is the length of the inout array. The space complexity will be O(c + 1 + s) where c is the number of characters in our input array, s is the separation character or string we choose, and 1 for the length of the word in Int form.</p><p>Decoding is a little more complicated. The space complexity is O(n) where n is the length of our original input array. The time complexity is O(n - x) where n is the length of characters in our encoded string, and x is the number of elements in our original input array. Not too bad.</p><h3>Approach</h3><h3>[ Separation Characters + Length ]</h3><h3>[ Encoding: O(n) time, O(c + 1 + s) space ]</h3><h3>[ Decoding: O(n - x) time, O(n) space ]</h3><p>Let's put this implementation to the test!</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="kc">_</span> <span class="n">words</span><span class="p">:</span> <span class="p">[</span><span class="nb">String</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">returnVal</span> <span class="p">=</span> <span class="s">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">word</span> <span class="k">in</span> <span class="n">words</span> <span class="p">{</span>
        <span class="n">returnVal</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="si">\(</span><span class="n">word</span><span class="p">.</span><span class="bp">count</span><span class="si">)</span><span class="s">&quot;</span> <span class="o">+</span> <span class="s">&quot;#&quot;</span> <span class="o">+</span> <span class="n">word</span> <span class="c1">// Pre-traversal concatenation</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">returnVal</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">decode</span><span class="p">(</span><span class="kc">_</span> <span class="n">str</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="nb">String</span><span class="p">]</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">returnVal</span> <span class="p">=</span> <span class="p">[</span><span class="nb">String</span><span class="p">]()</span>
    <span class="kd">var</span> <span class="nv">index</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span> <span class="c1">// Loop through characters in our encoded string</span>
        
        <span class="kd">var</span> <span class="nv">thisWordIndex</span> <span class="p">=</span> <span class="n">index</span> <span class="c1">// Index for this given word</span>
        <span class="k">while</span> <span class="n">thisWordIndex</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nv">currentElementIndex</span> <span class="p">=</span> <span class="n">str</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="n">thisWordIndex</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">str</span><span class="p">[</span><span class="n">currentElementIndex</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;#&quot;</span> <span class="p">{</span> <span class="c1">// While we have not found a new word, continue</span>
                <span class="n">thisWordIndex</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">break</span> <span class="c1">// We have found a word, time to evaluate</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="kd">let</span> <span class="nv">beginningIndex</span> <span class="p">=</span> <span class="n">str</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="n">index</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">endingIndex</span> <span class="p">=</span> <span class="n">str</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="n">thisWordIndex</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">wordSize</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">beginningIndex</span><span class="p">..&lt;</span><span class="n">endingIndex</span><span class="p">])</span> <span class="p">??</span> <span class="mi">0</span> <span class="c1">// The size of the word</span>
        
        <span class="kd">let</span> <span class="nv">wordBeginningIndex</span> <span class="p">=</span> <span class="n">str</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="n">thisWordIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">wordEndingIndex</span> <span class="p">=</span> <span class="n">str</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">offsetBy</span><span class="p">:</span> <span class="n">thisWordIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">wordSize</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">word</span> <span class="p">=</span> <span class="n">str</span><span class="p">[</span><span class="n">wordBeginningIndex</span><span class="p">..&lt;</span><span class="n">wordEndingIndex</span><span class="p">]</span> <span class="c1">// The word itself</span>
        
        <span class="n">returnVal</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="n">word</span><span class="p">))</span> <span class="c1">// Append the word to our return array</span>
        <span class="n">index</span> <span class="p">=</span> <span class="n">thisWordIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">wordSize</span> <span class="c1">// Set index to the end of our last word found and continue.</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">returnVal</span>
<span class="p">}</span>
</div></code></pre><p>Substrings in Swift are NOT FUN ðŸ˜Ž</p><hr><h1>Top K Frequent Elements</h1><p>This is a tricky problem, especially in the iOS world.</p><img src="https://swiftrefresher.com/topkfrequentelements.png"/><h3>Brute Force</h3><p>I think the brute force solution is pretty obvious. We can nest loops, and for every element we can count how often it appears in the input array. Outside of our loops we can keep track of the largest count. Based on our K input integer we can build out our top k frequent elements array.</p><pre><code><div class="highlight"><span></span><span class="n">create</span> <span class="n">array</span> <span class="n">of</span> <span class="n">k</span> <span class="n">length</span>

<span class="k">for</span> <span class="n">indexed</span> <span class="n">loop</span> <span class="n">from</span> <span class="mi">1</span> <span class="p">-&gt;</span> <span class="n">k</span>
    <span class="n">loop</span> <span class="n">input</span> <span class="n">array</span> <span class="n">and</span> <span class="bp">find</span> <span class="n">most</span> <span class="n">indexed</span> <span class="n">most</span> <span class="n">element</span> <span class="n">and</span> <span class="n">its</span> <span class="bp">count</span>
    <span class="n">compare</span> <span class="n">after</span> <span class="n">each</span> <span class="n">loop</span> <span class="n">to</span> <span class="n">see</span> <span class="k">if</span> <span class="n">the</span> <span class="k">return</span> <span class="n">array</span> <span class="n">needs</span> <span class="n">to</span> <span class="n">be</span> <span class="n">adjusted</span>
</div></code></pre><p>This has two nested loops so the time complexity here would be O(nk) where n is the length of the input array, and k is the input variable k. The space complexity would be O(k) where k is the input variable k we start the problem with, due to the length of the return variable.<br><br>Even a brute force solution here would be difficult, so lets simplify our lives a little bit, and introduce our favorite friends: Sorting and A HashTable.</p><h3>Approach</h3><h3>[ Sort + HashTable ]</h3><h3>[ O(uLogu) time + O(2u) space ]</h3><p>One easy way to simplify storing the count of each character frequency is to use a HashTable. We can use the HashTable as an [Int:Int] dictionary where each key is the unique element in the input array, and the value is its frequency in the input array. We can then sort our dictionary by values, descending order to get which elements have the highest frequency, and return the first k from the sorted dictionary.</p><pre><code><div class="highlight"><span></span><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="n">add</span> <span class="n">to</span> <span class="n">hashTable</span> <span class="k">if</span> <span class="n">it</span> <span class="n">doesnt</span> <span class="n">already</span> <span class="n">exist</span>
    <span class="k">if</span> <span class="n">it</span> <span class="n">does</span> <span class="n">exist</span><span class="p">,</span> <span class="n">append</span> <span class="n">its</span> <span class="n">frequency</span> <span class="n">by</span> <span class="mi">1</span>

<span class="bp">sort</span> <span class="n">hashTable</span> <span class="n">by</span> <span class="n">values</span><span class="p">,</span> <span class="n">descending</span> <span class="n">order</span>

<span class="k">for</span> <span class="n">indexed</span> <span class="n">loop</span> <span class="k">in</span> <span class="mi">1</span> <span class="p">-&gt;</span> <span class="n">k</span>
    <span class="kr">get</span> <span class="n">hashTable</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="n">key</span><span class="p">,</span> <span class="n">and</span> <span class="n">add</span> <span class="n">to</span> <span class="k">return</span> <span class="n">array</span>
    
<span class="k">return</span> <span class="n">returnArray</span>
</div></code></pre><p>The tricky thing here is to make sure you are sorting properly. We want to sort the hashTable, but after sorting we only care about the keys in the hash-table, so it might be more intelligent to leverage the swift built in higher order functions on arrays to get the data structure we want.</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">hashTable</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">:</span><span class="nb">Int</span><span class="p">]()</span>
<span class="kd">var</span> <span class="nv">returnVal</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]()</span>

<span class="k">for</span> <span class="n">num</span> <span class="k">in</span> <span class="n">nums</span> <span class="p">{</span>
    <span class="n">hashTable</span><span class="p">[</span><span class="n">num</span><span class="p">,</span> <span class="k">default</span><span class="p">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// add these values to a hashTable, and append the existing number if it exists</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">sorted</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">hashTable</span><span class="p">.</span><span class="bp">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="nv">$1</span><span class="p">.</span><span class="n">value</span> <span class="p">})</span> <span class="c1">// sort our hashTable by value.</span>
                <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">key</span> <span class="p">})</span> <span class="c1">//  But then put the (now sorted) keys into an array for easier access</span>

<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.&lt;</span><span class="n">k</span> <span class="p">{</span> <span class="c1">// loop through K times to get the top K elements from the sorted data structure</span>
    <span class="n">returnVal</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">sorted</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">returnVal</span>
</div></code></pre><p>The time complexity here is (n + uLogu + u + k) Where K is our input variable k, and n is the size of the input array, and u is the number of unique numbers. We go through the input array once (n), we sort the hashTable (guaranteed to only have u elements -&gt; uLogu), we add the unique elements into an array (u) and loop to find the top k elements (k). This mathematically simplifies to 2uLogu + n + k -&gt; which translates to uLogu on average.</p><p>The space complexity is O(2u) where u is the number of unique elements in the input array. Our HashTable will only ever be u size, because all keys must be unique in a hashTable. and our array of sorted keys will only ever be u size because of the same reason as before. That is 2 separate u space data structures that on average equal out to 2u.</p><p>Well done! Just be careful when it comes to Swift sorting ðŸ˜ƒ</p><hr><h1>Container With Most Water</h1><p>This is a tricky problem, especially in the iOS world.</p><img src="https://swiftrefresher.com/continerwithmostwater.png"/><p>On initial thinking we see this has a math component. The good news about programming problems with math components is, the math is never more than basic algebra. It's all about having strong problem solving skills</p><h3>Brute Force</h3><p>The brute force solution to this problem seems obvious at first. We need to find the largest area between two points. By having some nested loops, we can calculate all possible areas for all values.</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">track</span> <span class="n">of</span> <span class="n">maximum</span>
<span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
    <span class="k">for</span> <span class="n">inner</span> <span class="n">number</span> <span class="k">in</span> <span class="n">array</span>
        <span class="n">calculate</span> <span class="n">area</span>
        <span class="n">update</span> <span class="n">maximum</span> <span class="k">as</span> <span class="n">necessary</span>
</div></code></pre><p>The time complexity here is O(nÂ²) due to the nested nature of the loops. Calculating area, and keeping track of a maximum are both O(1) operations. The space complexity is also constant because we are just storing the return value in a single variable, that does not expand.</p><h3>Approach</h3><h3>[ 2 pointers ]</h3><h3>[ O(n) time + O(1) space ]</h3><p>By using 2 pointers we can more effectively find the maximum area within a set of data points. We essentially need to find the 2 values that are the furthest apart, with one of the values being as maximum as possible. By keeping a left and right pointer and the beginning and end of our array, we can iteratively move the pointers inward based on which value is smaller. That way we can keep our maximum of the 2 values.</p><pre><code><div class="highlight"><span></span><span class="n">keep</span> <span class="n">a</span> <span class="kr">left</span> <span class="o">&amp;</span> <span class="kr">right</span> <span class="n">pointer</span>
<span class="n">keep</span> <span class="n">a</span> <span class="n">maximum</span> <span class="n">array</span> <span class="n">variable</span>

<span class="k">while</span> <span class="kr">left</span> <span class="n">pointer</span> <span class="o">&lt;</span> <span class="kr">right</span> <span class="n">pointer</span> 
    <span class="bp">find</span> <span class="n">area</span>
    <span class="n">update</span> <span class="n">area</span> <span class="k">as</span> <span class="n">needed</span>
    <span class="n">move</span> <span class="n">either</span> <span class="kr">left</span> <span class="n">or</span> <span class="kr">right</span> <span class="n">pointer</span> <span class="n">inward</span> <span class="p">(</span><span class="n">whichever</span> <span class="k">is</span> <span class="n">smaller</span><span class="p">)</span>
</div></code></pre><p>The time complexity here is O(1/2n) which translates to O(n) on average. This is because we will on average gravitate towards the middle of our array with our pointers. It is guaranteed we will never move greater than the length of the array. The space complexity is O(1) because we only have 3 constant variables, the area &amp; the left + right pointers.</p><p>We should think how to find the area at each iteration. This can be found of width ** height. The height is the smaller of the 2 values because the problem description says we cannot tip our container. And the width is the distance between the 2 pointers aka rightPointer - leftPointer.</p><pre><code><div class="highlight"><span></span><span class="k">guard</span> <span class="n">height</span><span class="p">.</span><span class="bp">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span> <span class="c1">// edge cases </span>
<span class="kd">var</span> <span class="nv">leftPointer</span> <span class="p">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rightPointer</span> <span class="p">=</span> <span class="n">height</span><span class="p">.</span><span class="bp">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">area</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// setup our pointers</span>

<span class="k">while</span> <span class="n">leftPointer</span> <span class="o">&lt;</span> <span class="n">rightPointer</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">leftValue</span> <span class="p">=</span> <span class="n">height</span><span class="p">[</span><span class="n">leftPointer</span><span class="p">]</span>
    <span class="kd">let</span> <span class="nv">rightValue</span> <span class="p">=</span> <span class="n">height</span><span class="p">[</span><span class="n">rightPointer</span><span class="p">]</span>
    <span class="kd">let</span> <span class="nv">iterativeArea</span> <span class="p">=</span> <span class="p">(</span><span class="n">rightPointer</span> <span class="o">-</span> <span class="n">leftPointer</span><span class="p">)</span> <span class="o">*</span> <span class="bp">min</span><span class="p">(</span><span class="n">leftValue</span><span class="p">,</span> <span class="n">rightValue</span><span class="p">)</span> <span class="c1">// find our area at this cycle in our loop</span>
    
    <span class="n">area</span> <span class="p">=</span> <span class="bp">max</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">iterativeArea</span><span class="p">)</span> <span class="c1">// update our area value as needed</span>
    
    <span class="k">if</span> <span class="n">leftValue</span> <span class="o">&lt;</span> <span class="n">rightValue</span> <span class="p">{</span> <span class="c1">// left value is smaller, move left pointer in</span>
        <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">leftValue</span> <span class="o">&gt;</span> <span class="n">rightValue</span> <span class="p">{</span> <span class="c1">// right value is smaller, move right pointer in</span>
        <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// values are equal, move both pointers</span>
        <span class="n">leftPointer</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">rightPointer</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">area</span>
</div></code></pre><hr><h1>Conclusion</h1><p>When facing array problems, try to keep in mind some of these tricks we learned in these problems. You will start to find programming problems follow similar patterns! Happy Coding!</p><hr>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/leetcode/how-to-solve-a-leetcode-problem</guid><title>How to solve a Leetcode problem</title><description>Leetcode. The bane of many a programmer</description><link>https://swiftrefresher.com/leetcode/how-to-solve-a-leetcode-problem</link><pubDate>Mon, 14 Mar 2022 22:15:00 -0400</pubDate><content:encoded><![CDATA[<h1>Overview</h1><p>Overall, you will find that many leetcode problems are similar to one another. Once you build a solid foundation of knowledge (Blind 75) you will be able to conquer any problem! Keep this in mind when you are looking for patterns within problems. If a string problem stumps you, try thinking of it from an array perspective and vice versa! When I think about Leetcode solutions, I take the following steps:</p><h3>The process</h3><ol><li>Clarify the question with your interviewer. ASK QUESTIONS! Don't rush into it.</li><li>Understand the problem. Know WHY the answers are correct vs incorrect.</li><li>Approach a Brute Force solution, in THEORY but do not code yet.</li><li>Write some pseudocode for your brute force solution.</li><li>Run through test cases, on your pseudocode to make sure it works. (Time permitting)</li><li>Identify bottlenecks, and optimize as necessary.</li><li>Code the final solution.</li><li>TEST!</li></ol><h3>Testing</h3><p>When testing our solutions, it's always good to think about edge cases to test against. This shows our interviewer our deep knowledge of the underlying data structure, as well as the ability to think outside of the box. Here is my (not so) exhaustive list of testing criteria for arrays and strings.</p><h5>Arrays</h5><ol><li>Nil input value</li><li>Empty array</li><li>Single value in array</li><li>Repeating values in the array</li><li>Large array</li></ol><h5>Strings</h5><ol><li>Nil input value</li><li>Empty string</li><li>Special characters in strings (ie. $%^&amp;#ðŸ˜ŽðŸ˜ƒ)</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/swift/arrays</guid><title>Arrays Overview</title><description>Programmers best friend</description><link>https://swiftrefresher.com/swift/arrays</link><pubDate>Thu, 3 Mar 2022 23:15:00 -0500</pubDate><content:encoded><![CDATA[<h1>Arrays</h1><h2>Overview</h2><p>I figured we could start with one of the simplest data structures on our journey. Array's are a swift collection type &amp; they can hold elements of a single type, whether it be Integers, Strings, or Structs/Classes. They are linear collections that are accessible using indexes starting at index Zero.</p><h3>Array's in Memory</h3><p>Swift arrays come in 2 different variations depending on how you initialize them:</p><p>Static arrays are an array implementation in which the size of the array is determined on initialization. Under the hood, the machine will allocate a fixed amount of memory to store this initialized array. Which is nice! But comes at a cost. In order to append values, the machine will copy the entire array over, and allocate new memory space for it + the new value you want to add. This is a linear operation.</p><p>Dynamic arrays are an array implementation that preemptively allocates DOUBLE the memory needed to store the arrays values. Therefore when you want to append a new value, that operation is constant time due to the already free space available to add the value into memory. When all the extra free space is filled up, the array is copied and stored elsewhere. This operation is Amortized constant time, when inserting at the end of the array.</p><h3>Under the hood Swift Implementation</h3><p>When looking through the swift source code on arrays, you will see the underlying implementation of arrays uses Structs. This means arrays are value types, and whenever you copy an array over to a new variable, the value of the array is copied and stored in a new memory address. Any changes to this copied variable will not affect the original array. For example:</p><pre><code><div class="highlight"><span></span><span class="kd">var</span> <span class="nv">originalArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="kd">var</span> <span class="nv">copyArray</span> <span class="p">=</span> <span class="n">originalArray</span>
<span class="n">copyArray</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="bp">print</span><span class="p">(</span><span class="n">originalArray</span><span class="p">)</span> <span class="c1">// [1, 2, 3]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">copyArray</span><span class="p">)</span> <span class="c1">// [1, 2, 3, 4]</span>
</div></code></pre><p>To be even more efficient, Swift uses copy-on-write optimization for arrays. This means copies of arrays are stored at the same memory address until one of the copies is mutated. Then the array is stored into a new memory address. Keep this in mind when writing efficient code, because in swift copying the array over a bunch is not the time consuming event. The mutation of the copy is what will cost you in Big O time.</p><h3>Big O operations on Arrays</h3><ul><li>Accessing value at an index <strong>O(1)</strong></li><li>Update value at an index <strong>O(1)</strong></li><li>Insert value at beginning <strong>O(n)</strong></li><li>Insert value at middle <strong>O(n)</strong></li><li>Insert value at end:<ul><li>Dynamic arrays: Amortized <strong>O(1)</strong></li><li>Static arrays: <strong>O(n)</strong></li></ul></li></ul><ul><li>Remove value at beginning <strong>O(n)</strong></li><li>Remove value at middle <strong>O(n)</strong></li><li>Remove value at end <strong>O(1)</strong></li><li>Copy array <strong>O(n)</strong></li></ul><h3>Array Declarations</h3><p>Arrays are very easy to declare (dynamic arrays):</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">arrayOne</span> <span class="p">=</span> <span class="p">[</span><span class="nb">String</span><span class="p">]()</span>
<span class="kd">let</span> <span class="nv">arrayTwo</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span>
<span class="kd">let</span> <span class="nv">arrayThree</span> <span class="p">=</span> <span class="p">[</span><span class="n">CustomObjectOne</span><span class="p">,</span> <span class="n">CustomObjectTwo</span><span class="p">]</span>
</div></code></pre><p>The swift compiler does some really cool things under the hood to infer the underlying type based on how you declare the variable.</p><p>You can also determine the size of the array &amp; repeated values of the array on variable declaration like so (static array):</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">arrayFour</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">repearing</span><span class="p">:</span> <span class="s">&quot;Four&quot;</span> <span class="bp">count</span><span class="p">:</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">// [&quot;Four&quot;, &quot;Four&quot;, &quot;Four&quot;, &quot;Four&quot;, &quot;Four&quot;, &quot;Four&quot;]</span>
</div></code></pre><h2>Operations on Arrays</h2><p>Inserting elements in arrays is simple, there are a couple main API's depending on your use case:</p><pre><code><div class="highlight"><span></span><span class="n">arrayFive</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="c1">// at to the end</span>
<span class="n">arrayFive</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">contentsOf</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span> <span class="c1">// add a sequence</span>
<span class="c1">// [1, 2, 8, 0, 7]</span>

<span class="n">arrayFive</span><span class="p">.</span><span class="bp">insert</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">at</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// 0-based index</span>
<span class="c1">// [1, 2, 8, 9, 0, 7]</span>
</div></code></pre><p>Here is how to delete elements in an array:</p><pre><code><div class="highlight"><span></span><span class="n">arrayFive</span><span class="p">.</span><span class="n">removeFirst</span><span class="p">()</span>
<span class="n">arrayFive</span><span class="p">.</span><span class="bp">removeLast</span><span class="p">()</span>
<span class="c1">// [2, 8, 9, 0]</span>

<span class="n">arrayFive</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">at</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> 
<span class="c1">// remove index 0</span>
<span class="c1">// [8, 9, 0]</span>
</div></code></pre><p>By accessing an element on an array you can substitute the value in place:</p><pre><code><div class="highlight"><span></span><span class="k">if</span> <span class="kd">let</span> <span class="nv">element</span> <span class="p">=</span> <span class="n">arrayFive</span><span class="p">.</span><span class="n">firstIndex</span><span class="p">(</span><span class="n">of</span><span class="p">:</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">arrayFive</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="p">=</span> <span class="mi">9</span>
<span class="p">}</span>
<span class="c1">// [9, 9, 0]</span>
</div></code></pre><h2>Higher Order Functions</h2><h3>Sort</h3><p>Say you have a collection of elements in the form of an array, and you want to sort these elements by some sort of predicate. The swift collection type comes with the built in sorted by function. This function returns a new array from your desired sorting mechanism. For example:</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="p">(</span><span class="n">Base</span><span class="p">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">Base</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="nb">Bool</span><span class="p">)</span> <span class="kr">rethrows</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">Base</span><span class="p">.</span><span class="n">Element</span><span class="p">]</span> 
</div></code></pre><p>The sorted by function takes a predicate in which you can define how to sort your elements.</p><pre><code><div class="highlight"><span></span><span class="kd">struct</span> <span class="nc">FooStruct</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">value</span><span class="p">:</span> <span class="nb">Int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">nonSortedArray</span> <span class="p">=</span> <span class="p">[</span><span class="n">FooStruct</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="mi">15</span><span class="p">),</span> <span class="n">FooStruct</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">),</span> <span class="n">FooStruct</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="mi">9</span><span class="p">)]</span>
<span class="c1">// Trailing closure notation</span>
<span class="kd">var</span> <span class="nv">sortedArrayOne</span> <span class="p">=</span> <span class="n">nonSortedArray</span><span class="p">.</span><span class="bp">sorted</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="k">in</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">value</span>
<span class="p">}</span>
<span class="c1">// Shorthand notation</span>
<span class="kd">var</span> <span class="nv">sortedArrayTwo</span> <span class="p">=</span> <span class="n">nonSortedArray</span><span class="p">.</span><span class="bp">sorted</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="nv">$1</span><span class="p">.</span><span class="n">value</span> <span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">sortedArrayTwo</span><span class="p">)</span> <span class="c1">// [FooStruct(value: 3), FooStruct(value: 9), FooStruct(value: 15)] </span>
</div></code></pre><h3>Map</h3><p>The main purpose of Map is to iterate on every element in the array, but instead of sorting the elements, you can transform each element based on a closure you pass into it. Here is the underlying implementation:</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">map</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">transform</span><span class="p">:</span> <span class="p">(</span><span class="kc">Self</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">T</span><span class="p">)</span> <span class="kr">rethrows</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span>
</div></code></pre><p>Given the return type of the map function is T, we can pass in one type of array, and return a different type of array. For example taking in an array of numbers, mapping over them, and returning that array represented in String form.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">newArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="bp">map</span> <span class="p">{</span> <span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span>
    <span class="k">return</span> <span class="nb">String</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="p">}</span>
</div></code></pre><h3>Filter</h3><p>You can specify a filter in the form of a closure, and you can filter an array given your criteria.</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">filter</span><span class="p">(</span><span class="kc">_</span> <span class="n">isIncluded</span><span class="p">:</span> <span class="p">@</span><span class="n">escaping</span> <span class="p">(</span><span class="kc">Self</span><span class="p">.</span><span class="n">Elements</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">LazyFilterSequence</span><span class="p">&lt;</span><span class="kc">Self</span><span class="p">.</span><span class="n">Elements</span><span class="p">&gt;</span>
</div></code></pre><p>For example lets get all numbers from our array that are greater than 1.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">filteredArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">].</span><span class="bp">map</span><span class="p">{</span> <span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">1</span>
<span class="p">}</span>
</div></code></pre><h3>Reduce</h3><p>This function allows us to combine all the elements in a collection, and return a unified common (and also generic) type!</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">reduce</span><span class="p">&lt;</span><span class="n">Result</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">initialResult</span><span class="p">:</span> <span class="n">Result</span><span class="p">,</span> <span class="kc">_</span> <span class="n">nextPartialResult</span><span class="p">:</span> <span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="n">Bound</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">Result</span><span class="p">)</span> <span class="kr">rethrows</span> <span class="p">-&gt;</span> <span class="n">Result</span>
</div></code></pre><p>Let's say we want to take all of our numbers in an array, and combine them into a single long String.</p><pre><code><div class="highlight"><span></span><span class="c1">// Long version</span>
<span class="kd">let</span> <span class="nv">reduced</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">].</span><span class="bp">reduce</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{(</span><span class="n">result</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="k">in</span> 
    <span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="nb">String</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Inline version</span>
<span class="kd">let</span> <span class="nv">reduced</span> <span class="p">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">].</span><span class="bp">reduce</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">+</span> <span class="nb">String</span><span class="p">(</span><span class="nv">$1</span><span class="p">)</span> <span class="p">}</span>
</div></code></pre><h3>FlatMap</h3><p>This takes in a closure and applies this closure to every element in the array. It returns the flattened sequence post traversal.</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">flatMap</span><span class="p">&lt;</span><span class="n">SegmentOfResult</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">transform</span><span class="p">:</span> <span class="p">((</span><span class="n">key</span><span class="p">:</span> <span class="n">Key</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Value</span><span class="p">))</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">SegmentOfResult</span><span class="p">)</span> <span class="kr">rethrows</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">SegmentOfResult</span><span class="p">.</span><span class="n">Element</span><span class="p">]</span> <span class="k">where</span> <span class="n">SegmentOfResult</span> <span class="p">:</span> <span class="n">Sequence</span>
</div></code></pre><p>Remember that map can return a different array type than was traversed upon. But with FlatMap we can transform, and then flatten. Typically this function is used in sequences of sequences.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">strings</span> <span class="p">=</span> <span class="p">[[</span><span class="s">&quot;Hello&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s">&quot;GoodBye&quot;</span><span class="p">]]</span>
<span class="kd">let</span> <span class="nv">finalStrings</span> <span class="p">=</span> <span class="n">strings</span><span class="p">.</span><span class="n">flatMap</span><span class="p">({</span> <span class="nv">$0</span> <span class="p">})</span>
<span class="bp">print</span><span class="p">(</span><span class="n">finalStrings</span><span class="p">)</span> <span class="c1">// [&quot;Hello transformed&quot;, &quot;Goodbye transformed&quot;]</span>
</div></code></pre><h3>CompactMap</h3><p>This function is frequently used with sequences that contain optionals. It is a safe way to traverse an array, and safely unwrap the value, and return the new sequence</p><pre><code><div class="highlight"><span></span><span class="kd">func</span> <span class="nf">compactMap</span><span class="p">&lt;</span><span class="n">ElementOfResult</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">transform</span><span class="p">:</span> <span class="p">(</span><span class="n">Base</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">ElementOfResult</span><span class="p">?)</span> <span class="kr">rethrows</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">ElementOfResult</span><span class="p">]</span>
</div></code></pre><p>For example:</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">optionals</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">?]</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">finalOptionals</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]</span> <span class="p">=</span> <span class="n">optionals</span><span class="p">.</span><span class="n">compactMap</span><span class="p">({</span> <span class="nv">$0</span> <span class="p">})</span>
<span class="bp">print</span><span class="p">(</span><span class="n">finalOptionals</span><span class="p">)</span> <span class="c1">// [1, 6, 7]</span>
</div></code></pre><h2>Array Slicing</h2><p>Slicing arrays, and getting specific ranges of arrays in swift can be slightly tricky as opposed to other programming languages.</p><h3>Ranges</h3><p>Starting in Swift 5, you can use the subscript of an arrays range, to get specific parts of an array. You use the swift built in Range type for this.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">test</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">test2</span> <span class="p">=</span> <span class="n">test</span><span class="p">[</span><span class="mf">0.</span><span class="p">.&lt;</span><span class="mi">2</span><span class="p">]</span> <span class="c1">// Give us the indices from the first array 0 up to, but not including the 2nd zero based index.</span>
<span class="bp">print</span><span class="p">(</span><span class="n">test2</span><span class="p">)</span> <span class="c1">// [3, 2]</span>

<span class="kd">let</span> <span class="nv">nums</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">99</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">nums2</span> <span class="p">=</span> <span class="n">nums</span><span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="mi">5</span><span class="p">]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span> <span class="c1">// [10, 3, 4, 2, 11, 14]</span>
</div></code></pre><h3>Prefix/Suffix</h3><p>There are also built in swift functions for getting the beginning and end sections of an array. All you need to do is pass the X number of prefixed or suffixed values you want from the array as a parameter in the function. Prefix is for the first X values from the array, and suffix is for the last X values you want from the array.</p><pre><code><div class="highlight"><span></span><span class="kd">let</span> <span class="nv">longNums</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">88</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">312</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">firstThree</span> <span class="p">=</span> <span class="n">longNums</span><span class="p">.</span><span class="kr">prefix</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">lastThree</span> <span class="p">=</span> <span class="n">longNums</span><span class="p">.</span><span class="bp">suffix</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="bp">print</span><span class="p">(</span><span class="n">firstThree</span><span class="p">)</span> <span class="c1">// [10, 3, 2]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">lastThree</span><span class="p">)</span> <span class="c1">// [99, 100, 312]</span>
</div></code></pre><h2>Conclusion</h2><p>And thats it! You are now a Swift Array master, so give yourself a pat on the back. Coming soon we will be taking the arrays, and giving some real life application in Leetcode Problems. We will go over common tips &amp; tricks you will encounter in Leetcode array problems. Stay Tuned!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftrefresher.com/about/about</guid><title>About</title><description>A little about myself ðŸ˜„</description><link>https://swiftrefresher.com/about/about</link><pubDate>Thu, 3 Mar 2022 22:15:00 -0500</pubDate><content:encoded><![CDATA[<h2>Welcome!</h2><p>Hello everyone! My name is Alex Stevens, and I decided to do what a million other people have already done. Start a Swift blog. I feel this will be a good way to advance my iOS domain knowledge, as well as serve as a point of reference for future job interviews. I plan to cover all aspects of iOS Development from Computer Science algorithms, to App Extensions, to SwiftUI/Combine. I hope everyone joins me in on this journey, and I hope this will be a good resource to any iOS Engineer out there, no matter what part of your journey you are on. From a new grad, or a seasoned engineer looking to crack into the mobile development space, welcome! --Alex</p>]]></content:encoded></item></channel></rss>